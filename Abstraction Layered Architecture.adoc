= Abstraction Layered Architecture
:doctype: article
:encoding: utf-8
:lang: en
:toc: left
:imagesdir: images
:source-highlighter: highlightjs
:highlightjs-theme: Docco
:partnums:

//:stylesheet: asciidoctor-default.css
//:stylesdir:

[big]*Engineering the structure of software*




image::BOSS_Great_Wall.jpg[BOSS_Great_Wall.jpg,900, title="*The large scale structure of the universe - what should the structure of software look like?*"]




// blame J R Spray

John R Spray

Last update: 2022-07-25

This online book is a work in progress. Feedback is welcome. Please send to johnspray274<at>gmail<dot>com

---


== Synopsis

Intuitively, good quality software would allow you to read and understand any one part of the code without also having to read and understand any other part. I call this zero coupling. We are taught the meme _loose coupling and high cohesion_. It is said that a zero coupled system would not do anything. But this is only because we confuse design-time coupling with run-time communications. It is entirely possible for parts of a system to have zero knowledge about one another at design-time and still communicate at run-time. We define the word _coupling_ to mean design-time coupling in this book. That's the coupling that matters. By _design-time_, we mean any time you are reading, writing or understanding code in one module, how much to you have to know about code inside other modules. Modules in conventional code tend to have a lot of coupling in the form of collaboration. ALA converts that collaborative coupling into cohesion in a new module.

ALA is a set of three architectural constraints:

* The only unit of code is an abstraction.

* The only relationship allowed is a dependency on an abstraction that is significantly more abstract.

* All abstractions must be small - as a guide, less then about 500 LOC.

Many patterns and properties emerge from these three constraints. These are explored throughout this book. But first let's elaborate on these three constraints.


[big]#*The only unit of code is an abstraction*#

[.float-group]
--
image::abstracttree.jpg[float="right"]

Abstractions are fundamental to the constraints.

An abstraction is a learnable idea or concept. Once learned it becomes part of your language.

In conventional methods, a system is broken into smaller pieces that we call modules, components or classes. These modules, components or classes tend to have a fixed arrangment with another (although an individual piece may be substitutable). This fixed arrangement leads to implicit collaborate with one another to form the system. They are like jigsaw pieces. Specific pieces fit together in a specific way to make a specific picture. The system is not explicit, it is just the collaboration of the individual parts.

In contrast, abstractions are like lego pieces. These pieces are general and can be composed in an infinite variety of ways. A specific arrangement is an explicit design in itself. It can be varied without changing the abstractions it uses. 
--

Abstractions have no knowledge of one another, nor the system that uses them.

****
All implicit collaboration between modules in conventional architecture becomes explicit code inside a new abstraction in a higher layer in ALA.
****

This first constraint means that the ALA equivalent of a _module_ is an _abstraction_. The distinction is crucial. Modules that are not good abstractions only provide encapsulation. The term _encapsulation_ means hiding details at compile-time, but not necessarily at design-time. Abstractions are what our brains use, so only abstractions hide details at design-time. 

Abstractions are the only mechanism that provides design-time _information hiding_. When David Parnas coined the term _information hiding_ he meant at _design-time_. Unfortunately there is a popular meme that _information hiding_ means _encapsulation_. The same idea of design-time information hiding has other names such as Alistair Cockburn's _protected variations_, and Robert Martin's version of the _OCP_ (open closed principle). 

In the absence of direct computer language support for abstractions, ALA generally implements  abstractions as source files (like modules in C). The file usually contains one class, but may contain a small number of classes, interfaces, enums, delegates, typedefs, functions, etc.

Inside an abstraction, there are no dependency rules, or any organisational rules for that matter. It is all considered cohesive code. So internally, abstractions are small balls of mud.

Charles Krueger pointed out that _abstraction_ and _reuse_ are two sides of the same coin. More abstract means more reusable. More abstract also tends to mean more stable because a more abstract idea is drawn from more examples, and is therefore a more ubiquitous, more fundamental idea. The abstraction 'squareroot' has been stable for thousands of years despite the fact that new instances of its use occur every day.

Software libraries tend to be good abstractions because they were written without knowledge of who will use them. If we conceive of and write abstractions similarly, without knowledge of the code that will use them, we will also get good abstractions. However, we also need to build useful abstractions. This will require some knowledge of what sorts of applications we are wanting to build. We call that the domain, and the abstractions are called domain specific abstractions.



[big]#*The only relationship is a dependency on a more abstract abstraction*#


The second constraint is that dependencies must be on abstractions that are significantly more abstract (than the abstraction whose implementation has the dependency).

When we use a more abstract abstraction, for example, when a function that calculates standard deviation uses a function that calculates squareroot, the dependency is only on the concept of squareroot. As a concept, squareroot is stable and learnable. So a dependency on a more abstract abstraction is a dependency on a concept that is relatively stable. Because of this stability, there is zero coupling between the code that _implements_ standard deviation and the code that _implements_ squareroot.

For this to work, the abstraction being used must be significantly more abstract than the one whose implementation code uses it.

*Communication between instances of peer abstractions* 

[.float-group]
--
image::collaboration.jpg[float="right",title="Collaboration between abstractions is illegal"]


Seemingly, communication is needed between peer abstractions to make a system work. However, in ALA, a dependency from one abstraction on the interface of another is illegal. For example, if the code implementing standard deviation were to, say, output the result directly to a peer module like a display, it would destroy the standard deviation abstraction. Even if the dependency is on the interface of display, the code in standard deviation would be coupled to a concept that is not more abstract. Standard deviation would no longer be easily learnable as a concept and it would no longer be reusable without dragging display with it.

Furthermore, over time, the fixed arrangement between the standard deviation function and the display function is likely to lead the display function to provide specifically what the standard deviation function needs. So both functions would now just be specific parts of a specific system. They would be collaborating.
--

In ALA a more specific abstraction in a higher layer represents the system. This abstraction calls the standard deviation function and then calls the display function, or arranges for this to happen in some way.

*Using objects instead of functions*

We don't particularly like the system abstraction in the higher layer handling the data itself. We prefer the system abstraction's job is just to compose the two peer abstractions - to wire them together.

In functional programming we can compose functions and have the data automatically flow from one to the next without handling it ourselves. To handle state and side effects on the external world without having to pass them in to the functions, we can use monads. Functional programming using monads is ALA compliant (provided the monads are good abstractions, which they usually are, because they are built to be composable building blocks).

ALA essentially brings the benefits of functional monad programming to the world of plain old objects. Because they are of plain old explicit classes, they are easier to understand than monads, and easier to write, which is essential if they are to be at the abstraction level of the domain.

These plain old objects have multiple ports with can use different programming paradigms, not just data flow.  

For example, we make _standard deviation_ and _display_ classes with I/O ports. Instances of them can then be wired together by the _system_ abstraction. While the standard deviation and display abstractions know nothing about each other, the instances can communicate directly at run-time. As we shall see shortly, the next layer down will provide an abstract interface which we call a programming paradigm.


*All dependencies are knowledge dependencies*

A dependency on an abstraction means you need to understand the concept the abstraction represents. We often call it a knowledge dependency. You could not understand the code that calculates standard deviation without first knowing about the concept of squareroot. However, to understand the code that calculates standard deviation does not require knowledge of the concept of a display, so that dependency is illegal.

Going one layer up, to understand the code in the system abstraction requires knowledge of both the concept of standard deviation and the concept of display. It is fine for the system to have dependencies on both so it can compose a standard deviation and a display.

Abstractions that are more abstract become part of your language. We take this for granted when we use library abstractions, such as squareroot. In ALA we are using this effect for all relationships up to the application.



*Good and bad dependencies*

[.float-group]
--
image::dependencyimage.png[dependencyimage.png,400,float="right"]

Conventional code contains both good and bad dependencies.

Good dependencies are ones on abstractions such as math library classes. There will typically be many bad dependencies. These bad dependencies were put there for different parts of a program to inter-communicate. They are also used to break a program up into smaller but more specific pieces. Bad dependencies make the dependency diagram look like the one on the right. My partner says these look like two ferris wheels engaged in a mating act. Even if there are no cyclic dependences, there are still typically many bad dependencies. 

In ALA, both types of bad dependencies are illegal. Normally in conventional code we don't distinguish between good and bad dependencies. We consider them all to be necessary if the system is to work. But it turns out that systems can be built using only good dependencies.

Good dependencies are not just good - they are really good. We want as many of them as possible, because then we are reusing our abstractions. Bad dependencies are not just bad - they are really bad. They cause a growing tangled network of complexity.
--

Since bad dependencies are illegal in ALA, how do parts of the system communicate? Each bad dependency becomes a line of code inside a higher layer abstraction. That line of code connects two instances of abstractions. There it is cohesive with other lines of code that connect other instances of abstractions to make a system or a user story. 

If you think about it, circular dependencies come about because there is circular communications. When you stop representing communications with dependencies, and start representing them with wiring code, circular wiring makes perfect sense. When you use only knowledge dependencies, the whole dependency problem just goes away.

Association relationships in the UML class diagram are bad dependencies, and are illegal in ALA. The only legal UML class relationship is composition (filled diamond arrow), and then _only_ if the class being used is more abstract. Now when you use such an abstraction you refer to it by name, not use an arrow on a diagram. You wouldn't draw line on a diagram to a library class. So if you draw a UML class diagram of an ALA application, you will just get disconnected boxes sitting in space. They will be arranged in layers as described below, but there will be no lines at all. The UML class diagram is not only not useful in ALA, it is the cause of much unnecessary complexity in conventional code.

*Metrics*

Unfortunately metrics do not understand abstractions. For example, CBO (Coupling of objects), which is the total number of classes with dependencies to or from a given class, does not distinguish between good and bad dependencies.

ALA recognises the importance of using abstractions and composability dealing with complex systems. If metrics don't also take into account this importance, they cannot work well.

A consideration for calculating CBO is whether or not to include library classes. Intuitively we know that library classes are abstractions. They become part of our language. So we feel they shouldn't be included in the metric. 

In ALA we can extend this reasoning all the way up the layers. Abstractions are always just extending the language that we use. Relationships on them should not be included in a metric that measures coupling. If the metric could first identify all the abstractions, and then identify which abstractions are significantly more abstract than others, then it could just count bad dependencies. We would then have a really useful metric.



*Emerging layers* 

[.float-group]
--
image::Layers.png[Layers.png, 600, title="Abstraction layers", float="right"]


Because of the constraint that an abstraction that is depended on must be significantly more abstract, abstractions form layers. This gives the architecture its name: abstraction layered architecture. We give the layers names that reflect the types of abstractions that tend to go in them - _application layer_, _domain abstractions layer_ and _programming paradigms layer_. Each layer becomes a folder and a namespace.

For large applications, another layer called _features layer_ or _user stories layer_ comes into the picture between the application and domain abstraction layers.
--

There is no 'hierarchical' structure in ALA. In other words, abstractions cannot be contained within abstractions. There is no analog of a sub-module or sub-component - no such thing as a sub-abstraction. Abstraction layers replace hierarchical containment. This is because lower layer abstractions must be public for reuse, not hidden inside an encapsulation hierarchy. 

Once you know the set of abstractions available in lower layers, it is easy to read and understand code in higher layers that use instances of them. Reading a line of code that uses an abstraction by name is like reading any other line of code. A good abstraction is when we don't need to follow the indirection and go and read the code that implements the abstraction. For example, when we see a use of squareroot, if our brain has already learned he concept of squareroot once, we can just stay in the context of the code that is using the squareroot. Squareroot is just part of the language. ALA is about achieving that level of readability for every single dependency in the entire application. 


[big]#*All abstractions must be small*#

[.float-group]
--
image::smalltree.jpg[smalltree.jpg,200,float="right"]

The final constraints prevents us from conforming to the first two constraints by simply putting everything into one big abstraction. That's obviously not desirable, so we need this constraint to force us to create abstractions from which we can compose applications. 

The application layer is where code will accumulate as more user stories or features are added. Eventually it will be necessary to insert a new layer for this type of abstraction.

Abstractions are internally highly cohesive, which means that all code inside them is inter-related. Internally they are a small ball of mud. If that highly interrelated code is to be understood, it needs to be small. 

A rule of thumb is around 100 to 500 lines of code. If the code is in diagram form (which will often be the case for reasons we will explain later), we should limit the size to 100-500 nodes plus edges.
--

If an abstraction contains more than 500 lines, it is starting to get over the brain limit for other programmers to understand. If abstractions average less than 100 lines of code, we will have more abstractions than we needed to, and burden ourselves with an unnecessarily high number of them to learn. The sweet spot is somewhere in between.


[big]#*Other emergent patterns*#

[.float-group]
--
image::ropespiral.jpg[ropespiral.jpg,200,float="right"]

ALA emerges many other patterns and properties. Many of them are already known about in software engineering, which is not surprising - such things as DSLs (Domain Specific Languages), Dependency Injection, Composite and Decorator patterns, monad like composition, etc. However, there are often subtle but important differences. For example the observer pattern (publish/subscribe) can be used to achieve calls going up the layers at run-time, but may not be used between abstractions in the same layer. The subscribers's reference to the publisher would be an illegal dependency. A line of code in an abstraction in a higher layer must do the subscribing, which is effectively what the wiring pattern described below is.
--

Inheritance is not used in ALA. We only use composition because inheritance breaks abstractions.

[big]#*Wiring pattern*#


[.float-group]
--
image::WiringPattern.png[WiringPattern.png, 500, title="*Wiring pattern frequently used in ALA*", float="right"]

I use the wiring pattern shown on the right frequently to build ALA applications. 

Abstraction A in the application layer has legal dependencies on abstractions B and C in the domain abstractions layer. B and C have dependencies on D in the programming paradigms layer.

D is a programming paradigm interface. This interface is not owned by B or C. It is its own abstraction representing a compositional idea, such as Dataflow or UI construction.

B and C have ports of type D. B's port is implemented as a field in the class, and C's port is implemented by implementing D's interface.

A can create an instance of B and an instance of C and wire them together because they have compatible ports. Wiring causes the instance of C, cast as the interface, to be assigned to the field in B. 

While abstraction B and abstraction C know nothing about each other, the instances of B and C can communicate with each other at run-time.
--

[big]#*Going forward*#


When the idea first occurred that zero coupling could be achieved through the stated constraints, we did not know what it would be like, or even if it was possible, to create a working system. Our experience since then is that zero-coupling has always been possible, but coming up with the abstractions is sometimes obvious and sometimes not so obvious. Also, some (but not all) conventional habits, languages, patterns, and architectural styles will conspire against you to break the fundamental constraints.

In time there will be tools to help enforce the ALA constraints. As Robert Martin points out, an indication of a good abstraction can be the number of times it is used, but ultimately this may require AI. When that is achieved, it will be possible to automatically refactor legacy code into ALA code. 
 




---


[big]#*A tiny example*#

Every chapter has an example, and we do the same here in the synopsis. Unlike most pedagogical sized examples, these examples progressively become non-trivial. Yet because of ALA's power, they remain uncomplicated and easy to understand.) 

 Requirement: Make a switch control a light. 


[plantuml,file="diagram-switch-light.png"]
----
@startdot
digraph foo {
# edge [color=green]
size="1!"
graph [rankdir=LR]
node [shape=Mrecord]
Switch -> Light
}
@enddot
----

The diagram above is not documentation. Nor is it a high-level architectural view of the solution. It is the solution. It contains all the detail needed for an executable application. The diagram is literally compiled. Let's do that now by hand:

*Application layer*

.System.cs
[source,C#]
....
var system = new Switch().WireTo(new Light());
system.Run();
....

Given this code, it is not difficult for any programmer to write the necessary Switch and Light domain abstractions, together with a dataflow programming paradigm abstraction to make that code execute.

In conventional code, we would likely have broken the system up into two modules, one for the switch and one for the light. The switch might directly call a method in the interface for the light, or vice versa. In ALA you can't do that. The concepts of Switch and Light, already handed to us as abstractions in the words of the requirements, must remain as abstractions. They can't know about or communicate with one another and they can't know about the specific system.

A concept of dataflow is invented to allow _instances_ of Switch and Light to communicate at run-time. Dataflow is an even more abstract abstraction. It resides in the programming paradigms layer. It is a steam of data without end. It is not a specific interface of either Switch or Light. It allows Switches and Lights to be wired arbitrarily to anything using the same dataflow concept and data type.

The _system_ is also an abstraction, albeit a more specific one than Switch and Light. Instances of it can be reused in a building. Its purpose is to know about the system comprising a light and a switch connected together. It knows about Switches,  Lights and Dataflows as abstract concepts but doesn't know anything about their implementation details. 

The system diagram is a direct, formal restatement of the requirements. So the diagram is three things in one: The formal statement of requirements, the high level architecture, and the executable. One source of truth for all three. Conventional software engineering usually has three different documents for these which must be kept synced.  

When the program is this small, it looks like we just created four abstractions when two modules would have done. However, by creating an application layer abstraction to represent the system level knowledge, and a programming paradigm layer abstraction to represent the concept of dataflow, we make several powerful improvements to the code that are important as the application scales:

. There is now an explicit place that cohesively implements the requirement instead of having the requirement's implementation distributed in an obviscated way inside Switch and Light. What is loose coupling between modules in conventional code becomes cohesive code completely contained inside a higher (more specific) abstraction in ALA. Changes to the system are made in this one place.

. The code inside all the abstractions: System, Switch, Light and Dataflow are zero-coupled with one another. 

. Being abstractions, Switch and Light are reusable. They are reusable in the same application or in other applications in the domain. Dataflow is even more reusable.

. Programming paradigms provide the _meaning_ of connecting together two instances of domain abstractions. We can use multiple different programming paradigms in the one top level design. ALA is said to be polyglot in programming paradigms. This makes it very expressive.

. Switch and light do not have to have a shared understanding for the interpretation of data (a shared language). We think that shared languages are necessary because people need a shared language to communicate. So we tend to create modules that work in the same way. These are sometmes refered to as contracts. If Switch and Light were modules, they would need to agree on something like _true_ means _on_ and _false_ means _off_. In the ALA version, this type of coupling is gone. The knowledge about interpretation of data is wholely contained inside the system abstraction. This may seem trivial in this simple case, but it becomes enormously significant in larger programs and distributed programs.

. If the instances of Switch and Light are deployed to different locations, the Switch-Light system is still a single cohesive abstraction describing that system. Normally programs are decomposed first into modules by physical locations, but ALA always composes first by user stories. This will also be highly significant as the system scales up.

. Switch and Light are testable with unit tests.

. Testing the system abstraction is exactly acceptance testing. In ALA, you always test with dependencies in place, but you mock the ports. Just as you would not mock out a dependency such as squareroot, you do not mock any dependencies in ALA, because all dependencies are knowledge dependencies. Testing the system abstraction means testing that the switch and Light system works.

. The writing of the Switch and Light abstractions can be handed off to different individuals or teams because as abstractions they know nothing about each other, and they know nothing about the System. In fact abstractions will be better quality if the teams do not collaborate with each other so that the abstractions themselves do not collaborate. (Variation of Conway's law.)

. In terms of methodology, instead of _decomposing_ the Switch-Light system into parts, we _composed_ it from abstractions. This point may seem subtle at first, but it is profoundly important. The method of dividing a system into smaller parts until the parts are small enough to implement is arguably the prevalent approach in traditional software engineering. However it tends to result in parts that are more specific than the system (can't be reused for anything) and generally inter-collaborating parts that have implicit knowledge of each other to work.

Here is skeleton code of the two domain abstractions. 


*Domain abstractions layer*


.Switch.cs
[source,C#]
....

// domain abstraction
class Switch
{
    // port
    private IDataFlow<bool> output;
    
    // called from internal code (not shown) when it detects a hardware change
    private void SwitchChange(bool newState)
    {
        output.Send(newState);
    }
}
....



.Light.cs
[source,C#]
....

// domain abstraction
class Light : IDataFlow<bool>
{
    // port
    IDataFlow<bool>.Send(bool data)
    {
        if (data) // turn on the light
        else // turn off the light
    }
}
....


Each of these abstractions implements a _port_, which allows instances of them to be wired using the programming paradigm, DataFlow.

Here is our programming paradigms layer which contains IDataFlow:


*Programming Paradigms layer*


.DataFlow.cs
[source,C#]
....

// Programming paradigm: DataFlow
interface IDataFlow<T>
{
    void Send(T data);
}
....


In ALA, we frequently use a *wiring pattern*, as depicted by the diagram in Figure 4, which consists of instantiating domain abstractions and wiring them together by ports that use an even more abstract interface representing a programming paradigm. The wiring pattern is quite ubiquitous, and therefore comes from a foundation layer that resides below the Programming Paradigms layer: 


*Foundation layer*


.Wiring.cs
[source,C#]
....

public static object WireTo(this object a, object b)
{
    // using reflection:
    // 1. Find a private field in object "a" that matches in type an interface implemented by object "b".
    // 2. Assign object "b" to that field in object a.
    // 3. Return object "a".
}
....

Note: A basic implementation of WireTo is listed in Chapter Two. You can get the source for a WireTo extension method from one of the Github repositories for the example projects in several following chapters.

Note: ALA does not require the use of reflection. I like to use reflection because it allows me to use an extension method to get a WireTo operator implemented for all domain abstractions. It allows me to make specifying the port name optional. It also allows me to make the port fields in the class private so they do not look like part of the public configuration interface to the layer above.

If you are generating wiring code from the diagram automatically using a tool, and you make the port fields public, you could generate code like the following: 

.Application.cs
[source,C#]
....
new Switch().output = (IDataFlow<double>) new Light();
....


Now that we know how to express requirements by composition of domain abstractions, let's quickly demonstrate the ease of maintenance of our application:

Requirement: Add a sensor to turn on the light when the switch is on and it is dark. And give a feedback indication:

(For these small examples, we will manually generate code from the diagrams.)



[plantuml,file="diagram-switch-light-sensor.png"]
----
@startdot
digraph foo {
# edge [color=green]
size="1.5"
graph [rankdir=LR]
node [shape=Mrecord]
AndGate [label="AndGate"]
Sensor [label="<f0> Sensor|<f1> 0.5"]
Switch -> AndGate -> Light
Sensor -> AndGate -> Indicator
}
@enddot
----


.Application.cs
[source,C#]
....

var andGate = new AndGate();
new Main
    .WireTo(new Switch()
        .WireTo(andGate
            .WireTo(new Light())
            .WireTo(new Indicator())))
    .WireTo(new Sensor(threshold:0.5)
        .WireTo(andGate))
    .Run();
....


We just invented some new domain abstractions: AndGate and Sensor, again directly implied by the requirements.

One of the domain abstraction instances has a configuration of 0.5. This is a threshold for expressing the requirement clause "is dark". 

Notice that this application is easier to write in this way than it would be in conventional C code. This is because the programming paradigm we are using, dataflow, suits the expression of these requirements. Most C code to do even such a simple requirement as this would likely already be messy in the way it handles run-time execution. 

The astute reader will notice that the AndGate can't implement IDataFlow<bool> twice for its two inputs. In later projects, we will show how we work around this language constraint.

You may also notice that the fanout from the output of the AndGate to both the Light and the Indicator won't work. We show how this implementation problem is solved in later projects as well.

Now that we have some reusable domain abstractions and programming paradigms, let's quickly write another trivial application:


Requirement: Turn on the light from a tick item in the Tools menu of a PC application, and give an indication in the status bar when the light is on.




[plantuml,file="diagram-menu-light-status.png"]
----
@startdot
digraph foo {
# edge [color=green]
size="3"
graph [rankdir=LR]
node [shape=Mrecord]
MainWindow -> Menu1 -> Menu2 -> TickBox -> Light
Indicator [label="<f0> Indicator|<f1> Light is Off | Light is On"]
Menu1 [label="<f0> Menu"]
Menu2 [label="<f0> Menu|<f1> Tools"]
TickBox [label="<f0> TickBox|<f1> Light"]
TickBox -> Indicator
MainWindow -> StatusLine -> Indicator
{rank=same Menu1 StatusLine}}
@enddot
----

.Application.cs
[source,C#]
....

var indicator = new Indicator( {"Light is off", "Light is On"} );
new MainWindow()
    .WireTo(new Menu())
        .WireTo(new Menu("Tools")
            .WireTo(new TickBox(label:"Light")
                .WireTo(new Light())
                .WireTo(indicator)
            )
        )
    )
    .WireTo(new StatusBar()
        .WireTo(indicator) // put the indicator on the UI
    )
    .Run();
....

Here we are introducing some graphical UI, so we invented another programming paradigm for "UI layout". It is used between all the UI elements: MainWindow, Menu, Tickbox, StatusBar, Indicator. Wiring things together using that programming paradigm means things are arranged inside things on the UI.

Notice how ALA is a polyglot programming paradigm. We use two programming paradigms, UI layout and dataflow, in the same diagram. Notice also that we don't separate UI from business logic and data models. These are highly cohesive things from the perspective of user stories. Instead we separate the implementations of the domain abstractions. It is still easy to swap out, for example, the UI implementation. The diagram above could be implemented as a web application or a desktop application by swapping between two sets of UI domain abstraction implementations.  

Let's do an application to browse for and display a (dynamic content) CSV file on a grid, filtered by a user specified name, and sorted by names. The CSV file has headings that will display in the grid.

Actually if you already have monads in your programming library for things like sorting and filtering (such as LINQ or reactive extensions), you could just create a domain abstraction called _query_ and put all the code for the query passed into it as its configuration.

[plantuml,file="diagram-csv-to-grid.png"]
----
@startdot
digraph foo {
size="5"
graph [rankdir=LR]
node [shape=Mrecord]
MainWindow -> Menu1 -> Menu2 -> MenuItem -> Browser -> CsvReadWriter -> Filter -> Sort -> Grid
Menu1 [label="<f0> Menu"]
Menu2 [label="<f0> Menu|<f1> File"]
MenuItem [label="<f0> MenuItem|<f1> Open"]
TextBox [label="<f0> TextBox|<f1> Label = Filter by name"]
Filter [label="<f0> Filter|<f1> Column = Name"]
Sort [label="<f0> Sort|<f1> Column = Name"]
Browser [label="<f0> OpenFileBrowser|<f1> extensions=CSV" ]
MainWindow -> TextBox -> Filter
MainWindow -> Grid 
{rank=same Menu1 TextBox Grid}}
@enddot
----

The wiring between the CSVReadWriter, Filter, Sort and Grid uses a new programming paradigm that allows dynamic row and columns of data to flow.  The Grid abstraction is able to pull rows of data.

The wiring between the MeniItem and the OpenFileBrowser uses an Event-driven programming paradigm.


.Application.cs
[source,C#]
....
var grid = new Grid();
var csvReaderWriter = new CsvReaderWriter
var filter = new Filter() {Column = "Name"};
new MainWindow()
    .WireTo(new Menu()
        .WireIn(new Menu("File"))
        .WireIn(new MenuItem("Open"))
        .WireIn(new OpenFileBrowser(extensions = {"csv"} ))
        .WireIn(csvReaderWriter)
        .WireIn(filter) 
        .WireIn(new Sort() { Column="Name" })
        .WireIn(grid) { Column="Name" }
    )
    .WireTo(new TextBox(Label="Filter by name")
        .WireTo(filter)
    )
    .WireTo(grid)
    .Run();
....


Note: WireTo() returns its first operand (this). WireIn() is the same as WireTo() except that it returns its second operand. These operators support the fluent coding style being used in this hand compiled code so that we do't have to think of names for every instance of an abstraction.

The methodology we have been following is that you write the application code (diagram) first (or part of it), just focusing on expressing the requirements. This causes you to invent domain abstractions and programming paradigms. Then you come up with an execution model that will make the programming paradigms execute. For example, the two interfaces listed below might be what you would come up with for Event and PullTable. 

.Event.cs
[source,C#]
....
// Programming paradigm: Event driven
interface IEvent
{
    void Execute();
}
....



.PullTable.cs
[source,C#]
....
// Programming paradigm: TableDataFlow
interface IPullTable : IEnumerable<List<string><T>>
{
    List<string> GetHeaderLabels();
}
....


This interface is designed to handle dynamic data (types unknown at compiletime). Both Filter and Sort will also have both input and output ports of type  IPullTable. The List in the IEnumerable represents one row of the table.

Don't worry, we won't be creating new programming paradigm abstractions at this rate for long. In fact we already have most of the ones we will use in all our example projects.

Notice how in the above examples, we have used software engineering patterns we already know about, just in a different way. There is DSL (Domain Specific Language), Dependency Injection (which is what the WireTo operator does), Event driven programming, XAML-like UI layout (without the XML), RX (Reactive programming), monad-like wiring up, and the fluent style. 

Notice how the application diagram in each case is both a direct representation of the requirements and executable. Application diagrams do not leave out details from requirements because ultimately they are a complete expression of them. Instead, they leave out details of implementation.

To the extent that the requirements are cohesive, so the code that expresses them should be. For example, we do not try to separate the specific UI, I/O, business logic, persistent data etc into different modules because they are highly cohesive for a given requirement. Most other architectural patterns, such as MVC, do separate in this way, which creates coupling. Instead we reduce the problem in a different way - through the use of domain abstractions which provide reusable aspects of implementation. All knowledge and details from the requirements end up in the application layer, but that's all that goes there. 

Note: A graph-like structure is showing up in these small applications because each requirement in itself contains a graph of relationships. ALA embraces this and makes it explicit, which is why the requirements are best expressed as diagrams. In conventional code, the graph structure is still there, but it is typically obfuscated inside the modules, making it hard to trace. Worse still, the natural cycles in the graph would cause cycle dependencies, so these need to be broken by using pulling data half the time rather than pushing, or worse still, using indirections such as the observer pattern. 

Although the fluent style is a nice way to hand-compile these small diagrams, code like this with indenting and nested brackets does not scale up well for large diagrams. (It is still better than the tangled web of dependencies they would form in conventional modular code though.) But we can do better. We will not be hand-writing code like this for large applications - we will automatically generate the code from the diagrams. 

Finally, the wiring pattern used in the examples above is only one possible way of meeting the fundamental ALA constraints. For example, ALA can also be applied to functional programming using monads as domain abstractions. But we will use explicit objects with explicit classes and the wiring pattern shown above in most of our examples. The wiring itself is implemented by a field in the objects, but that is immutable. ALA may appear to be synonymous with this wiring pattern, but actually ALA is just the three fundamental constraints stated at the beginning of this introduction. 

---

////

[big]#*Chapter summaries*#

{empty} +

*Chapter 1, "What problem does ALA solve?"*

* The Big Ball of Mud

** The two constraints solve the "big ball of mud" problem by providing a pre-worked reference architecture (a meta-structure for code at the largest granularity scale). 

* Simplify down the overwhelming set of architectural styles, patterns, principles and paradigms

** ALA coherently combines a myriad of architectural styles, patterns, principles and paradigms

* An optimal reference architecture for quality attributes

** Complexity
** Readability
** Maintainability
** Testability

* The software engineer's trap

** Describes the Create, Repair, Abandon, rePeat cycle that ALA breaks.

* A short history of ALA

** How ALA was developed 

* An example

** This chapter concludes with an example that implements a thermometer. In this example, we start with typically written C code, and then refactor it step by step into ALA organised code.


{empty} +

*Chapter 2, "What does the structure look like?"*

Without explaining why, this chapter describes the code structure that emerges from applying the two fundamental ALA constraints:

* Units of code are abstractions

* ALA uses just one relationship type

** The code inside an abstraction may have a dependency on a more abstract abstraction. What to do instead for all other conventional relationship types is explained.

* Abstraction Layers

** Application layer

** Domain abstractions layer

** Programming paradigms layer

** Libraries layer

* Code organisation into folders

* How files, classes and interfaces are used

* Executable expression of requirements

* Composition not decomposition



* The emergent use of diagrams to describe the instantiation, configuration and wiring of abstractions. Code is auto-generated from the diagram. 

* If the Application becomes large, we can insert a layer called Story Abstrations above the Domain Abstraction layer. It provides abstractions to support separate diagrams for features in the application layer. This supports a plug-in architectural style. For example, the Story Abstractions layer could have an abstraction that is an object "TheMainMenu". Different features can plug heir menus items into it.

* Polyglot programming paradigms



* The ALA "composition of instances of abstractions" structure is analogous to real world composition structures such as Lego, electronic schematics, and molecules. 

{empty} +

*Chapter 3, "Why the structure works"*

Explains the theory behind the two fundamental architectural constraints:

* While an increasing number of internal validation experiments show promising results, the claim that ALA pre-solves for the software engineering problems outlined in chapter 1 is based largely on theory.

* In the field of structural engineering, a bridge is designed using theory. The theory gives us confidence that, once built, the bridge will stand. Similarly ALA uses theory to design a software structure. This gives us confidence that, once built, it will stand up to long term maintenance, be readable and testable, and have a controlled level of complexity. The following points describe this theoretical basis.

* Fundamental basis in abstraction

** We distinguish between compile-time and design-time (code-reading-time). One is when the compiler is reading the code, and the other is when the human brain is reading the code.

** Chapter 6 defines 'abstraction', and some of the overloaded meanings the word has in the software industry that cause confusion. For now we can just know that ALA code units are called abstractions (rather than classes, functions, modules, or interfaces) because an abstraction has properties at design-time which the language (compile-time) code units don't necessarily have. However, an abstraction will still usually be implemented using classes, functions or interfaces.

** By using abstractions as its unit of code, ALA shifts the idea of 'information hiding' from compile-time to design-time and from 'information hiding' from the compiler to 'knowledge hiding' from our brain.

** Consider the abstraction, SquareRoot. We can have two pieces of code: code that uses Squareroot and code that implements SquareRoot. The abstraction itself is just a concept. The two sections of code are both dependent only on this concept. At design-time they are as decoupled as the concept is stable. It's a very stable concept because it hasn't changed in thousands of years. So the two sections of code are essentially zero-coupled at design-time. Abstraction is the only mechanism we know of that has this property at design-time.

** Use of abstractions in software engineering is obviously not novel. ALA is a constraint that the only relationship allowed is a dependency on an abstraction (that is more abstract than the abstraction using it). Most conventional code is full of other types of relationships.

** ALA is therefore inherently zero-coupled (depending only on the quality of the abstractions). So ALA is said to have "Zero coupling and high cohesion", not "loose coupling and high cohesion".


* Collaboration

** In conventional code based on classes, functions, modules or interfaces, we rely heavily on compile-time encapsulation. Compile-time encapsulation is not sufficient to hide knowledge. It is entirely possible for code encapsulated inside two modules to be collaborating to achieve a higher purpose, such as a user story.

** Abstractions do not collaborate. The code that implements an abstraction does not collaborate with any other code - it just implements the abstraction. To change conventional modules to ALA we would do the following transformation. To the extent that conventional modules are collaborating to implement a feature, that knowledge is moved to a higher (more specific) abstraction that represents the feature and contains all that collaboration knowledge. There, the collaboration is expressed without coupling between multiple code units, is expressed explicitly, and is cohesive. The code left behind in the modules must be more abstract. They lose all mutual coupling and they become reusable.


* Complexity

** Zero coupling, together with limited abstraction size, keeps complexity level a constant. Most complexity models have complexity increasing at least in proportion to program size, and sometimes worse like L^m where L is program size and m is a factor such as 1.1.


* Dependencies

** Conventional code typically contains both good and bad dependencies. Good dependencies are the ones that are on abstractions, such as Squareroot function or instantiating a Filter class. Bad dependencies are all the others. There are at least two common types of bad dependencies: 1) dependencies that facilitate communication from one part of a system to another at run-time. 2) dependencies that decompose a large component into smaller (but more specialized) pieces. ALA eliminates all these bad dependencies.

** Good and bad dependencies look syntactically the same in code. They are usually function calls, method calls or the 'new' keyword. So distinguishing between good and bad dependencies is not done at the code level, but at a higher level of code structure.

** Dependencies in conventional code that facilitate communication between parts of a program become wirings between instances of abstractions in ALA. These wirings appear as normal lines of code inside another abstraction in a higher layer, where they are not dependencies.  

** Dependencies from decomposing a larger module into more specific pieces in conventional code are also eliminated using abstractions. Conventional architectural design uses a 'decomposition' based methodology. For example, it is common to separate a feature into UI and business logic, neither of which is an abstraction relative to the feature, but a specialized piece of the feature. Such decomposition tends results in coupling. Decomposition methodology has too much flexibility to break modules up in arbitrary ways. ALA first encourages us to not decompose at all, and instead uses a purely 'composition' methodology - compose from a set of abstractions that you invent. If an abstraction does become too large, we either factor out an abstraction or break into pieces that must be themselves abstractions (zero coupled with one another).  

* Gap between requirements and implementation

** ALA puts all code that has knowledge of the specific requirements in the top layer. But only code that carries details of requirements is put in the top layer. Our experience is that this constitutes around 10% of the total code making up an application. So, once the set of domain abstractions is complete, changes to requirements are generally confined to this 10% of code in the top layer.

** Because the job of the top layer is just to express requirements, the gap between stated requirements and their implementation is small. There is usually a much more direct relationship between the requirements expressed in natural language and the requirements expressed as a simple composition of instances of abstractions.

* Diagrams

** Requirements typically contain relationships that form a graph structure (a network). In conventional software, this network of relationships is distributed in the implementation code. This makes the graph itself quite obfuscated. Furthermore, we try to eliminate circular dependencies, which makes the graph even more obfuscated. ALA makes these graph structures explicit. Preferably they become diagrams. The graphs go inside their own abstractions in the top layer.


* Refactoring

** Software failure points are well understood. In addition to the quality attributes, complexity, readability, maintainability, testability, we often identify sub-causes such as coupling, dependencies, unstable classes or interfaces, circular dependencies, the large semantic gap between requirements and code, lack of reuse, syntactic noise, indirection, and the like. (Indirection appears as the common difficulty of tracing though a program that uses dynamic connections, such as the observer pattern.) The problem is we find them difficult to manage when we are also concentrating on getting things working, and doing that under a deadline. 

** Conventional development therefore usually involves two phases. In the first you concentrate on functionality. Then once you have that, you turn your attention to all these other quality attributes, and use refactoring to try to improve them. This refactoring is an ad-hoc process that really only works at a fine grained level. ALA takes a different approach. It starts with a meta-architecture that already takes care of all these quality attributes. You usually don't have to refactor unless you have broken the ALA constraints. The trade-off is that you have to spend some time to work out what the Domain Abstractions and Proramming Paradigms should be. Sometimes this is hard, especially in a new domain.  

Actually, in practice we do some refactoring. We find ourselves improving the description of an abstraction. This description pops up as a tooltip when we hover over an instance on an application diagram. This is especially true when a new person on the team is reading the diagram and needs to understand the domain abstractions without goin to their documenation comments. We also often rename the ports on abstractions so that the external point of view of an instance is easier to understand.


{empty} +

*Chapter 4, "Execution models".*

Explains how the underlying execution for each programming paradigm can be made to actually work.

** Explains the ways that the CPU executes the right code at the right time when the structures that emerge from ALA compose domain abstractions in a different or more declarative way compared to imperative execution flow.

** UI layout

** UI Navigation

** Dataflow

** Event driven

** Real world time activity flow

** Data schema



{empty} +

*Chapter 5, "Methodology"*

Describes ALA in terms of how it fits into Agile software development.

** The primary methodology is that requirements are simply 'described' in terms of 'invented' domain abstractions.

** An "Iteration zero" is used, important to get a starting set of domain abstractions and programming paradigms. The starting set will set the pattern of the whole design.

** How to go about 'inventing' domain abstraction for the first time in a new domain.


{empty} +

*Chapter 6, "The philosophy behind ALA"*

Gives the theory of why ALA works from the perspective of complex systems and how our brains work.

** Describes how the two fundamental architectural constraints are designed to mimic how our brains see the real world.

* Abstractions are learnable, stable and reusable.

** Learnable: In ALA, any code can be read as a stand-alone unit once the dependent abstractions have been learned. For example, we can read code that has a dependency on squareroot because we have learned what the squareroot abstraction is. We don't need to go and read the squareroot code. ALA constrains us to make ALL dependencies work this way.

** Stable: In ALA, all dependencies are on stable concepts. Not stable code, stable concepts, such as the concept of squareroot or the concept of events. Since stable concepts don't change, the dependent code is protected from ripple effects. The stability of the concept of an abstraction is unrelated to the code that implements an abstraction. For example, the concept of squareroot has been stable now for thousands of years.

** Reusable: As Charles Krueger has pointed out, abstraction and reuse are two sides of the same coin. By constraining dependencies to be on abstractions, we then find these abstractions being reused, which creates more dependencies on them (a good thing), which helps us consolidate them as abstractions.  

* An abstraction provides our brain a way to reason about all possible instances at once. The details of any given instance is hidden, . 



** Composition of a small number of abstraction layers in the real world as an analogy: e.g. atoms, molecules, proteins, cells, bodies.

** ALA leverages how our brains have evolved to use abstractions to understand the real world. This enables us to understand our programs in the same way.

** ALA achieves an optimal level of expressiveness in each layer. This includes the application layer which is just a formal expression of requirements in their details, but nothing else. 

** ALA uses layers instead of encapsulation hierarchies. We want public abstractions for maximal reuse, not private specialized parts for a specialized use.

** ALA does not use 'models' for its structure or architecture. Models, as the term implies, can leave out details arbitrarily. These details are unknowns and will come back to bite us. ALA only leaves out details by putting them inside abstractions, which renders them harmless. (Models differ from diagrams, which ALA can use.)



{empty} +

*Chapter 7, "ALA compared with...".*

** Unsurprisingly, the two fundamental constraints of ALA emerge most architectural styles and patterns that we already use in software engineering. 

** ALA makes use of them simultaneously.

** Interestingly, most of the patterns appear in a modified form. 

** Examples are: Layers, Dependency injection, Observer pattern, DSLs, Pipes and Filters, Components and connectors, Monads.

** Very surprisingly, some patterns are odds with ALA. Examples are MVC and UI/Businesslogic/Database tiers. And says the UML class diagrams are completely evil. 

** It is interesting to compare and/or contrast ALA with all these conventional engineering styles and patterns. 

{empty} +

////

This online book is a work in progress. ALA is a research in progress. Please don't hesitate to provide feedback to the e-mail address given at the top.

I would like to acknowledge the help of Roopak Sinha at AUT (Auckland University of Technology) for his significant academic contributions and ideas for ALA, and the contributions of many students who have implemented ALA projects, and helped refine the ALA methodology. 

link:Abstraction_Layered_Architecture_Paper_ECSA_2018.pdf[ALA Paper presented at ECSA 2018]

link:Building_Maintainable_Software_Using_Abstraction_Layering_IEEE_TSE_2022.pdf[ALA Paper published in IEEE Transactions on Software Engineering 2022]



// https://AbstractionLayeredArchitecture.com/Abstraction_Layered_Architecture_Paper_ECSA_2018.pdf[ALA Paper presented at ECSA 2018]


:partnums:
:sectnums:

include::ChapterOne.adoc[]

include::ChapterTwo.adoc[]

include::ChapterThree.adoc[]

include::ChapterFour.adoc[]

include::ChapterFive.adoc[]

include::ChapterSix.adoc[]

include::ChapterSeven.adoc[]

include::ChapterEight.adoc[]







