= Abstraction Layered Architecture
:doctype: article
:encoding: utf-8
:lang: en
:toc: left
:sectnums:
:imagesdir: images
:source-highlighter: highlightjs
:highlightjs-theme: Docco

[.float-group]

[big]*Engineering the large scale structure of code*

--
image::BOSS_Great_Wall.jpg[BOSS_Great_Wall.jpg,900, title="*The large scale structure of the universe*"]


--

// blame J R Spray

John R Spray

Last update: 2020-11-10


[big]#*The real quick summary*#


Fundamentally, ALA is two architectural constraints when writing software:


- The only relationship allowed is a dependency on an abstraction. That abstraction must be significantly more abstract than the abstraction containing the dependency. No other relationships are allowed (or needed).

- All abstractions must be small - e.g. 100-500 LOC (or diagram nodes).

Patterns and properties emerge from these two constraints. In many ways they are similar to ones we already know, which is not surprising. However, there is often subtle but important differences. For example, one emergent property is "zero coupling and high cohesion". This is qualitatively different to the familiar "loose coupling and high cohesion".  


[big]#*Summary*#


*Chapter 1, "What problem does ALA solve?"*

** These two constraints solve the "big ball of mud" problem by providing a pre-worked reference architecture (a meta-structure for code at the largest granularity scale). 

** The meta-structure pre-solves for the following quality attributes: Complexity, Readability, Maintainability, Testability




*Chapter 2, "What does the structure look like?". Without explaining why, this chapter describes the code structure that emerges from applying the two constraints:*

* An abstraction is usually a function or class, but can be a small group of functions, classes, delegates, enums, even variables or objects, etc. The grouping is highly cohesive code that is unrestricted in its internal relationships. An abstraction is usually represented by a source file.

* A small number of discrete abstraction layers emerge. The layers are given the standard names: Application, Domain abstractions, Programming Paradigms, and Libraries. Folders are used for these layers. Dependencies only go down the layers, not across.

* The use of ports emerges.  An abstraction is often implemented as a class with ports. Ports are implemented using plain code. 

* A common pattern that emerges is to explicitly wire together instances of abstractions that will communicate with each other at run-time through even more abstract interfaces. This is often done in the top layer, the application layer. Wiring in the top layer is done using a dependency injection operator, WireTo(). e.g. "new A().WireTo(new B());"

* The emergent use of diagrams to describe the instantiation, configuration and wiring of abstractions. Code is auto-generated from the diagram. 

* The use of programming paradigms when composing instances of abstractions. Programming paradigms are often implemented with simple, quite abstract interfaces. An example programming paradigm is "Event driven". The corresponding interface might be "interface IEvent { void Execute(); }".

* Multiple programming paradigms are used in an application. e.g. interfaces for user interface layout, events, data flows, activity flows, state machines, data schemas, and others.

* An emergent property is that the top layer code is a direct expression of requirements. Like a DSL, this direct expression of requirements is executable.

* If the Application becomes large, we add a layer called StoryAbstrations, which provides abstractions to support separate diagrams. This supports a plug-in architectural style in the Application layer.

* The ALA "composition of instances of abstractions" structure is analogous to real world composition structures such as Lego, electronic schematics, and molecules. 

* All knowledge specific to the application ends up in the application layer. This knowledge is essentially just the requirements. It is typically around 2% of the total code. All knowledge for how to actually do anything goes in the domain abstractions layer. 

* Conventional libraries generally contain good abstractions, not necessarily because their designers set out to create good abstractions, but because they couldn't know anything specific about the code that will use them. So it was not possible for the classes to be specific to anything. ALA asks us to do that for one more layer before we write the application. We call that layer the domain abstractions layer.

* Library abstractions are generally used in isolation. The code that uses a library class must handle its input and output data. In ALA, we don't want to handle data in the application. That's why we insert a layer below the domain abstractions layer called programming paradigms. This layer allows instances of domain abstractions to be wired together to communicate directly at run-time (dependency injection). Yet the classes themselves still don't know anything about each other.


* Programming paradigms provide a grammar for the way instances of domain abstractions can be composed.



*Chapter 3, "Why the structure works". Explains the theory behind the two fundamental architectural constraints:*

* While a number of internal validation experiments show promising results, the claim that ALA solves the software engineering problems outlined in chapter 1 is largely based on its design.

* Just as understanding how a bridge is designed to eliminate all its points of failure can gives us confidence that it will stand, understanding how ALA eliminates known points of failure in software can give us confidence that the resulting architecture can stand up to long term maintenance.

* While chapter 6 focuses on what is an abstraction, and why are they so important, this chapter focuses on the properties that abstractions give us in code. We focus on the known failure points in software. These failure points are things we already largely recognise, but just find difficult to eliminate - coupling, system complexity, dependencies on the unstable, indirection, and the large gap between requirements and implementation.

* Abstractions are learnable, stable and reusable.

** Learnable: In AlA, any code can be read as a stand-alone unit once the dependent abstractions have been learned. For example, we can read code that has a dependency on squareroot because we have learned what the squareroot abstraction is. We don't need to go and read the squarroot code. ALA constrains us to make ALL dependencies work this way.

** Stable: In ALA, all dependencies are on stable concepts. Not stable code, stable concepts, such as the concept of squareroot or the concept of events. Since stable concepts don't change, the dependent code is protected from ripple effects coming from its dependencies. The stability of the concept of an abstraction is unrelated to the code that implements an abstraction. For example, the concept of squareroot has been stable now for thousands of years.

** Reusable: As Charles Krueger has pointed out, abstraction and reuse are two sides of the same coin. By constraining dependencies to be on abstractions, we then find these abstractions being reused, which creates more dependencies on them (a good thing), which helps us consolidate them as abstractions.  

* The constraint that "dependencies are only allowed on abstractions" results in zero coupling. The code inside all abstractions in the system is zero coupled with one another. (So ALA achieves "Zero coupling and high cohesion", not "loose coupling and high cohesion.)

* Zero coupling, together with limited abstraction size, eliminates complexity.

* Conventional code typically contains both good and bad dependencies. Good dependencies are the ones that are on abstractions. Bad dependencies are all the others. There are two common types of bad dependencies: 1) to facilitate communication from one part of a system to another at runtime. 2) to decompose a large component into smaller (but more specialized) pieces. Both these types of dependencies are on the potentially unstable. ALA eliminates all these bad dependencies.

* Conventional architectural design uses a decomposition method. For example, it is common to separate UI and business logic. Decomposition tends to result in coupling. ALA uses a composition method. The set of abstractions being composed start out with zero coupling with one another.

* Requirements typically inherently contain relationships that form a graph structure (a network). In conventional software, this network of relationships is distributed in the implementation code. This makes the graph itself quite obviscated. Furthermore, we try to eliminate circular dependencies by introducing either the wrong kind of layering and indirections. These make makes the graph even more obviscated. This appears as the common difficulty of tracing though a program when debugging. ALA makes these graph structures explicitly represented. Preferably they become simple diagrams. The graphs go inside their own abstractions in the top layer.

* ALA puts all code that has knowledge of the specific requirements in the top layer. But only code that carries details requirements is put in the top layer. Our experience is that this constitutes around 2% of the total code making up an application. So, once the set of domain abstractions is complete, changes to requirements are generally confined to this top layer.

* Because the job of the top layer is just to express requirements, the gap between requirements and their implementation is small. There is usually a much more direct relationship between the requirements expressed in natural language and the requirements expressed in code as a simple composition of abstractions.

* An ALA application (top layer) is three things in one: The expression of requirements, the architecture documentation, and the executable.


*Chapter 4, "Execution models". Explains how the underlying execution for each programming paradigm can be made to actually work.*

** Explains the ways that the CPU executes the right code at the right time when the structures that emerge from ALA compose domain abstractions in an orthogonal way to imperative execution flow.

** UI layout

** UI Navigation

** Dataflow

** Event driven

** Real world time activity flow

** Data schema





*Chapter 5, "Methodology". Describes ALA in terms of where it fits into Agile software development*

** The primary methodology is that requirements are simply 'described' in terms of 'invented' domain abstractions.

** An "Iteration zero" is used, important to get a starting set of domain abstractions and programming paradigms. The starting set will set the pattern of the whole design.

** How to go about 'inventing' domain abstraction for the first time in a new domain.




*Chapter 6, "The philosophy behind ALA". Gives the theory of why ALA works from the perspective of complex systems and how our brains work.*

** Describes how the two fundamental architectural constraints are designed to mimic how our brains see the real world.

** Composition of a small number of abstraction layers in the real world as an analogy: e.g. atoms, molecules, proteins, cells, bodies.

** ALA leverages how our brains have evolved to use abstractions to understand the real world. This enables us to understand our programs in the same way.

** ALA achieves an optimal level of expressiveness in each layer. This includes the application layer which is just a formal expression of requirements in their details, but nothing else. 

** ALA uses layers instead of encapsulation hierarchies. We want public abstractions for maximal reuse, not private specialized parts for a specialized use.

** ALA does not use 'models' for its structure or architecture. Models, as the term implies, can leave out details arbitrarily. These details are unknowns and will come back to bite us. ALA only leaves out details by putting them inside abstractions, which renders them harmless. (Models differ from diagrams, which ALA can use.)





*Chapter 7, "ALA compared with...".*

** Unsurprisingly, the two fundamental constraints of ALA emerge most architectural styles and patterns that we already use in software engineering. 

** ALA makes use of them simultaneously.

** Interestingly, most of the patterns appear in a modified form. 

** Examples are: Layers, Dependency injection, Observer pattern, DSLs, Pipes and Filters, Components and connectors, Monads.

** Very surprisingly, some patterns are odds with ALA. Examples are MVC and UI/Businesslogic/Database tiers. And says the UML class diagrams are completely evil. 

** It is interesting to compare and/or contrast ALA with all these conventional engineering styles and patterns. 


*Examples*

Each chapter ends with an example project or two. These projects show the architecture in real code. Unlike most pedagogical sized examples, these examples are progressively non-trivial. Yet because of ALA's power, they remain uncomplicated and easy to understand. 

Here is a small example showing a common emergent pattern in ALA. In this pattern we wire instances of abstractions using an even more abstract programming paradigm interface.

Requirement: Make a switch control a light. 


.Application.cs
[source,C#]
....
var program = new Switch().WireTo(new Light());
program.Run();
....


.Switch.cs
[source,C#]
....
// domain abstraction
class Switch
{
    // port 1: output
    private IDataFlow<bool> output;
    
    // called from internally when detect hardware change
    private void SwitchChange(bool newState) { output.Send(newState); }
    
}
....



.Light.cs
[source,C#]
....
// domain abstraction
class Light : IDataFlow<bool>
{
    // port 1: input
    IDataFlow<bool>.Send(bool data)
    {
        if (data) // turn on the light
        else // turn off the light
    }
}
....





.DataFlow.cs
[source,C#]
....
// Programming paradigm: DataFlow
interface IDataFlow<T>
{
    void Send(T data);
}
....



.Wiring.cs
[source,C#]
// library
....
public static T WireTo<T>(this T a, object b)
{
    // using reflection:
    // 1. Find a private field in object a that matches in type an interface implemented by object b.
    // 2. Assign object b to that field.
}
....

Note: You can get the source for the WireTo method from one of the example projects of later chapter on GitHub.

Note: Because of the zero coupling between abstractions, our experience has been that abstractions such as the Switch and Light above are easy to write, even enjoyable to write and maintain, and also testable, as is the application itself.


Now that we know the pattern, let's quickly do some maintenance on our application:

Requirement: Turn on a light when both the switch is on and a sensor says it is dark. And give a feedback indication:

.Application.cs
[source,C#]
....
var andGate = new AndGate();
new Main
    .WireTo(new Switch()
        .WireTo(andGate()
            .WireTo(new Light())
            .WireTo(new Indicator())))
    .WireTo(new Sensor(threshold:0.5)
        .WireTo(andGate()))
    .Run();
....

Note: we just invented some new domain abstractions: AndGate and Sensor.

Note: We just invented a programming paradigm for polling. It is used between Main and its children:

.Poll.cs
[source,C#]
....
// Programming paradigm: Poll
interface IPoll
{
    void Poll();
}
....

Note: The astute reader will notice that the AndGate can't implement IDataFlow<bool> twice. In later projects, we will show how we solve this implementation problem, and allow more than one input port of the same type.

Note: The astute reader will notice that the fanout from the output of the AndGate to both the Light and the Indicator won't work. We show how this problem is solved in later projects also.




Now that we have some reusable domain abstractions and programming paradigms, let's quickly write a another trivial application:


Requirement: Turn on the light from a tick item in the Tools menu of a PC application, and give an indication in the status bar when the light is on.

.Application.cs
[source,C#]
....
var indicator = new Indicator("Light is On");
new MainWindow()
    .WireTo(new Menu())
        .WireTo(new Menu("Tools")
            .WireTo(new TickBox(label:"Light")
                .WireTo(new Light())
                .WireTo(indicator)
            )
        )
    )
    .WireTo(new StatusBar()
        .WireTo(indicator) // put the indicator on the UI
    )
    .Run();
....

Note: We just invented another programming paradigm for "UI layout". It is used between all the UI elements: MainWindow, Menu, Tickbox, StatusBar, Indicator.

Let's do an application to browse for and display a (dynamic content) CSV file on a grid, filtered by a user specified name, and sorted by Names. The CSV file has headings that will display in the grid.


.Application.cs
[source,C#]
....
var grid = new Grid();
var csvReaderWriter = new CsvReaderWriter
var filter = new Filter() {columnlambda = (name)};
new MainWindow()
    .WireTo(new Menu()
        .WireTo(new Menu("File")
            .WireIn(new MenuItem("Open"))
            .WireIn(new OpenFileBrowser(extensions = {"csv"} ))
            .WireIn(csvReaderWriter)
        )
    )
    .WireTo(new TextBox()
        .WireTo(filter)
    )
    .WireTo(new grid()
        .WireIn(new Sort() { Column="Name" })
        .WireIn(filter) 
        .WireIn(csvReaderWriter) 
    )
    .Run();
....


Note: Once again, because they are zero-coupled, the domain abstractions are easy to write. The Grid abstraction is able to pull rows of data from a table as needed.

Note: WireTo() returns its first operand (this). WireIn() is the same as WireTo() except that it returns its second operand.

Note: In addition to the new domain abstractions, we have two new programming paradigms, which we can call Events and PullTable.

Note: The methodology is that you always write the application code first, just focusing on expressing the requirements. This causes you to invent domain abstractions and programming paradigms. Then you back yourself to be able to come up with a way to make the programming paradigms work. Our experience so far is that this has never been difficult. For example, the two interfaces listed below might be what you would come up with for Event and PullTable. We then expect grid to have a field of type IPullTable<List<string>> and CsvFileReaderWriter to implement it. This interface is abstract. Both Filter and Sort will also have both input and output ports of type of IPullTable<List<string>>. The List represents one row of the table.

.Event.cs
[source,C#]
....
// Programming paradigm: Event driven
interface IEvent
{
    void Execute();
}
....



.PullTable.cs
[source,C#]
....
// Programming paradigm: TableDataFlow
interface IPullTable<T>
{
    event DataReadyDelegate SourceReady;
    List<string> GetHeaderLabels();
    IEnumerable<T> GetIEnumerable<T>();
}
....





Don't worry, we won't be creating domain abstractions and programming paradigms at this rate for long. In fact we already have most of the Programming Paradigms that we will ever use in all our example projects.

Notice how in the above examples, we have used software engineering patterns we already know about, just in a different way. There is DSL, Dependency Injection, Event driven programming, XAML-like UI layout (without the XML), RX (Reactive programming), monad-like wiring up of objects, fluent style. 


Notice how the application code in each case is both a direct representation of the requirements and executable. The requirements themselves are cohesive, and so should be the application code that expresses it. We do not try to separate UI, I/O, business logic, persistent data etc because they are highly cohesive. Most other architectural patterns do separate in this way, which creates coupling. Instead we reduce the problem in a different way - through the use of domain abstractions. All knowledge and details of the requirements ends up in the application layer.


Note: When the applications get larger we will switch to diagrams instead of the hand-generated wiring code that you see in these examples. The graph-like wiring structures in the applications is because the requirements implicitly contain these relationships. 


Note: The above examples are only one possible pattern for meeting the fundamental ALA constraints. But we will use this pattern quite often. ALA may appear to be synonymous with this pattern, but actually ALA is just the two fundamental constraints. 



This web site is a work in progress. ALA is a research in progress. Please don't hesitate to provide feedback to the e-nail address given at the end.

I would like to acknowledge the help of Roopak Sinha at AUT (Auckland University of Technology) in the writing of the paper for ECSA 2018 and  his academic perspective. 

// for web site

link:Abstraction_Layered_Architecture_Paper_ECSA_2018.pdf[ALA Paper presented at ECSA 2018]

// for pdf

// https://AbstractionLayeredArchitecture.com/Abstraction_Layered_Architecture_Paper_ECSA_2018.pdf[ALA Paper presented at ECSA 2018]



include::ChapterOne.adoc[]
include::ChapterTwo.adoc[]
include::ChapterThree.adoc[]
include::ChapterFour.adoc[]
include::ChapterFive.adoc[]
include::ChapterSix.adoc[]
include::ChapterSeven.adoc[]
include::ChapterEight.adoc[]





= Feedback

Any feedback about this article is welcomed. Please send to johnspray274<at>gmail<dot>com

