:imagesdir: images
:sectnum-start: 2


== Chapter two - The structure

In this section we describe the structure of ALA without trying to explain too much about why it looks that way. An analogy is if we described the physical anatomy of the human body without explaining how it works. How ALA works will be covered in chapter three, why this works in chapter six.  

We will describe the structure from several different perspectives. We all have different prior knowledge on which we build new knowledge. So we will each have a different insight on what ALA is. This chapter has about 10 different perspectives, some concrete, some more theoretical, some by analogy, and finally some by example in code. Use the one that makes the most sense. 


=== The unit of code is an abstraction

The only unit code in ALA is an abstraction. Not module, not class, not function. An abstraction is different from a module or class in that it must be a 'generalized conceptual idea'. It must be learnable as a concept. Many modules or classes in traditional code may already be abstractions, especially if they have no dependencies on peer modules. Abstraction goes hand in hand with reuse. Krueger said that abstraction and reuse are two sides of the same coin. Abstractions tend to be stable, as stable as their conceptual idea. When we have a dependency on an abstraction, it is simply a dependency on a conceptual idea.

Here is an example abstraction called LowPassFilter, which smooths data arriving on its input and outputs it at a slower rate. Its internal code is understandable in itself except for the abstract concept it relies on : IDataFlow. The concept of IDataFlow is the flow of data by pushing it with a Push method. 

.DomainAbstractions\LowPassFilter.cs
[source,C#]
....
using ProgrammingParadigms;

namespace DomainAbstractions
{
    /// <summary>
    /// ALA Domain abstraction
    /// Has one DataFlow input port and one DataFlow output port, both type double
    /// Smooths the incoming data and outputs it at a lower frequency
    /// The strength parameter sets the degree of filtering 
    /// (cutoff frequency relative to input frequency)
    /// and also sets the lower rate of output.
    /// e.g. if Strength is set to 10, then there is one output for every 10 input
    /// datas received.
    /// You need to understand the programming paradigm abstraction, IDataFlow,
    /// to understand this code.
    /// </summary>
    class LowPassFilter : IDataFlow<double>
    {
        public LowPassFilter(int strength, double initialState = 0.0)
        {
            this.strength = strength;
            this.state = initialState;
        }

        // ports
        private IDataFlow<double> output;

        private int strength;
        private double state = 0.0;
        private int resampleCounter = 0;

        void IDataFlow<double>.Push(double data)
        {
            state = (data + strength * state) / (strength+1);
            if (resampleCounter==0)
            {
                resampleCounter += strength;
                output?.Push(state);
            }
            resampleCounter--;
        }
    }
}
....

The abstraction has two ports. The input port is the IDataFlow<double> interface that is implemented by the class. Incoming data arrives via a Push method in this interface. We never know where the data comes from. The output port is the private field named "output". This field will be set pointing at an IDataFlow<double> input of an instance of another abstraction somewhere. We will never know where that is. How this field gets set is described later.

Because the abstraction uses ports, it has no knowledge of other peer abstractions, otherwise it would not be abstract. It is self-understandable at design-time, except for the even more abstract concepts on which it depends, the concept of DataFlow and the concept of Wiring. These are described more fully shortly.

Internally, abstractions are cohesive, which means (sticking together) or highly interconnected code collaborating for a single purpose.

In ALA, abstractions are implemented as files. The name of the file is the name of the abstraction. The code that implements an abstraction needs no internal organisation. We do not care about dependencies or any inter-relationships inside an abstraction. In fact the more cohesive everything is the better, as long as it is small. It will often be implemented as a single class or function, but may consist of a small number of items such as classes, functions, interfaces, enums, delegates, etc, as long as the total is small.

The concept of information hiding shifts when using the word _abstraction_. An abstraction is the only mechanism we know of that hides information at design-time. A module or class can encapsulate information at compile-time but does not necessarily hide information at design-time. The code inside most modules end up both explictly and implicitly coupled because they are designed to collaborate. Abstractions do not collaborate.

==== Meaning of abstraction

Unfortunately, there are now two distinct meanings for the meme 'higher level of abstraction' in common usage in software engineering. We need to take a moment to understand the difference. In ALA, abstraction means the original dictionary meaning:

 Etymology: abstract literally means _draw away_ [a common idea or concept from specific examples]

 Miriam Webster: relating to or involving general ideas or qualities rather than specific people, objects or actions.


The other meaning of 'higher level of abstraction' used in the software engineering community appears to be 'further away from the domain of the computer and closer to the problem domain'. For example, layers are often shown building up from the hardware. They can also build up from the database, or a physical communication medium, such as the layers of the OSI communications model. The application is considered the most abstract. For example, a 3-tier system or a communication stack uses this type of layering. The perception is that because we no longer have to deal with computer domain details such as data storage, communications protocols, hardware, etc, we must be more abstract. The problem with this is that the problem domain also deals with details. These details come from the real world and are described by detailed requirements. The modules that contain these details are no more abstract than those in the various domains of computing.

Conventional layering tends to use this second meaning of 'abstract'; layers are said to be more abstract as you go up. ALA layers use the original meaning of the word 'abstract' and layers get more abstract as you go down.

The layers are not the same either. To convert conventional layers to ALA, you generally just tip them on their side so that they are not layers but independent disconnected abstractions. Each of them knows about details of something but they are no longer directly connected in either direction. On their own they will do nothing. The layer above, whose job is to know the details of a specific application or system, composes instances of them by instantiating them, configuring them, and wiring them together. Conventional layers can be many. ALA layers are few.

A final note about abstractions versus the SRP (single responsibility principle). The SRP is not really a suitable way to think about abstractions. It is better to think about what details an abstraction implementation knows about. It can be a specific user story, a specific feature, a type of UI element, a type of database, a protocol, a hardware device, etc. It will contain all the cohesive knowledge about that thing. In doing so, it may have multiple responsibilities. For example an abstraction that knows about a protocol should have responsibility for both input and output. 

We will look further at what 'abstraction' means in chapter six.




=== ALA uses just one relationship type

This is the second of the three fundamental constraints. ALA uses a single type of relationship - a dependency on an abstraction that is more abstract than the one whose implementation uses it.

[plantuml,file="diagram-05a.png"]
----
@startdot
digraph foo {
// size="3!"
subgraph cluster_1
{
label="Abstraction A"
labeljust=l
labelloc=b
style=rounded 
A [ style = invis ];
}
B [label="Abstraction\nconcept B"; shape = rect; style=rounded ]
A -> B  [dir="both", arrowhead="open", arrowtail="tee", color=green, label=" requires knowledge of to understand"]
}
@enddot
----

In terms of our previous example, LowPassFilter is Abstraction A and IDataFlow is Abstraction concept B.

Notice how in the diagram the relationship arrow comes from inside A. This is significant. It is the code that implements A that requires knowledge of abstraction concept B. We never actually draw lines when using abstractions, so you wont see this type of line in ALA diagrams. We only use it here while describing this one relationship that we are allowed to use. 

B must be more abstract than A. "More abstract" means more general, not specific to A, and have a greater scope of reuse than A.

Because B is more abstract, it is more stable. ALA therefore automatically enforces the Stable Dependencies Principle. 

The relationship means that, to read and understand the code inside A, you must know the abstraction concept B - not how the insides of abstraction B work. The word "abstraction" implies that it should be learnable in a short time and easy to retain. When we get an abstraction concept is sometimes described as a moment of insight. 

Here are somemore lagel dependancies, this time from the application layer to the domain abstractions layer.

.Application\Thermometer.cs
[source,C#]
....
    new AnalogInput(channel: 2)
    .WireIn(new LowPassFilter(strength: 10))
    .WireIn(new OffsetAndScale(offset: -31, scale: 0.2))
    .WireIn(new Display(label: "Temperature"));
....

Legal dependencies from a _Thermometer_ user story abstraction on abstractions _AnalogInput_, _LowPassFilter_, _OffsetAndScale_, _Display_ and _WireIn_. The user story takes input from an analog to digital converter, filters them to remove noise, scales them to be in degrees, and displays them.

This type of dependency has zero coupling. Because of the way our brains have evolved to understand a complex world in terms of abstractions, abstractions are the only mechanism that hide knowledge at design-time. The dependency has zero coupling between all codes using the abstraction and the code that implements the abstraction.


This type of dependency also tells us explicitly what other knowledge we need in order to _understand_ code. For example, if abstraction A is __standard deviation__ and abstraction B is __square root__, then to understand the code that implements standard deviation requires knowledge of the concept of square root. That's why we sometimes refer to it as a knowledge dependency. Such a dependency always applies at design-time, as well as compile-time and run-time. Some knowledge dependencies may be implicit and so apply at design-time only. For example a dependency may be on a convention, or it may be simply the knowledge of ALA. You need knowledge of those things to fully understand the code. We want to be explicit and clear about knowledge dependencies for every bit of code inside every abstraction, so we endeavour to always state implicit dependencies in comments.

Architectures generally work by applying constraints that restrict the infinite variety of ways code could be organised. The ALA constraints seem severe at first, but after some practice they are exceedingly helpful in guiding the design. There is essentially one right way to organise the code. Sometimes the abstractions come easily and sometimes they require sustained inventive thought processes, especially in a new domain. In most domains, I usually start with the UI description in the requirements as they most readily reveal their abstractions. Then it becomes apparent that data flows must be connected to these instances of UI abstraction elements. Data transformation and state abstractions will then become apparent next. 


==== ALA's UML class diagram

All UML relationships except one are illegal in ALA. And that one is restricted to being a composition on a more abstract class. Such a relationship is always represented in code by just referring to the abstraction by name. You do not draw a line on a UML class diagram when using an abstraction. For example, you would never use a library abstraction such as _regex_ by drawing a line on a diagram to a box representing the regex class. You would just use the regex abstraction by name. If a UML class diagram were drawn of an ALA application, there would be no lines at all, just boxes in space arranged in layers.

image::ALAClassDiagram.drawio.png[ALAClassDiagram.drawio.png, title="UML class diagrams for ALA have no relation lines.", width=90%]

That diagram is not useful. That's not to say we can't use diagrams. Diagrams can be used in ALA to represent the internals of an abstraction. This is often done in the layer representing the application or user stories. It shows instances of lower layer abstractions wired together and so is close to a UML object diagram.

Following are the UML relationships you cannot use, and what you do instead.

* *Associations*: A conventional program will typically have many, many bad dependencies referred to as _associations_ in UML. Most are there because data, messages, events, execution flow, etc, need to get from one place to another in the program. These are simply illegal in ALA. The whole difficult concept of dependency management vanishes. But where do these relationships go? How can the program still work? How is it possible for messages and events to travel around at run-time? The short answer is that all these associations become a line of code inside an abstraction in the layer above. Or they become a line on a diagram composing two _instances_ of abstractions. Such lines are not relationships or dependencies - they are inside an abstraction, no different to a line of code that say calls one function and passes the result to another function. In ALA, you cannot use associations between classes. Instead you create objects in a higher level abstraction and then wire them together. The abstractions themselves will not know where their data comes from, nor where it goes.
+
Note that dependency injection or otherwise passing an object into another object doesn't remove an association relationship between the classes. It only changes the relationship from composition to association, neither of which is allowed between peer classes. In other words, in ALA you are not allowed to know about the interface belonging to another class in the same layer, nor that of an abstract base class or even an interface. Instead you use ports that use a much more abstract interface called a programming paradigm interface from a lower layer.

* *Composition*: Although the knowledge dependency relationship used in ALA can be implemented as a UML composition relationship (directed arrow with filled diamond), the ALA knowledge dependency is more constrained. It must be instantiating a class in a lower, more abstract, layer. This means that you cannot break a module up into pieces arbitrarily. Instead, you must invent abstractions. The composition relationship in ALA can go down by one or more layers, but never within a layer.

* *Inheritance*: ALA doesn't need or use inheritance. It would break the abstraction of the (more abstract) base class in the lower layer. Instead we always use composition. Inheritance is often used to provides a 'calling up the layers at run-time' mechanism by its use of virtual functions. In ALA, we do this with ordinary observer pattern (events in C#), or by passing in a method as a configuration (usually anonymously or as a lambda expression), or with the strategy pattern. 

* *Packages*: ALA does not use hierarchies or nesting. In other words, abstractions cannot be contained by other abstractions. Abstractions are never private. The reason they are never private is simple. An abstraction that is depended on should be more abstract than the abstraction using it. A more abstract abstraction needs to be public so it can be reused. ALA uses abstraction layers instead of encapsulation hierarchies. In ALA, packages would only be used as a distribution mechanism, not as part of the architecture for information hiding.
+
The word package means container. Packages are usually just a container of abstractions such as a library. We should not consider knowledge dependencies to be on the package because we can't generally learn a package. We should consider knowledge dependencies to be on the individual abstractions inside the package.
+
Let's consider the situation where a conventional package is a good abstraction in itself. Because it was implemented as a package, it's internal implementation is large (Facade pattern). Let's say our conventional package hides a lot of complex implementation and contains  abstractions that we are not interested in using in the rest of our application. For example it could be a compiler that we can invoke from our application. The thing is, if the compiler abstraction is written using ALA, it will use lots of useful abstractions for the domain of compilers and parsing. We still want those abstractions to be public for reuse. It's just that we don't want them particularly visible to the rest of our application, which is in a different domain. To solve this problem we should still make the abstractions used by the compiler abstraction public, but put them into a different DomainAbstractions folder and namespace. When we do this, we will want the DomainAbstractions folders to be qualified with the name of the domain, such as CompilerDomainAbstractions.

* *Namespaces*: In ALA, namespaces are used for the layers. For example we use namespaces such as Application, DomainAbstractions and ProgrammingParadigms. This allows abstractions in different layers that happen to have the same name. The files that implement abstractions are put inside folders that have the same names as the namespaces.
+
Note that unlike packages, namespaces are not encapsulations. Namespaces only make names unique. One 3rd party tool I used to generate dependency graphs showed dependencies on namespaces as if namespaces were abstractions. This gave a completely misleading view of the true nature of the dependencies in the code. I had to write a query for the tool to show the actual dependencies on the abstractions inside the namespaces.


=== Abstraction layers

Because the target of a dependency must be more abstract, abstractions arrange themselves in discrete layers. This is what gives the architecture its name: Abstraction Layered Architecture.

Only a small number of layers are needed. Consider that we can construct the human body with just six layers: Atoms, Molecules, Proteins, Cells, Organs, Body. Probably need another two or three to build the human brain from neurons. Small applications generally use four. The layers are given standard names that describe their level of abstraction:

image::Layers.png[Layers.png, title="Abstraction layers", width=75%]


These layers are not fixed by ALA. But we tend to return to these ones in our experience so far. Following is discussion of each layer together with example code to see how everything works.



=== Application layer

In describing example layers, we start with example code. This code will build into a complete running application so no holes are left in understanding the code level mechanics of how everything works. The accompanying bullet points then explain the high level theory of why the code is organised the way it is. The code is available here:
https://github.com/johnspray74/Thermometer[https://github.com/johnspray74/Thermometer]


.Application\Thermometer.cs
[source,C#]
....
using DomainAbstractions;
using ProgrammingParadigms;
using Foundation;

namespace Application
{
    class Thermometer
    {
        public static async Task Main()
        {
            Console.WriteLine("Wiring application");

            private ADCSimulator adc;

            adc = new ADCSimulator(channel: 2, period: 1000) { simulatedLevel = 400 };
            adc.WireIn(new LowPassFilter(strength: 10))
                .WireIn(new OffsetAndScale(offset: -200, scale: 0.2))
                .WireIn(new DisplayNumeric<double>(label: "Temperature") { units = "C"} );

            Console.WriteLine("Running application");
            adc.Run();

            Console.WriteLine("press any key to stop");
            Console.ReadKey();
        }
    }
}
....

To understand the code, you need to know the abstraction concepts on which it depends. These are:

* Data flow and ports

* ADCSimulator - simulates an analog to digital converter hardware peripheral. Has a single output port of type IDataFlow

* LowPassFilter - we already met this at the beginning of this chapter

* OffsetAndScale - has a single input port and a single output port, both IDataFlow<double>. Adds a value and Multiplies by another value the data stream passing through. 

* DisplayNumeric = has one input port of type IDataFlow. Displays the value on the console with label and optional units.

* WireIn - wires compatible ports of instances of abstractions by setting the private field in the first object that matches the interface implemented by the second object.

* In this example, Run() is called on the ADC object. For data flow wiring, we prefer pushing data through the system (from ADC to display) unless there is good reason to do otherwise.


The application is implemented by simply composing instances of domain abstractions. It instantiates domain abstractions, configures them with application specific details, and connects them together in the topology needed to express user stories or features.

The application layer contains all information at the abstraction level specific to the requirements. For example, if the user story is a thermometer, it cohesively has all the details of how to make a thermometer, but nothing else.

The application layer is three things in one: The expression of requirements, the architecture, and the executable. In conventional software development, these are three separate artefacts.

Execution typically occurs in two phases (similar to monads). In the first phase the application wires together instances of abstractions. In the second phase the network of instances executes (which is what the finalizing call to Run does in the example).



=== Domain abstractions layer

At the beginning of this chapter we had an example of a domain abstraction, LowPassFilter. Here is another example:


.DomainAbstractions\OffsetAndScale.cs
[source,C#]
....
using ProgrammingParadigms;

namespace DomainAbstractions
{
    /// <summary>
    /// ALA domain abstraction
    /// Has one input port of type IDataflow and one output port of type IDataflow
    /// (both type double)
    /// Performs y = m(x+c) like operation where x is the input and y is the output
    /// If visualized as a straight line on an x,y graph, -c is the x axis intercept
    /// and m is the slope. 
    /// You need to understand the programming paradigm abstraction, IDataFlow,
    /// to understand this code.
    /// </summary>
    class OffsetAndScale : IDataFlow<double>
    {
        public OffsetAndScale(double offset, double scale)
        {
            this.offset = offset;
            this.scale = scale;
        }

        private double offset;
        private double scale;


        private IDataFlow<double> output;

        void IDataFlow<double>.Push(double data)
        {
            output.Push((data + offset) * scale);
        }
    }
}
....

Notes on the code:

* In the particular application code above, an instance of LowPassFilter was wired to an instance of OffsetAndScale. When wired, the output field is set to the object it is  wired to, cast as the appropriate interface, in this case IDataFlow<double>.

* The input port is the implemented interface.

* The output port _output_ is private so that it does not appear as a configuration to the layer above. It is set by WireTo using reflection.

* It has two configuration parameters. Compulsory configurations are passed in the constructor.



For completeness, here are the other two domain abstractions that we used in the Thermometer application example:


.DomainAbstractions\DisplayNumber.cs
[source,C#]
....
using ProgrammingParadigms;

namespace DomainAbstractions
{
    /// <summary>
    /// ALA Domain Abstraction
    /// Ouptuts incoming data to the console with a preceding label and optional units.
    /// Has one input port of type IDataFlow which can take int, float, double
    /// The label must be passed in the constructor.
    /// The units property may be used to set the units.
    /// fixPoint Property sets the number of decimal places.
    /// You need to understand the programming paradigm abstraction, IDataFlow,
    /// to understand this code.
    /// </summary>
    class DisplayNumeric<T> : IDataFlow<T>
    {
        public DisplayNumeric(string label)
        {
            this.label = label;
        }

        public int fixPoints { get; set; } = 0;

        private string label;
        public string units { get; set; }


        void IDataFlow<T>.Push(T data)
        {
            double d = (double)Convert.ChangeType(data, typeof(double));
            Console.WriteLine($"{label}: { d.ToString($"F{fixPoints}") } {units}");
        }
    }
}
....




.DomainAbstractions\ADCSimulator.cs
[source,C#]
....
using ProgrammingParadigms;

namespace DomainAbstractions
{
    /// <summary>
    /// ALA Domain Abstraction
    /// Simulate a 10-bit ADC Analog to Digital converter)
    /// Normally an ADC is a hardware peripheral, but here we just do a software
    /// simulation of one
    /// to use as a source of data for example applications.
    /// A real ADC driver would have properties for setting the channel and period.
    /// You would create one instance of this driver for each ADC channel.
    /// It would output raw data in adc counts. Since it is a 10 bit ADC, the adc counts
    /// are in the range 0-1023.
    /// We retain the channel although it is not used by the simulated version.
    /// The simulated version has two simulation properties, one to set the simulated
    /// ADC reading
    /// and one to set the level of noise in the simulated readings.
    /// You need to understand the programming paradigm abstraction, IDataFlow,
    /// to understand this code.
    /// </summary>
    class ADCSimulator
    {
        public ADCSimulator(int channel, int period = 100)
        {
            this.channel = channel;
            this.period = period;
        }

        private int channel;  // unused on simulated ADC
        private int period;   // milliseconds
        public int simulatedLevel { get; set; } = 512; // 0 to 1023
        public int simulatedNoise { get; set; } = 0; // 0 to 1023

        private IDataFlow<int> output;

        public void Run()
        {
            var setAndForget = RunAsyncCatch();
        }

        public async Task RunAsyncCatch()
        {
            // because we are the outermost async method, if we let exceptions go, they will be lost
            try
            {
                await RunAsync();
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.ToString());
            }
        }

        Random randomNumberGenerator = new Random();

        public async Task RunAsync()
        {
            while (true)
            {
                // add a bit of noise to the adc readings
                int data = simulatedLevel + randomNumberGenerator.Next(simulatedNoise) - simulatedNoise/2;
                if (data < 0) data = 0;
                if (data > 1023) data = 1023;
                output.Push(data);
                // throw new Exception("exception test");
                await Task.Delay(period);
            }
        }

    }
}
....



As can be seen in the above examples, the domain abstractions layer contains concepts that can be composed into applications. These are typically building blocks for I/O, data transformations, and state, but many other types of abstractions are possible.

Some of these types of things may also be found in general language libraries but domain abstractions are more specific to the types of applications we want to express with them. They are specific to a domain, making them more expressive, but less reusable than general purpose language abstractions. They are reusable both within a single application and by other applications in the same domain.

Another difference between domain abstractions and typical library abstractions is the ports. This supports building functionality by simply composing them. While the composing code controls who will communicate with whom, it does not actually handle the data at run-time. The data moves directly between instances. 

A further difference between domain abstractions and typical library abstractions is that when domain abstractions are composed, the meaning of composition can be a programming paradigm other than imperative. For example the application above uses a data-flow programming paradigm. Other common programming paradigms we use are UI layout and asynchronous events. Imperative is not usually a suitable programming paradigm for the expression of requirements. Being able to compose instances of domain abstractions together with meanings that you define in the programming paradigms layer is powerful.

The domain abstractions layer and programming paradigms layer together are like a DSL (Domain Specific Language).  The domain abstractions are composable language elements with programming paradigms providing the grammar. 

It is an internal DSL because it uses the underlying language (WireTo method, & new). This allows you to easily fall back on the great flexibility of the underlying language when you need to. For example, you can pass lambda expressions as configuration properties to a domain abstraction, or you can pass in an application specific object (which is the strategy pattern).

Conventional libraries generally contain good abstractions. This is because their designers don't know anything about the specific applications that will use them. Writing domain abstractions is best done in the same way. If necessary pretend you don't know anything about the application. They need to be learnable abstractions embodying a learnable concept, not be modules designed as a partial implementation of a specific application.

Through the use of ports, abstractions know nothing of each other at design-time, yet can still communicate directly with one another at run-time. It is the responsibility of the code in a layar above to know the meaning of the communication, but not to handle the data itself. 


=== Programming paradigms layer

For the Thermometer example application, we have now seen the application code that instantiated, configured and wired four instances of domain abstractions, and we have seen the code for the four domain abstractions. They all used only one programming paradigm, _synchronus data flow_. Here is the interface for that programming paradigm: 

.IDataFlow.cs
[source,C#]
....
namespace ProgrammingParadigms
{
    interface IDataFlow<T>
    {
        void Push(T data);
    }
}
....

Programming paradigms interfaces are often this simple. Another example programming paradigm is _synchronous event driven". The corresponding interface might be: 

.IEvent.cs
[source,C#]
....
namespace ProgrammingParadigms
{
    interface IEvent { void Execute(); }
}
....

To get an idea of the variety of programming paradigms possible, here is the interface we use for the UI layout programming paradigm. In this programming paradigm, a parent UI element is wired to its contained child elements. The interface returns the WPF element of the child. This allows domain abstractions to construct the UI using underlying WPF elements. In effect, domain abstraction are wired together instead of using XAML. Both are descriptive, but XAML horrible.  


.IUI.cs
[source,C#]
....
namespace ProgrammingParadigms
{
    interface IUI { UIElement GetUIElement(); }
}
....

The Programming paradigms layer typically provides only a small set of abstract interfaces. Each provides a different meaning when the application wires two instances of domain abstractions together. ALA is said to be polyglot in programming paradigms. Examples might be Data-flow, UI Layout, Event driven, State machine transition, Data schema. 

Programming paradigms control the way the application actually executes. Execution models such as synchronous vs asynchronous, push vs pull, and fan-out and fan-in wiring are discussed in Chapter four.

Programming paradigms provide the grammar for the way instances of domain abstractions can be composed by the application.

Programming paradigms enable direct communication between instances of domain abstractions. They enable this without the abstractions themselves knowing anything about each other. 


Domain abstractions know nothing about each other at design-time, yet instances of them can communicate at run-time. We could make the application handle these communications at run-time and sort of comply with ALA. The common example would be an applicaton that calls one function which returns a result, and then calls another function passing to it the result. But we don't really want the application to be concerned with this run-time communications. The application really just wants to connect instances of abstractions together. So we insert a layer below the Domain abstractions called Programming paradigms. This layer allows instances of domain abstractions to have compatible ports that in turn allow them to communicate directly with one another at run-time. The most common programming paradogm we use is IDataFlow<T>, but many other programming paradigms are possible.



=== Foundation layer

* The foundation layer contains any very general code used to support ALA programs.

** A common pattern I use is a WireTo() extension method in the foundation layer. The application layer uses it to wire together instances of Domain Abstractions by its ports.

Here is minimal code for the WireTo method.



 Wiring.cs
[source,C#]
....
namespace Foundation
{
    public static class Wiring
    {
        /// WireTo is an extension method on the type object
        /// Wires instances of classes that have ports by matching interfaces
        /// Port name can be optionally provided for the A side.
        /// If object A has a private field of an interface, and object B implements that interface, 
        /// and the private field not yet assigned, assigns B to the field in A.
        /// uses reflection.
        /// Returns this for fluent style programming.
        public static T WireTo<T>(this T A, object B, string APortName = null)
        {
            // achieve the following via reflection
            // A.field = B; 
            // if 1) field is private, 2) field's type matches one of the implemented interfaces of B, and 3) field is not yet assigned

            if (A == null)
            {
                throw new ArgumentException("A is null ");
            }
            if (B == null)
            {
                throw new ArgumentException("B is null ");
            }

            bool wired = false;
            var BType = B.GetType();
            var AfieldInfos = A.GetType().GetFields(System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance) // do the reflection once
                .Where(f => (APortName == null || f.Name == APortName)).Where(f => f.GetValue(A) == null).ToList(); // filter to for given portname (if any) and not yet assigned 
            var BinterfaceTypes = BType.GetInterfaces(); // do the reflection once

            foreach (var AfieldInfo in AfieldInfos)
            {
                var BimplementedInterface = BinterfaceTypes.FirstOrDefault(interfaceType => AfieldInfo.FieldType == interfaceType);
                if (BimplementedInterface != null)  // there is a matching interface
                {
                    AfieldInfo.SetValue(A, B);  // do the wiring
                    wired = true;
                    break;
                }
            }

            if (!wired) // throw exception
            {
                var AinstanceName = A.GetType().GetProperties().FirstOrDefault(f => f.Name == "InstanceName")?.GetValue(A);
                var BinstanceName = B.GetType().GetProperties().FirstOrDefault(f => f.Name == "InstanceName")?.GetValue(B);

                if (APortName != null)
                {
                    // a specific port was specified - see if the port was already wired
                    var AfieldInfo = AfieldInfos.FirstOrDefault();
                    if (AfieldInfo?.GetValue(A) != null) throw new Exception($"Port already wired {A.GetType().Name}[{AinstanceName}].{APortName} to {BType.Name}[{BinstanceName}]");
                }
                throw new Exception($"Failed to wire {A.GetType().Name}[{AinstanceName}].\"{APortName}\" to {BType.Name}[{BinstanceName}]");
            }
            return A;
        }


        public static object WireIn<T>(this T A, object B, string APortName = null)
        {
            WireTo(A, B, APortName);
            return B;
        }
    }
}
....

=== Extra layers for larger applications

If a single abstraction is used for the application, then as more and more user stories are added into it, it will eventually get too large for the size constraint. Meanwhile, domain abstractions and programming paradigms are stable and do not grow larger with overall program size. They may increase in number, but it is the application that will go over the 500 line complexity limit.

ALA will need to be applied to the large application abstraction by adding a new layer below it. The requirements are likely already written in terms of abstractions, which we can use as the basis for the new layer. We call these abstractions _features_ or _user stories_ or _use cases_. We can make a layer called "Features" or "UserStories". The application abstraction becomes a composition of features. 

==== Application layer

* Instantiates a set of features or user stories for a particular application.

* Wires together certain features instances that may need to interact at run-time. Feature abstractions would have ports to enable this. A common example would be to wire a feature instance's menu items to the an instance of a menu representing the main menu.

* Another example is a feature abstraction that measures and displays a temperature may provide a port that exposes the temperature for use by anything else that needs it. Another feature abstraction that calculates a battery voltage may have an optional input port for temperature that it uses for compensation. The application could wire instances of these two abstractions together. 


.Application\Applicaton.cs
[source,C#]
....
using UserStories;

namespace Application
{
 class Main
 {
  var mainMenu = new Menu();
  var temperature = new Temperature();
  temperature.WireTo(mainMenu); 
  var batteryvoltage = new BatteryVoltage();
  batteryVoltage.WireTo(mainMenu);
  temperature.WireTo(voltage);
 }
}
....



==== Features layer

* The Features layer abstractions independently express features or user stories in the requirements.

* Creates instances of domain abstractions, configures each instance with application specific details, and connects them together as needed to express the feature story.

* Features abstractions will have ports. The domain abstractions they use will also have ports. Sometimes an external port will need to connect directly to an internal port. 

.Features\Temperature.cs
[source,C#]
....
using DomainAbstractions

namespace Features
{
  class Temperature
  {
    // ports    
    IUI menu;
    IDataFlow<int> output;
   
    displayField = new DisplayField<int>(label:"Temperature");

    menuTickBox = new MenuTickBox(label:"Temperature", shortcut:'t');
      .WireTo(displayField, "visible")
      .WireToPort(menu);
    new ADC(channel:2)
      .WireIn(new Filter<int>(200))
      .WireTo(displayField);
      .WireToPort(output)
  }
}
....



=== Folders, files, classes and interfaces


If you see an ALA application, you will find three to six folders that correspond with the abstraction layers (described in the previous section), for example:

* Application
* DomainAbstractions
* ProgrammingParadigms
* Foundation

Continuing with the idea of knowledge dependencies, the files in the Application folder have knowledge dependencies on the files in the DomainAbstractions folder. In other words, you need to know the abstractions in the DomainAbstractions folder in order to read the application abstraction's code. Similarly the code inside the files in the DomainAbstractons folder has knowledge dependencies on the files in the ProgrammingParadigms folder. There are no dependencies between the files in any folder. 

All abstrations are put into namespaces that correspond with folder names, which correspond with the layer names. Therefore we have namespaces called "Application", "Domain abstractions", "Programming paradigms", etc. This tells us which layer an abstraction comes from, and which folder it resides in.

Abstractions are implemented as files. Abstractions are often implemented as a single class, function, or interface, but sometimes an abstraction consists of a small cohesive group of them, with things like delegates, enums, variables or objects. Internal to an abstraction, they interconnect with each other unconstrained. There are no dependency rules among them inside a file. The only constraint ALA makes is that the total must be small - of the order of 100-500 lines of code. This applies to all abstractions, including the ones that make up the application itself in the top layer. 

In ALA, a class's public interface (it's public methods and properties) are only used to instantiate and configure the class from a higher layer. Only the higher layer knows what should be instantiated, how it should be configured, and how the instantiated objects should be composed together to make a system. The public interface is not used for anything the class actually does at run-time. Unlike all the other interfaces a class may use, the public interface is 'owned' by the class and specific to the class. 

All other operations are done through interfaces. Classes don't 'own' these  interfaces. They are not specific to any one class. They are not about what any one class does, or needs. They are more general so that typically many different classes will implement/accept them. Objects of different classes can then be connected together using these more general interfaces in arbitrary compositions. The implication is that classes themselves do not have association relationships. Instead they just have fields of the type of these more abstract interfaces or they implement these more abstract interfaces. We call these _ports_.

If using functions as abstractions, it can be as simple as having a higher layer function that calls lower layer functions and passes data received from one to the next. We don't often need the data in the higher level function, however, so we prefer to use classes with ports.

Any given class will typically implement/accept more than one of these more abstract interfaces. For the data-flow interfaces at least, think of them as I/O ports. This is obeyingvthe interface segregation principle, except that we do not refer to the objects that may be wired to our ports as clients. Only the class in the layer above (that uses the public interface) has the status of a client. The objects to which an object is wired are peers.

In the Application folder, you will often find a diagram. If so the, diagram is the source code. There should be a code file that is generated from the diagram. Looking at this code file may help clarify how the diagram is made to execute.

There should be a readme file that points to this website (or equivalent documentation). In ALA, we are explicit about what knowledge is needed before a given piece of code can be understood (knowledge dependencies). To understand an ALA application, you need a basic understanding of ALA (from this chapter). So that's why there should be a readme file pointing here.



=== Executable expression of requirements

This perspective puts the focus on your input information - the requirements. ALA is a methodology that finds a way to directly and succinctly describe requirements that is also executable. This is what the top layer does. It describes all the details in the requirements. Instead of having two documents, one for requirements capture and one for software source code, ALA combines them as a single artefact and a single source of truth. BDD (Behavioural Driven Design) does something similar, but only achieves it for requirements and their tests. ALA goes one step further to make the expressed requirements also the executable solution.

The code in the top layer only expresses requirement, and therefore has no implementation details. The amount of code that describes requirements is typically about 3-10% of the entire application. The rest goes into lower layers. When requirements change, you only need to change this 3-10%.

The requirements code is expressed in terms of _domain abstractions_. Each domain abstraction provides one generic piece of implementation. Each is a building block useful for expressing requirements, without knowing about the requirements.  


The executable description of requirements in the top layer is also the architecture or the design. (I do not make a distinction between architecture and design.) There is no separate artefact or documentation of the 'architecture', no model, no other "high level" design. The same artefact that describes the requirements and is executable is also the application's architecture. So one source of truth for everything.



=== Polyglot programming paradigms

Many programming systems use one programming paradigm. The paradigm solves some problems really well so the programming system is kept pure and simple. An example ladder logic. The problem is that some problems are hard to solve, and require many programming elements making the solutions themselves complex. So ALA takes the opposite approach. We want all requirements to be easily expressible. Therefore we will need multiple programming paradigms. 

Some examples of programming paradigms are UI layouts, data flows, navigation flows, schema relationships, state transitions. ALA makes it easy to add new programming paradigms by adding new types of ports, in other words adding new gneric interfaces.

There are other types of programming paradigms that don't need to use ports as well. For example, say you want a programming paradigm for style. You would create a Style concept abstraction in the programming paradigms folder. Then every UI domain abstraction would get aspects of its style from this abstraction. Then the application layer configures the style abstraction for a specific application, and all UI instances would take on that style. You use this method rather than ports if all the ports would otherwise be connected to a single instance of something. If things are connected to one instance, that indicates that the instance itself can be an abstraction, and simply be put down a layer for every one to access. 

ALA is said to be a polyglot programming paradigm architecture.





=== Diagrams vs text


Generally in ALA, compositions of instances of domain abstraction form a graph or network. This is because a  requirement often contains a network of relationships. A graph is most easily represented as a diagram. In the trivial examples of composition that we already used we used text because they were mostly linear or tree structured. These structures can naturally be represented in text, although trees represented in text form become hard to read if too deep (too much indenting). For graphs, using text requires 'symbolic connections' or labels to connect the points. This method becomes hard to read beyond a few connections. Conventional code using modules can end up with thousands of method names that are little more than labels. All files searches are needed to find them. ALA therefore uses diagrams for non-trivial applications.

ALA therefore works best with an IDE that supports diagrams. 

Sometimes programming with diagrams is called model driven software development. I prefer to not put the empahisis on model driven. ALA does not necessarily require diagrams. I also prefer not to use the word model. In the real world, models can leave out details arbitrarily. Often high level software designs leave out details too. In ALA we don't leave out details, we abstract out implementation. All the details from the requirements need to be there in the diagram for it to be executable. That's why I use the word diagram rather than model. 

If a diagram is used for an ALA requirement or user story, it is the source code. A code form of the diagram is generated from it for execution, but that code does not need to be readable except to the extent of finding where it doesn't accurately reflect the diagram. It can be as simple as a list of instances, and a list of connections. 



=== Layers replace hierarchical decomposition

In the next chapter we will discuss why ALA uses a 'create and then compose' approach rather than a 'hierarchical decomposition' or 'divide and conquer' approach.

Here we describe the two different structures that result from these two different approaches.


==== The hierarchical decomposition approach


image::Slide8.jpg[Slide8.jpg, title="Decomposition into elements and their relations", align="center"]

The figure shows five modules (or components) and their relations (as interactions). Study almost any piece of software, and this is what you will find (even if it supposedly adheres to the so-called layering pattern).

The structure generally can be viewed as 'clumping'. Like galaxies, certain areas have higher cohesion, and so go inside boxes. Other areas are more loosely coupled, and so are represented by lines between the boxes. The difference between high cohesion and loose coupling is only quantitative.

Software health in this type of architecture is effectively management of the resulting coupling between the cohesive clumps. Allocate code to boxes in such a way as to minimize coupling. This coupling management has two conflicting forces. One is the need to have interactions to make the modules work as a system. The other is to minimize the interactions to keep the modules as loosely coupled as possible. As maintenance proceeds, the number of interactions inevitably increases, and the interfaces get wider. Encapsulations can become more or less transparent over time.

Various architectural styles are aimed at managing this conflict. Most notably:

* layering pattern
* MVC pattern
* Avoid circular dependencies
* Avoid high fan-in and high fan-out on a single module
* Avoid dependencies on unstable interfaces

Note that none of this 'dependency management' actually avoids circular coupling. To some extent there will always be 'implicit coupling' in both directions between modules of a decomposed system. This is because the modules are the opposite of abstractions - specific parts designed to interact or collaborate to make a system. For example, a function of a decomposed system will tend to be written to do what its caller requires even if there is no explicit compile-time dependency on its caller. So circular coupling may be avoided at compile-time, but will still be present at design-time. That is why in the diagram above, couplings are drawn from the insides of each of the modules in both directions. This indicates that the code inside has some inherent design-time collaborative coupling. To the compiler or a dependency graphing tool, the lines may appear to be non circular, and even layered, but this is not telling you the whole story of the coupling.

In the hierarchical decomposition appoach, wheever any of the inner modules becomes too large, your would decompose it into still smaller evern more specialized modules. This creates a hierarchical structure. Some make the analogy with zooming in on a map. The structure works looks like a fractal.


==== The create abstractions and compose approach

When you use abstractions instead of modules, there is qualitative difference in how the structure is built. There is no need for interactions, collaboration, or coupling between your abstractions at all. 

image::Slide9.jpg[Slide9.jpg, title="Abstraction do not interact", align="center"]

The word 'modules' has been changed to the word 'abstractions'. All the dependencies are gone. And with them all their problems. You no longer have to worry about dependencies and all their management. The implicit coupling that we talked about earlier is also gone. The 'clumping' structure has become isolated boxes. Loose coupling is replaced with zero coupling.

The obvious question now is how can the system work? Where do all the  interactions between elements that we had before go? The answer is they become normal code, completely contained inside one additional abstraction. This code composes instances of the abstractions to make a system:

image::Slide10.jpg[Slide10.jpg, title="Abstractions and composition of their instances", align="center"]

The code inside the new system abstraction is normal code. It's like code that composes if statements and assignment statements, except you are composing domain level abstractions instead.

Furthermore, this composition code is cohesive. It is all the code to do with the specific system itself. None of the code inside the abstractions knows about the specific system, only this new code does.

Now we put the abstraction, A, B, C, D and E into a layer. The system abstraction goes in the layer above that. The reason that the abstractions: A,B,C, D, and E don't go inside the system is that they are not specific to it. They are less specific. Therefore we actually want them to be public so that they can be used by other systems.

And so we see that in ALA, layers replace hierarchical decomposition.


[TIP]
====
Software engineering should [red]#*not*# be about [red]#*managing coupling*#.

It should be about [green]#*inventing abstractions*#. 
====







=== Real world metaphors

==== Atoms and molecules

Here are two atom abstractions:

image:oxygen.png[Oxygen atom, 200, title="Oxygen atom"]
image:hydrogen.png[Hydrogen atom, 200, title="Hydrogen atom"]

Instances can be composed to make a molecule:

image:water_molecule.jpg[Water molecule, 300, title="Water molecule"]


If water was implemented in the same way we typically write software, there would be no water molecule per se; the oxygen atom would be modified to instantiate hydrogen atoms and interact with them. Even if dependency injection is used to avoid the instantiating, it is still unlikely that a water abstraction would be invented to do that, and there would still be the problem of the oxygen atom interacting with hydrogen's specific interface. Either way, the oxygen module ends up with some implicit knowledge of hydrogen. And hydrogen probably ends up with some implicit knowledge of oxygen in providing what it needs. 

This implicit knowledge is represented by the following diagram. The relationship is shown coming from the inner parts of the modules to represent implicit knowledge of each other.

[plantuml,file="diagram-o-h.png"]
----
@startdot
digraph foo {
graph [rankdir=LR]
subgraph cluster_o { 
style="rounded"
margin="16"
Oxygen [style="setlinewidth(0)"]
}
subgraph cluster_h { 
style="rounded"
margin="16"
Hydrogen [style="setlinewidth(0)"]
}
edge [color=red]
Oxygen -> Hydrogen [dir="both", arrowhead="dot", arrowtail="dot"]
}
@enddot
----



While oxygen and hydrogen are modules, they are not abstractions because oxygen is implicitly tied to hydrogen and vice-versa. They can't be used as building blocks for any other molecules.

To keep oxygen as abstract as it is in the real world, an interface must be conceived that is even more abstract than oxygen or hydrogen. In the molecule world this is called a polar bond.

The corresponding software would look like this:


image::Slide15.jpg[Slide15.jpg, title="", align="center"]

The water molecule has a "uses instances of" relationship with the two atoms, and the atoms have a "uses instance of" relationship with the even more abstract polar bond. Polar bond is an example of what we call an 'abstract interaction'.

==== Lego

The second real world metaphor is Lego. Shown in the image below is the same three layers we had above for molecules, atoms and bonds.

image::Slide16.jpg[Slide16.jpg, title="", align="center"]

The domain abstractions are the various lego pieces, instances of which can be assembled together to make specific things. Lego pieces themselves have instances of an abstract interface, which is the stud and tube. There is a second abstract interface, the axle and hole. We also call the abstract interface the 'execution model' and here with the lego metaphor we start to see why it can be thought of in this way - when the model runs, stud and tube interface executes the holding of the model together and the axle and hole interface executes rotation.

==== Electronic schematic

The third real world metaphor comes from electronics. The abstractions are electronic parts, instances of which can be composed as a schematic diagram:  

image::Slide17.jpg[Slide17.jpg, title="", align="center"]

In this domain, we have two abstract interfaces (execution models), one for digital logic signals and one for analog signals.


==== A clock

The forth and final real world metaphor is a clock. In this diagram, we show the process of composition of abstractions to make a new abstraction. The process is a circle because instances of the new abstraction can themselves be used to make still more specific abstractions. Each time around the circle adds one layer to the abstraction layering.

image::Slide18.jpg[Slide18.jpg, title="", align="center"]

Let's go round the circle once. We start with abstract parts such as cog wheels and hands. Instances of these have abstract interfaces that allow them to interact at run-time, such as spinning on axles and meshing teeth. The next step is to instantiate some of these abstractions and configure them. For example, configure the size and number of teeth of the cog wheels. Next comes the composition step, where they are assembled. Finally we have a new abstraction, the clock. Instances of them can be used to compose other things such as a scheduling things during your day. Because you have now created the abstraction _clock_ you don't have to think about cog wheels when thinking about how to meet someone at a certain time.

There are many other instances of this pattern in the real world, and in nature. In fact everything appears to be actually composed in this way. The way we understand the world is in terms of abstractions, which are in composition layers.




=== Example project - Calculator



This project was originally done in a hurry for an ALA workshop. Apart from being a cool example of the use of ALA, the calculator itself is cool. This calculator is in Github, as a work in progress here: https://github.com/johnspray74/ReactiveCalculator[https://github.com/johnspray74/ReactiveCalculator]

The original development for the workshop was done in about a day, so here we tell the story of that development. 

When I was first asked to do the workshop, I needed to think of a suitable pedagogical sized project. It was suggested to do a calculator. Ok, I thought, if we have the domain abstractions already in place before the workshop, we should be able to write a calculator application (top layer) during the workshop. 

When we think of a calculator application, we usually imagine a user interface that mimics a handheld calculator. It has a one line display and a keypad. We certainly could have built that calculator (primarily using a state machine programming paradigm). But that problem has already been solved by Miro Samek. Besides, I hate those kinds of simulated handheld calculators. I think they a stupid way to do calculations on a computer. Such a calculator would be boring and redundant.

As an aside, I once loved my HP calculators. The first programmable anything I ever owned was an HP65 calculator. I have owned many top end models at one time or another. But as their displays got larger, I became more and more disappointed with how they used that display real-estate. They just used it as a stack. The calculator I wanted would show the expression you had entered so you can check what you did entered. It could show it in algebraic or even textbook form, even though you had entered it as RPN. You could edit the expression. You could label your expression result and then you could use the result in another expression. When you changed something, all results would be updated like Excel. This is what the HP prime should have been.

So I drew a sketch of what I wanted for the workshop. Here is the actual sketch: 

image::CalculatorRequirements.png[Calculator3.png, 900, title="Calculator requirements"]


Here is a screenshot of the working calculator as it was two half-days later:

image::CalculatorScreenshot.png[CalculatorScreenshot.png, 900, title="Calculator screenshot"]


The first step in the design of the calculator was to express the requirements (UI plus behaviours), inventing any needed abstractions to do so. Here is the actual first sketch: 

image::Calculator2Rows-HandDrawing.png[Calculator2Rows-HandDrawing.png, 900, title="Calculator (2 Rows only shown)"]

As we shall see, this diagram is practically executable code. The calculator is practically done. We don't know if the invented domain abstractions will work yet, but let's go through how this calculator works anyway. 

First notice how the entire calculator is here. Every detail about this particular calculator cohesively works together. This is an important aspect of ALA designs. All the UI and all the data flows to make a working calculator are in this one diagram. What is not here is the details we left to the domain abstractions. None of these abstractions is specific to a calculator. They can be used for all sorts of things. Even the Formula abstraction would be useful in any application where a calculation needs to be changed at run-time. For example an insurance application may need configurable calculations.

The left side shows two instances of the abstraction, Horizontal. These arrange their children horizontally in the UI. To the left of those (not shown) is an instance of Vertical, which arranges the two Horizontals vertically. And to the left of that, also not shown, is an instance of MainWindow.   

Each Horizontal has 3 instances of TextBox and one Text. The TextBoxs allow you to enter a string. The abstraction, Text, can only display a string. I see at this point, I hadn't put in the TextBox for the description. 


==== How the calculator works

We can ignore the use of labels for a moment and just enter a formula containing constants into the first row TextBox. Let's say we type in "2+1". The string "2+1" goes along the data flow wire to the StringFormat instance on its port 0. The StringFormat is configured with the format string "({1}=>{0})". StringFormat uses this format string in the same way as an interpolated string in C#. The {0} is substituted with the string coming in on port 0. The {1} is substituted with the string coming in on port 1. Since we have no string on port 1, the output from the StringFormat will be "()=>2+1". This is simply a lambda expression with no parameters. This string is fed into the instance of Formula. Formula is an abstraction that knows how to evaluate a lambda expression. Actually it will accept just a formula string (such as "2+1") as well. We can ignore the other input of Formula for the moment. Formula will evaluate "()=>2+1" and produce the number 3 on its output. This output is a data-flow of type double. This number is fed to an instance of NumberToString, and from there it goes to the instance of Text that knows how to display a string.

Now let's follow the use of labels in the calculator. Let's put the labels "a" and "b" into the TextBoxs for labels on the two rows. "a" and "b" are fed to the Concat instance. Concat's input port can have any number of string data-flows wired into it. In this diagram it has only two. What Concat does is concatenate all its inputs adding a separator. In this case the separator is configured to be a comma. The output of the Concat is "a,b". The concatenated list of labels is fed into port 1 of both StringFormat instances. 

Now let's put the formula "a*3" into the 2nd row of the calculator. The output of the StringFormat for that row will be "(a,b)=>a*3". That lambda expression will be fed to the Formula instance, which will evaluate it, using the value on its first input port for the value of 'a'. The output will appear on the corresponding Text in the 2nd row.

So that's all there is to understanding how the calculator works. At this point it takes a leap of faith that the abstractions can all be made to work, and that the two programming paradigms used, the UI layout and the data-flow, can be made to work. Not withstanding that, all the information required in the design of the calculator is captured.

At this point I drew little drawings of all the invented abstractions. Actually I reused TextBox, Text, Vertical, Horizontal and FormatString from a previous project. And I had already made the UI and data-flow programming paradigm interfaces in previous projects, so I reused them as well.




image::CalculatorDomainAbstractionsHandDrawings.png[CalculatorDomainAbstractionsHandDrawings.png, 300, title="Calculator Domain Abstractions"]

I see I forgot to draw Concat. I had to write that one. Here is its template as it was in my Xmind templates diagram.

image::CalculatorStringConcatTemplate.png[CalculatorStringConcatTemplate.png, 400, title="StringConcat template"]

The two ports are both drawn on the right hand side unfortunately - a limitation of using Xmind as the drawing tool. Drawing the templates makes the abstractions clearer for their implementation.  

==== Implementing the domain abstractions


Abstractions are gnerally trivial to implement because they are zero coupled with anything. They are like tiny stand-alone programs. Here is the full code for StringConcat.

.SringConcat.cs
[source,C#]
....
using ProgrammingParadigms;
using System;
using System.Collections.Generic;
using System.Linq;

namespace DomainAbstractions
{
    /// <summary>
    /// Outputs the input strings concatenated together
    /// Whenever an input strings changes, a new output is pushed.
    /// ---------------------------------------------------------------------------------------------------------
    /// Ports:
    /// 1. List<IDataFlowB<string>> inputs: inputs (indefinite number of string inputs)
    /// 2. IDataFlow<string> output: output
    /// </summary>



    public class StringConcat
    {
        // Properties ---------------------------------------------------------------
        public string InstanceName { get; set; } = "Default";
        public string Separator { private get; set; } = "";

        // Ports ---------------------------------------------------------------
        private List<IDataFlowB<string>> inputs;
        private IDataFlow<string> output;


        /// <summary>
        /// Outputs a boolean value of true when all of its inputs are true. Null inputs are treated as false.
        /// </summary>
        public StringConcat() { }

        // This function is called immediately after each time the inputs port is wired to something
        private void inputsPostWiringInitialize()
        { 
            inputs.Last().DataChanged += () =>
            {
                var result = "";
                bool first = true;
                foreach (IDataFlowB<string> input in inputs)
                {
                    if (!first) result += Separator;
                    first = false;
                    result += input.Data;
                }
                output.Data = result;
            };
        }

    }
}
....


The code in Concat is straightforward if you know C#, except for a few conventions which are to do with the use of ALA (which I was already proficient with):

. We put a property "InstanceName" in every domain abstraction. It's not required, but the reason is because abstractions get reused. So you are likely to end up with multiple instances of an abstraction all over your application. If you name the instances, it makes debugging a lot easier because you can see it in the debugger and know which instance you are in.

. All the IO for the abstraction is in a section called "Ports". Usually an abstraction would have some ports that are private fields of the type of an interface, and some that are an implemented interface. It just so happens that StringConcat has no implemented interface ports.

. The two ports are private, and yet they get wired by the application code to other objects. This may seem a little bit magic. The reason they are private is to indicate they are not for use by anything else. The application will use a method called WireTo() to achieve the wiring. WireTo is an extension method on all objects. It uses reflection to find and assign to these "port" fields.

. Notice that the "inputs" port uses IDataFlowB (not IDataflow). The B on IDataflowB indicates a tricky workaround for a limitation in the C# language. What we would have liked to do is implement IDatFlow. But we would have needed to implement IDataFlow multiple times. You can't do that in C# (although there is no reason why not in theory, and hopefully all languages will have this feature to support the concept of ports one day).

. Notice that the method, inputsPostWiringInitialize, is private and apparently unused. When the WireTo operation wires a port "xyz" it looks for a private method called xyzPostWiringInitialze and invokes it immediately. This gives us the opportunity to set up handlers on any events that may be in the interface. In this case, the IDataFlowB interface has a DataChanged event (that tells us when there is new data on the inputs).    

. It doesn't make sense to use a StringConcat without wiring its output to something. So the line "output.Data = result" will throw an exception if the application has not wired it. Often times, abstractions have ports that are optional to wire, in which case we would use "outputs?.Data = result"


For reference, here is the IDataFlow interface, which lives in the ProgrammingParadigms folder, and is used by most of the domain abstractions including the StringConcat abstraction:


.IDataFlow.cs
[source,C#]
....
namespace ProgrammingParadigms
{
    public interface IDataFlow<T>
    {
        T Data { get; set; }
    }
}
....

As you can see, this interface is simple, but its importance in giving us a data-flow programming paradigm is huge. It allows objects to be wired together so that data can flow from object to object without the abstractions knowing anything about each other. Note that IDataflow uses a 'push' execution model. This means that the source always initiates the transfer of data on its output (by using 'set'). The IDataFlowB interface is a little more complicated, so we wont go into how it works just now. But it achieves exactly the same purpose of the data-flow programming paradigm, just in a different way that allows more than one input port of the same type. .


The other domain abstraction I needed to write for the first time was Formula. Here is the template as used in Xmind: 


image::CalculatorFormulaTemplate.png[CalculatorFormulaTemplate.png, 500, title="Formula template"]


Once again, one of the input ports is shown on the right when we would prefer it to be on left.

Formula can be configured with an optional C# lambda expression when it is instantiated by the application, for example:

.Application.cs
[source,C#]
....
new Formula() {Lambda = (x,y) => x+y; }
....

If used in this way, the formula is fixed at design-time. But its real power comes from the fact that it can take a formula as a string at run-time. Formula has an input data-flow port called "formula". 

The Formula abstraction has to parse the formula string and then evaluate it. I used Roslyn to do this in a few lines of code. These lines of code took me a few hours to figure out however: 

.Formula.cs
[source,C#]
....

using Microsoft.CodeAnalysis.CSharp.Scripting;
using Microsoft.CodeAnalysis.Scripting;
using static System.Math;

namespace DomainAbstractions
{
    using LambdaType = Func<double, double, double, double, double, double, double>;

    public class Formula
    {
        public LambdaType Lambda { private get; set; }


        // Other code omitted from here


        private async void Compile(string formula)
        {
            var options = ScriptOptions.Default;
            options = options.AddImports("System.Math");
            try
            {
                Lambda = await CSharpScript.EvaluateAsync<LambdaType>(formula, options);
            }
            catch (CompilationErrorException e)
            {
                Lambda = null;
            }
        }
    }
}
....

As you can see, currently the Formula abstraction can only handle formulas that use a maximum of six parameters. The calculator application can use any number - it's just that any one formula is limited to using only six.

The rest of the code in the Formula abstraction is mostly dealing with this requirement of exactly six parameters used by LambdaType. But that's all internal to the abstraction. An instance of the Formula abstraction can handle any number of operands from zero to many. The Formula abstraction is also tolerant of the string on the formula input port being either just a formula such as "2*(3+1)" (implying it's not using any operand inputs), or a proper lambda expression such as "(x,y,z)=>x*(y+z).

Now that we have our needed domain abstractions, let's return to the application layer, and see if we can get this calculator running.


==== Hand wiring the appication code from the diagram

First here is the startup code for a wired ALA application. It is very simple:



.Application.cs
[source,C#]
....
namespace Application
{
    public class Application
    {
        private MainWindow mainWindow;

        [STAThread]
        public static void Main()
        {
            Application app = new Application();
            app.mainWindow.Run();
        }

        private Application()
        {
            // mainWindow = WireHelloWorld();
            mainWindow = Calculator2RowHandWired();
        }
    }
}
....



Here is an ALA Hello World application


.Application.cs
[source,C#]
....
private MainWindow WireHelloWorld()
{
    return new MainWindow().WireTo(new Text("Hello World"));
}
....

Ok, now we are ready to hand wire the hand drawn calculator diagram shown above:


.Application.cs
[source,C#]
....
private MainWindow Calculator2RowHandWired()
{
    // To understand this code, you need the wiring diagram of the two row calculator

    // First instantiate instances of abstractions we need to give names to. The rest can be anonymous.
    StringConcat stringConcat = new StringConcat() { Separator = "," };
    DataFlowConnector<string> stringConcatConnector = new DataFlowConnector<string>(); // Connectors are needed when there is fan-out or fan-in in the diagram
    stringConcat.WireTo(stringConcatConnector, "output");
    Formula[] formulas = { new Formula(), new Formula() }; // instantiate both the formulas up-front because we need to cross wire them


    MainWindow mainWindow = new MainWindow("Calculator")
        .WireTo(new Vertical()
            .WireTo(WireRow(stringConcat, stringConcatConnector, formulas[0], formulas))
            .WireTo(WireRow(stringConcat, stringConcatConnector, formulas[1], formulas))
            );
    return mainWindow;
}


private Horizontal WireRow(StringConcat stringConcat, DataFlowConnector<string> stringConcatConnector, Formula formula, Formula[] formulas)
{
    // To understand this code, you need the wiring diagram of the two row calculator

    // first instantiate objects we need to give names to.  The rest can be anonymous.
    Text result = new Text(); 

    // Wire up a calculator row
    Horizontal row = new Horizontal()
        .WireTo(new TextBox()
            .WireTo(new DataFlowConnector<string>()
                .WireFrom(stringConcat, "inputs")
            )
        )
        .WireTo(new TextBox()
            .WireTo(new StringFormat<string>("({1})=>{0}")
                .WireTo(stringConcatConnector, "inputs")
                .WireTo(formula
                    .WireTo(new DataFlowConnector<double>()
                        .WireFrom(formulas[0], "operands")
                        .WireFrom(formulas[1], "operands")
                        .WireTo(new NumberToString()
                            .WireTo(result)
                        )
                    )
                )
            )
        )
        .WireTo(result)
        .WireTo(new TextBox());
    return row;
}
....


Commentary on this wiring code

* The code is written in "fluent style". This is possible because the WireTo extension method returns its 'this' parameter, allowing you to use .WireTo() multiple times on an instance.

* The parts of the diagram that have a tree structure can be wired by using more .WireTos immediately inside the brackets of another WireTo. This is what causes the indented code.

* The previous two points allow much of the wiring to be done without having to think up names for the instances. The instances are anonymous just as they were on the diagram.

* Where the diagram has cross wires that formed a cycle, we need to give instances names so that we can complete all the wiring to them.

* Sometimes the WireTo method is given the port name of the first object. These are used when WireTo may get the wrong port if it were left to use the port types alone. (If an abstraction has multiple ports of the same type, WireTo doesn't know which port to use.)

* Most abstractions have ports that can only be wired to one place, and ports that can only be wired from one place. (The UI abstractions are exceptions, for example, Horizontal can be wired to multiple children.) The hand drawn wiring diagram has several places where the wiring either 'fans out' from a port or 'fans in' to a port. Unfortunately C# does not support the concept of ports, so we improvise to make them work in normal C# code. The way this improvisation works for fan-in and fan-out is to use a connector.

** For fan-out you wire the output port to a new Connector. Then you can wire the connector to multiple places.

** For fan-in, the abstraction, instead of implementing the port, uses a list field of a type like IDataFlowB. The 'B" on the end means the flow of data is reversed from IDataFlow. Now to wire such an inputs port to an output port also requires a connector (a second use for connectors). When wiring an IDataFlowB, you wire from the input to the connector (the opposite way to the direction of data flow unfortunately). 

* As a convenience, you can use WireFrom. It reverses the two operands being wired compared to WireTo.


Handwritten wiring code like the above can be managed for small applications. It is easy to get it wrong though. The code is not readable from the point of view of understanding the application. That's what the diagram is for. So every time you make a change to the requirements, you need to do it on the diagram first, then update the hand-generated code. You are still better off doing this than not using ALA. If not using ALA, the relationships of the cohesive, explicit ALA diagram still exist, but they become obscurred and distributed inside your modules.

But we don't have to hand generate code. At the time of writing a hand written graphical IDE is under development. 

Here is the calculator row part of the diagram, which was successfully used to auto-generate code:


image::CalculatorRow-GALADE.png[CalculatorRow-GALADE.png, 800, title="CalculatorRow abstraction internal wiring"]

Before we had that tool, we used Xmind to do diagrams from which we could generated code. This is the approach described in the next section. 



==== Automatic code generation from the diagram

Here is the diagram of the 2-row calculator as it was originally entered into Xmind. You can click on the image to get a bigger version.

image::Calculator2Rows.png[Calculator2Rows.png, 1000, title="Calculator drawn in Xmind (two rows version)", link=images/Calculator2Rows.png]


Xmind is not the perfect tool to do this, but it has one huge advantage - it lays itself out. This is so important that it's why we use it (until our new tool is ready). We will put up with the disadvantages, and the necessary conventions until then. Those conventions are documented in the wiki section of the project in Github here: https://github.com/johnspray74/ReactiveCalculator/wiki[https://github.com/johnspray74/ReactiveCalculator/wiki]

Entering the hand-drawn version of the diagram is a simple matter of copying and pasting the Xmind templates for the abstractions to the right place in the diagram. This connects most of the needed wiring from port to port. Xmind supports tree structured diagrams, so any cross tree wiring was done by using the red lines, which are quick to put in with a shortcut key.

The Xmind version of the diagram is pretty much identical to the hand drawn version. The colored boxes are instances of abstractions. All the other nodes attached around those colored boxes are the ports. The < and > signs in the ports are significant, and tell the automatic code generator which way to wire the instances. The asterisks are also significant, and tell the code generator that many wires can be wired to the one port.

The diagram done, it's time to generate the code. A tool called XmindParser does this. It can be downloaded from the Github project main page. Here is the tool in use to generate a calculator from the diagram.

image::CalculatorXmindParserTool.png[CalculatorXmindParserTool.png, 800, title="XmindParser tool in use"]

The tool can put the generated code into your Application.cs file if you give it special markers like the one below.



.Application.cs
[source,C#]
....
private void Calculator2Rows()
{
    // BEGIN AUTO-GENERATED INSTANTIATIONS FOR Calculator2Rows.xmind
    // END AUTO-GENERATED INSTANTIATIONS FOR Calculator2Rows.xmind

    // BEGIN AUTO-GENERATED WIRING FOR Calculator2Rows.xmind
    // END AUTO-GENERATED WIRING FOR Calculator2Rows.xmind
}
....

The markers contain the name of the Xmind diagram they get code from. This allows several diagrams to be used for one application.

I usually put the markers inside a function so that all the instantiated objects are private to the function.

Here is the code again with three lines of generated code shown in each section.


.Application.cs
[source,C#]
....
private void Calculator2Rows()
{
    // BEGIN AUTO-GENERATED INSTANTIATIONS FOR Calculator2Rows.xmind
    Formula Formula1 = new Formula() { InstanceName = "Formula1" };
    Formula Formula2 = new Formula() { InstanceName = "Formula2" };
    Horizontal id_24914ab245484fe1b70af8020ca2e831 = new Horizontal() { InstanceName = "Default" };
    // END AUTO-GENERATED INSTANTIATIONS FOR Calculator2Rows.xmind

    // BEGIN AUTO-GENERATED WIRING FOR Calculator2Rows.xmind
    mainWindow.WireTo(id_b02d2caea938499b997b9bfcb80fb0e9, "iuiStructure");
    id_b02d2caea938499b997b9bfcb80fb0e9.WireTo(id_24914ab245484fe1b70af8020ca2e831, "children"); 
    Formula1.WireTo(dfc1, "result");
    // END AUTO-GENERATED WIRING FOR Calculator2Rows.xmind

}
....


Completing the diagram had taken another morning of work. But the calculator was now working and I was ready for the workshop.

I made a diagram with six rows, but it was getting pretty large, and the duplication was pretty clumsy.


==== Calculator with 10 rows

The 6-row calculator is powerful compared to any normal calculator, but still wouldn't do jobs like the one shown here which has 11 rows:

image::CalculatorNRowsScreenshot.png[CalculatorNRowsScreenshot.png, 800, title="Later version of the calculator to support an unlimited number of rows"]

So it was time to do some maintenance, and solve that problem of the repetition in the diagram at the same time. During this maintenance, none of the existing abstractions changed. Their ports stayed the same. Their internals were improved a little in some cases but nothing significant. Formula was modified internally so that it could handle more than six operand inputs, although any one formula can still only use six of them.

There were two major changes though. One was to put the repeated wiring for a calculator row inside its own abstraction. This abstraction is called "CalculatorRow". This abstraction is less abstract than the Domain abstractions it uses, but more abstract than the application, which will use it multiple times. Other version of the calculator alos reused it. So it goes into its own layer between the two. This new layer is called "Requirements Abstractions". We don't make new layers lightly, but we had had the experience in a larger project that the diagram got too large. We needed to factor out some of it as 'Feature level abstractions'. These abstractions needed a new layer between the Application layer and the Domain abstractions layer. So I was reasonably happy to make use of this new layer in the calculator to reduce a now quite large diagram.

Here is the Xmind template for the CalculatorRow abstraction showing its ports:

image::CalculatorRowTemplate.png[CalculatorRowTemplate.png, 800, title="CalculatorRow abstraction"]


The implementation of CalculatorRow was done with a diagram using the new Graphical ALA tool which was shown earlier.


When you implement an abstraction by an internal diagram, there needs to be some extra code to wire from the ports (shown in the template above) to the internal wiring. I found this code quite tricky the first time and it took me a while. But there is a pattern to it. The new tool will be able to automatically generate this code as well, but for now I did it by hand.

I tested the completed CalculatorRow abstraction by making an application that uses it twice:


image::Calculator2ARows.png[Calculator2ARows.png, 1000, title="Calculator drawn in Xmind using the new CalculatorRow requirements abstraction", link=images/Calculator2ARows.png]

Because this test calculator has only two rows we can directly compare it with the 2-row calculator above and see how the two rows are now represented by two instances of this new CalculatorRow abstraction. However we are still not there to building a calculator with 10 rows. If we were to instantiate CalculatorRow 10 times, it would need 100 wirings in Xmind to connect all ten results to every CalculatorRow's operands input. Having thought the 36 wirings of the 6 row calculator was nuts, there was no way I was going to do 100 of them by hand.

So the next step was to invent a domain abstraction called 'Multiple'.

What 'Multiple' does is you instantiate it in your application and configure it with the number you want. In this case N:10. Multiple has a port called factory which uses a new interface called IFactory. Then what you do is add a small Factory class inside any abstraction that you want multiple instances of. In this case we want multiple instances of CalculatorRow, so I added a small class to that abstraction called CalculatorRowFactory. CalculatorRowFactory implements IFactory (which resides in the Programming Paradigms layer). Multiple can now create many instances of the abstraction that is wired to it. But these instances now have to be wired into the rest of the wiring in the application diagram as needed. To accomplish that, multiple is configured with two methods. These methods, which are part of the application, know how to wire the new instances into the rest of the wiring.

Here is the Xmind template for Multiple:

image::CalculatorMultipleTemplate.png[CalculatorMultipleTemplate.png, 500, title="CalculatorRow requirements abstraction"]

Using the new Multiple abstraction, we can now build a 10-row calculator. Here is the new diagram: 

image::Calculator10Rows.png[Calculator10Rows.png, 1000, title="Calculator drawn in Xmind using the new Multiple domain abstraction to create as many rows as we like", link=images/Calculator10Rows.png]

You can see inside the instance of Multiple that it is configured to make 10 of whatever is attached to its factory port. The CalculatorRow abstraction is shown next to the CalculatorRowFactory so you can see what it makes. You can see inside Multiple the two methods that Multiple calls when it makes a new instance. These methods are used to wire the CalculatorRow into the rest of the application wiring.

Getting to this point had taken another two Saturday mornings of work. It was mainly spent on thinking out the patterns for how the internal wiring inside CalculatorRow should get wired to CalculatorRows own border ports. Also in the initial attempt I had allowed temporal coupling to creep in between abstractions. It mattered whether the application wiring was done first. And if you let coupling creep in bugs will happen. The temporal coupling was resolved by making CalculatorRow not care whether or not the external wiring is done when it is instantiated.    

==== Calculator with N rows

Wouldn't it be cool if the calculator started with say 4 rows, and had a button for adding additional rows? You will notice that the Multiple abstraction template above has a port called addRow. It takes an IEvent. If it receives an event on that port at run-time, it will create another row and call the lambda wiring functions to get that row wired in.

Here is the calculator with the button added to the UI. This is the calculator from which the screen shot shown above was taken.

image::CalculatorNRows.png[CalculatorNRows.png, 800, title="Later version of the calculator to support an unlimited number of rows"]

I wanted the Button to be at the bottom, so I added another instance of Vertical to act as the wiring point for new row to be attached to the UI. The output of the Button is another programming paradigm interface called an IEvent. 

Here is the source code of IEvent:

.IEvent.cs
[source,C#]
....
namespace ProgrammingParadigms
{
    public interface IEvent
    {
        void Execute();
    }
}
....

Again, considering that this interface enables a whole programming paradigm, it is extremely simple and abstract, consisting of only a synchronous function call. It allows any objects that can produce events to be wired to any object that can receive an event. In the CalculatorNRows example, it allows a Button to be Wired to a Multiple. When the Button is pressed, Multiple creates a new row.  

There is one major Programming Paradigm that we have not explained yet. It is the one that allows UI instances to be wired together. The meaning of wiring two UI objects together is that one contains the other. Here is the IUI interface that implements this programming paradigm.

.IUI.cs
[source,C#]
....
using System.Windows;

namespace ProgrammingParadigms
{
    public interface IUI
    {
        UIElement GetWPFElement();
    }
}
....

The interface simply allows a containing UI instance to get the WPF (Windows Presentation Foundation) element from the contained UI instance it is wired to.

Making Multiple able to add rows to the calculator at runtime took yet another Saturday morning. But it was worth it to solve the challenge of learning how to change the wiring at run-time. The wiring diagram now statically describes how it dynamically changes itself.

That concludes the story of the development of the calculator using ALA. The full source code, and all the diagrams for every version along the way are in the Github project at
https://github.com/johnspray74/ReactiveCalculator[https://github.com/johnspray74/ReactiveCalculator]


// TBD why not use #defines?
