<!DOCTYPE html>
<html lang="en">
<head>
<!-- Google Tag Manager -->
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-NDHLGMM');</script>
<!-- End Google Tag Manager -->
<link rel="icon" type="image/png" href="favicon-32x32.png" sizes="32x32" />
<link rel="icon" type="image/png" href="favicon-16x16.png" sizes="16x16" />
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.8.dev">
<title>Abstraction Layered Architecture</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment @import statement to use as custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*::before,*::after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:600;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#914f0f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite::before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed;word-wrap:break-word}
:not(pre)>code.nobreak{word-wrap:normal}
:not(pre)>code.nowrap{white-space:nowrap}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details>summary:first-of-type{cursor:pointer;display:list-item;outline:none;margin-bottom:.75em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class~="highlight"]{background:#fefced}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos{border-right:1px solid currentColor;opacity:.35;padding-right:.5em}
pre.pygments .lineno{border-right:1px solid currentColor;opacity:.35;display:inline-block;margin-right:.75em}
pre.pygments .lineno::before{content:"";margin-right:-.125em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt,.quoteblock .quoteblock{margin:0 0 1.25em;padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;text-align:left;margin-right:0}
table.tableblock{max-width:100%;border-collapse:separate}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
td.tableblock>.content>:last-child.sidebarblock{margin-bottom:0}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>thead>tr>.tableblock,table.grid-all>tbody>tr>.tableblock{border-width:0 1px 1px 0}
table.grid-all>tfoot>tr>.tableblock{border-width:1px 1px 0 0}
table.grid-cols>*>tr>.tableblock{border-width:0 1px 0 0}
table.grid-rows>thead>tr>.tableblock,table.grid-rows>tbody>tr>.tableblock{border-width:0 0 1px}
table.grid-rows>tfoot>tr>.tableblock{border-width:1px 0 0}
table.grid-all>*>tr>.tableblock:last-child,table.grid-cols>*>tr>.tableblock:last-child{border-right-width:0}
table.grid-all>tbody>tr:last-child>.tableblock,table.grid-all>thead:last-child>tr>.tableblock,table.grid-rows>tbody>tr:last-child>.tableblock,table.grid-rows>thead:last-child>tr>.tableblock{border-bottom-width:0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot,table.frame-ends{border-width:1px 0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd),table.stripes-even tr:nth-of-type(even),table.stripes-hover tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{display:-ms-flexbox;display:-webkit-box;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media print,amzn-kf8{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
</head>
<body class="article toc2 toc-left">
<!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-NDHLGMM"
height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<!-- End Google Tag Manager (noscript) -->
<div id="header">
<h1>Abstraction Layered Architecture</h1>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#truesynopsis">Synopsis</a></li>
<li><a href="#truechapter-one-what-problem-does-it-solve">1. Chapter one - What problem does it solve?</a>
<ul class="sectlevel2">
<li><a href="#truethe-big-ball-of-mud">1.1. The Big Ball of Mud</a></li>
<li><a href="#truesimplify-down-the-overwhelming-set-of-architectural-styles-patterns-principles-and-paradigms">1.2. Simplify down the overwhelming set of architectural styles, patterns, principles and paradigms</a></li>
<li><a href="#truean-optimal-reference-architecture-for-quality-attributes">1.3. An optimal reference architecture for quality attributes</a></li>
<li><a href="#truestructure-hidden-inside-the-modules">1.4. Structure hidden inside the modules</a></li>
<li><a href="#truethe-software-engineers-trap">1.5. The software engineer&#8217;s trap</a></li>
<li><a href="#truea-short-history-of-ala">1.6. A short history of ALA</a></li>
<li><a href="#trueexample-project-thermometer">1.7. Example project - Thermometer</a></li>
</ul>
</li>
<li><a href="#truechapter-two-the-structure">2. Chapter two - The structure</a>
<ul class="sectlevel2">
<li><a href="#truesoftware-elements-relations-among-them">2.1. Software elements, relations among them</a></li>
<li><a href="#truefolders-files-classes-objects-interfaces-functions">2.2. Folders, files, classes, objects, interfaces, functions</a></li>
<li><a href="#trueexecutable-expression-of-requirements">2.3. Executable expression of requirements</a></li>
<li><a href="#truediagrams">2.4. Diagrams</a></li>
<li><a href="#truecomposition-vs-decomposition-methodologies">2.5. Composition vs decomposition methodologies</a></li>
<li><a href="#truecf-component-based-development">2.6. cf Component based development</a></li>
<li><a href="#truereal-world-analogies">2.7. Real world analogies</a></li>
<li><a href="#trueexample-project-calculator">2.8. Example project - Calculator</a></li>
</ul>
</li>
<li><a href="#truechapter-three-why-the-structure-works">3. Chapter three - Why the structure works</a>
<ul class="sectlevel2">
<li><a href="#truea-thought-experiment">3.1. A thought experiment</a></li>
<li><a href="#trueabstraction-as-design-time-encapsulation">3.2. Abstraction as design-time encapsulation</a></li>
<li><a href="#truezero-coupling-and-higher-cohesion">3.3. Zero coupling and higher cohesion</a></li>
<li><a href="#truegood-versus-bad-dependencies">3.4. Good versus bad dependencies</a></li>
<li><a href="#trueknowledge-dependencies-are-on-all-layers-below">3.5. Knowledge dependencies are on all layers below</a></li>
<li><a href="#trueexecutable-expression-of-requirements-2">3.6. Executable expression of requirements</a></li>
<li><a href="#truediagrams-vs-text">3.7. Diagrams vs text</a></li>
<li><a href="#truecomposition-not-decomposition">3.8. Composition, not decomposition</a></li>
<li><a href="#trueno-data-coupling">3.9. No Data coupling</a></li>
<li><a href="#truecomposability-and-compositionality">3.10. Composability and Compositionality</a></li>
<li><a href="#truesome-real-dependency-graphs">3.11. Some real dependency graphs</a></li>
</ul>
</li>
<li><a href="#truechapter-four-programming-paradigms-and-their-execution-models">4. Chapter four - Programming paradigms and their execution models.</a>
<ul class="sectlevel2">
<li><a href="#trueintroduction-to-programming-paradigms">4.1. Introduction to programming paradigms</a></li>
<li><a href="#trueintroduction-to-execution-models">4.2. Introduction to execution models</a></li>
<li><a href="#truecoding-execution-models">4.3. Coding execution models</a></li>
<li><a href="#trueexecution-model-properties">4.4. Execution model properties</a></li>
<li><a href="#trueexample-programming-paradigms">4.5. Example Programming paradigms</a></li>
<li><a href="#truerequestresponse">4.6. Request/response</a></li>
<li><a href="#trueevent-driven-programming-paradigm">4.7. Event-driven programming paradigm</a></li>
<li><a href="#truedataflow">4.8. Dataflow</a></li>
<li><a href="#trueactivity-flow">4.9. Activity-flow</a></li>
<li><a href="#truework-flow">4.10. Work-flow</a></li>
<li><a href="#trueiiterator">4.11. IIterator</a></li>
<li><a href="#trueui-layout">4.12. UI layout</a></li>
<li><a href="#trueui-navigation-flow">4.13. UI navigation flow</a></li>
<li><a href="#truedata-schema">4.14. Data schema</a></li>
<li><a href="#truelocking-resources">4.15. Locking resources</a></li>
<li><a href="#truestate-machines">4.16. State machines</a></li>
<li><a href="#trueimperative">4.17. Imperative</a></li>
<li><a href="#truemultithreading-2">4.18. Multithreading</a></li>
<li><a href="#trueagent-based-programming">4.19. Agent based programming</a></li>
<li><a href="#trueexample-project-ten-pin-bowling">4.20. Example project - Ten-pin bowling</a></li>
<li><a href="#trueexample-project-tennis">4.21. Example project - Tennis</a></li>
</ul>
</li>
<li><a href="#truechapter-five-methodology">5. Chapter five - Methodology</a>
<ul class="sectlevel2">
<li><a href="#truethe-first-few-strokes">5.1. The first few strokes</a></li>
<li><a href="#trueagility">5.2. Agility</a></li>
<li><a href="#truetechnical-debt">5.3. Technical debt</a></li>
<li><a href="#truefolder-structure">5.4. Folder structure</a></li>
<li><a href="#trueconvention-over-configuration">5.5. Convention over configuration</a></li>
<li><a href="#trueknowledge-prerequisites">5.6. Knowledge prerequisites.</a></li>
<li><a href="#truetwo-roles">5.7. Two roles</a></li>
<li><a href="#trueexample-project-coffee-machine">5.8. Example Project - Coffee machine</a></li>
</ul>
</li>
<li><a href="#truechapter-six-perspectives">6. Chapter six - Perspectives</a>
<ul class="sectlevel2">
<li><a href="#trueencapsulation-polymorphism-and-inheritance">6.1. Encapsulation, polymorphism and inheritance</a></li>
<li><a href="#truesolid-principles">6.2. SOLID Principles</a></li>
<li><a href="#truedependency-injection-pattern">6.3. Dependency injection pattern</a></li>
<li><a href="#truephysical-boundaries">6.4. Physical boundaries</a></li>
<li><a href="#truetest-driven-development">6.5. Test Driven Development</a></li>
<li><a href="#trueobserver-pattern">6.6. Observer pattern</a></li>
<li><a href="#truelayer-patterns">6.7. Layer patterns</a></li>
<li><a href="#truefactory-method-pattern">6.8. Factory method pattern</a></li>
<li><a href="#truedecorator-pattern">6.9. Decorator pattern</a></li>
<li><a href="#truebridge-pattern">6.10. Bridge pattern</a></li>
<li><a href="#truearchitecture-styles">6.11. Architecture styles</a></li>
<li><a href="#truedsls">6.12. DSLs</a></li>
<li><a href="#truemulti-tier-architecture">6.13. Multi-tier Architecture</a></li>
<li><a href="#trueclean-architecture">6.14. Clean Architecture</a></li>
<li><a href="#trueonion-architecture">6.15. Onion Architecture</a></li>
<li><a href="#truehexagonal-architecture-ports-and-adapters">6.16. Hexagonal Architecture (Ports and Adapters)</a></li>
<li><a href="#truedomain-driven-design">6.17. Domain Driven Design</a></li>
<li><a href="#truemicroservices">6.18. Microservices</a></li>
<li><a href="#truearchitecture-evaluation-methods">6.19. Architecture evaluation methods</a></li>
<li><a href="#truemonads">6.20. Monads</a></li>
<li><a href="#truereactive-extensions">6.21. Reactive Extensions</a></li>
<li><a href="#truewpf-xaml">6.22. WPF &amp; XAML</a></li>
<li><a href="#truefunctional-programming">6.23. Functional programming</a></li>
<li><a href="#truefunctional-programming-with-monads">6.24. Functional programming with monads</a></li>
<li><a href="#truefunctional-reactive-programming">6.25. Functional Reactive Programming</a></li>
<li><a href="#trueexample-project-game-scoreboard">6.26. Example project - Game scoreboard</a></li>
</ul>
</li>
<li><a href="#truechapter-seven-the-philosophy-behind-ala">7. Chapter seven - The philosophy behind ALA</a>
<ul class="sectlevel2">
<li><a href="#truethe-human-brain">7.1. The human brain</a></li>
<li><a href="#trueabstraction">7.2. Abstraction</a></li>
<li><a href="#truecomplexity-2">7.3. Complexity</a></li>
<li><a href="#truezero-coupling-not-loose-coupling">7.4. Zero coupling, not loose Coupling</a></li>
<li><a href="#truewiring-pattern-part-one">7.5. Wiring pattern - Part one</a></li>
<li><a href="#truewiring-pattern-part-two">7.6. Wiring pattern - part two</a></li>
<li><a href="#trueexpression-of-requirements">7.7. Expression of requirements</a></li>
<li><a href="#trueno-two-modules-know-the-meaning-of-data-or-a-message">7.8. No two modules know the meaning of data or a message.</a></li>
<li><a href="#trueexpressiveness">7.9. Expressiveness</a></li>
<li><a href="#trueno-models">7.10. No models</a></li>
<li><a href="#trueabstraction-layers-2">7.11. Abstraction Layers</a></li>
<li><a href="#truecomposition-versus-decomposition">7.12. Composition versus decomposition</a></li>
<li><a href="#true41-views">7.13. 4+1 views</a></li>
<li><a href="#trueno-separation-of-ui">7.14. No separation of UI</a></li>
<li><a href="#truefeatures">7.15. Features</a></li>
<li><a href="#trueinheritance">7.16. Inheritance</a></li>
<li><a href="#truehorizontal-domain-partitions">7.17. Horizontal domain partitions</a></li>
<li><a href="#trueno-hierarchical-design">7.18. No hierarchical design</a></li>
<li><a href="#truedomain-oriented">7.19. Domain oriented</a></li>
<li><a href="#trueproduct-owner-perspective">7.20. Product owner perspective</a></li>
<li><a href="#truereuse">7.21. Reuse</a></li>
<li><a href="#truedocumentation">7.22. Documentation</a></li>
<li><a href="#truesymbolic-indirection">7.23. Symbolic indirection</a></li>
<li><a href="#trueeverything-through-interfaces">7.24. Everything through interfaces</a></li>
<li><a href="#truewhat-do-you-know-about">7.25. What do you know about?</a></li>
<li><a href="#trueexample-project-a-real-device">7.26. Example project - a real device</a></li>
</ul>
</li>
<li><a href="#truechapter-eight-surrounding-topics">8. Chapter eight - Surrounding Topics</a>
<ul class="sectlevel2">
<li><a href="#truerecursive-abstractions">8.1. Recursive abstractions</a></li>
<li><a href="#trueabstraction-of-port-io-properties">8.2. Abstraction of Port I/O properties</a></li>
<li><a href="#trueworking-with-legacy-code">8.3. Working with legacy code</a></li>
<li><a href="#truewriting-tests-architected-in-ala">8.4. Writing tests architected in ALA</a></li>
<li><a href="#truedebugging-ala-programs">8.5. Debugging ALA programs</a></li>
<li><a href="#trueala-language-features">8.6. ALA language features</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p><strong class="big">Engineering the structure of software</strong></p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/BOSS_Great_Wall.jpg" alt="BOSS_Great_Wall.jpg" width="900">
</div>
<div class="title">Figure 1. <strong>The large scale structure of the universe - what should the structure of software look like?</strong></div>
</div>
<div class="paragraph">
<p>John R Spray</p>
</div>
<div class="paragraph">
<p>Last update: 2022-03-30</p>
</div>
<div class="paragraph">
<p>This article is a work in progress. Feedback is welcome. Please send to johnspray274&lt;at&gt;gmail&lt;dot&gt;com</p>
</div>
<hr>
</div>
</div>
<div class="sect1">
<h2 id="truesynopsis"><a class="anchor" href="#truesynopsis"></a>Synopsis</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Intuitively, good quality software would allow you to read and understand any one part of the code without also having to read and understand any other part. I call this zero coupling. We are taught the meme <em>loose coupling and high cohesion</em>. It is said that a zero coupled system would not do anything. But this is only because we confuse design-time coupling with run-time communications. It is entirely possible for parts of a system to have zero knowledge about one another at design-time and still communicate at run-time. We define the word <em>coupling</em> to mean design-time coupling in this article. That&#8217;s the coupling that matters. By design-time, we mean any time you are reading, writing or understanding code.</p>
</div>
<div class="paragraph">
<p>ALA is a set of three architectural constraints to achieve zero coupling:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The only unit of code is an abstraction.</p>
</li>
<li>
<p>The only relationship allowed is a dependency on an abstraction that is significantly more abstract.</p>
</li>
<li>
<p>All abstractions must be small - as a guide, less then about 500 LOC.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Many patterns and properties emerge from these three constraints. These are explored throughout this article. But first let&#8217;s elaborate on these three constraints.</p>
</div>
<div class="paragraph">
<p><span class="big"><strong>The only unit of code is an abstraction</strong></span></p>
</div>
<div class="openblock float-group">
<div class="content">
<div class="imageblock right">
<div class="content">
<img src="images/abstracttree.jpg" alt="abstracttree">
</div>
</div>
<div class="paragraph">
<p>Abstractions are fundamental to the constraints.</p>
</div>
<div class="paragraph">
<p>An abstraction is a learnable idea or concept.</p>
</div>
<div class="paragraph">
<p>In conventional methods, a system is broken into smaller pieces that we call modules, components or classes. These modules, components or classes tend to implicitly collaborate with one another to form the system. They are like jigsaw pieces. These specific pieces fit together in one specific way to make a specific picture. The system is not explicit, it is just the collaboration of the parts.</p>
</div>
<div class="paragraph">
<p>In contrast, abstractions are like lego pieces. These pieces are general and can be composed in an infinite variety of ways. A specific arrangement is an explict design. It can be varied without changing the abstractions it uses.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Abstractions have no knowledge of one another, nor the system that uses them.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>All implicit collaboration between modules in conventional architecture becomes explicit code inside a new abstraction in a higher layer in ALA.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>This first constraint means that the ALA equivalent of a <em>module</em> is an <em>abstraction</em>. The distinction is crucial. Modules that are not good abstractions only provide encapsulation. The term <em>encapsulation</em> means hiding details at compile-time, but not necessarily at design-time. Abstractions are what our brains use, so only abstractions hide details at design-time.</p>
</div>
<div class="paragraph">
<p>Abstractions are the only mechanism that provides design-time <em>information hiding</em>. When David Parnas coined the term <em>information hiding</em> he meant at <em>design-time</em>. Unfortunately there is a popular meme that <em>information hiding</em> means <em>encapsulation</em>. The same idea of design-time information hiding has other names such as Alistair Cockburn&#8217;s <em>protected variations</em>, and Robert Martin&#8217;s version of the OCP (open closed principle).</p>
</div>
<div class="paragraph">
<p>In the absence of direct computer language support for abstractions, ALA generally implements  abstractions as source files (like modules in C). The file usually contains one class, but may contain a small number of classes, interfaces, enums, delegates, typedefs, functions, etc.</p>
</div>
<div class="paragraph">
<p>Inside an abstraction, there are no dependency rules, or any organisational rules for that matter. It is all considered cohesive code. So internally, abstractions are small balls of mud.</p>
</div>
<div class="paragraph">
<p>Charles Krueger pointed out that <em>abstraction</em> and <em>reuse</em> are two sides of the same coin. More abstract means more reusable. More abstract also tends to mean more stable because a more abstract idea is drawn from more examples, and is therefore a more ubiquitous more fundamental idea. The abstraction 'squareroot' is very stable despite the fact that new instances of its use occur frequently.</p>
</div>
<div class="paragraph">
<p>Math library functions are good abstractions because they were written without knowledge of who will use them. If we conceive of and write abstractions similarly, without knowledge of the code that will use them, we will also get good abstractions. However, we also need to build useful abstractions. This will require some knowledge of what sorts of things we are wanting to build. We call that the domain, and the abstractions are called domain specific abstractions.</p>
</div>
<div class="paragraph">
<p><span class="big"><strong>The only relationship is a dependency on a more abstract abstraction</strong></span></p>
</div>
<div class="paragraph">
<p>The second constraint is that dependencies must be on abstractions that are significantly more abstract (than the abstraction whose implementation contains the dependency).</p>
</div>
<div class="paragraph">
<p>When we use a more abstract abstraction, for example, when a function that calculates standard deviation uses a function that calculates squareroot, the dependency is only on the concept of squareroot. As a concept, squareroot has been stable for thousands of years. A dependency on an abstraction is a dependency on a concept that is relatively stable. Because of this stability, there is zero coupling between the code that <em>implements</em> standard deviation and the code that <em>implements</em> squareroot.</p>
</div>
<div class="paragraph">
<p>For this to work, the abstraction being used must be significantly more abstract than the one whose implementation code uses it.</p>
</div>
<div class="paragraph">
<p><strong>Communication between instances of peer abstractions</strong></p>
</div>
<div class="openblock float-group">
<div class="content">
<div class="imageblock right">
<div class="content">
<img src="images/collaboration.jpg" alt="collaboration">
</div>
<div class="title">Figure 2. Collaboartion between abstractions is illegal</div>
</div>
<div class="paragraph">
<p>Seemingly, communication is needed between peer abstractions to make a system work. However, in ALA, a dependency from one abstraction on the interface of another is illegal. For example, if the code implementing standard deviation were to, say, output the result directly to a peer module like a display, it would destroy the standard deviation abstraction. Even if the dependency is on the interface of display, the code in standard deviation would be coupled to a concept that is not more abstract. Standard deviation would no longer be easily learnable as a concept and it would no longer be reusable without dragging display with it.</p>
</div>
<div class="paragraph">
<p>Furthermore, over tme, the fixed arrangement between the standard deviation function and the display function is likely to lead the display function to provide specifically what the standard deviation function needs. So both functions would now just be specific parts of a specific system. They would be collaborating.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>In ALA a more specific abstraction in a higher layer represents the system. This abstraction calls the standard deviation function and then calls the display function.</p>
</div>
<div class="paragraph">
<p><strong>Using objects instead of functions</strong></p>
</div>
<div class="paragraph">
<p>We don&#8217;t particularly like the system abstraction in the higher layer handling the data itself. We prefer the system abstraction&#8217;s job is just to compose the two peer abstractions - to wire them together.</p>
</div>
<div class="paragraph">
<p>So we make standard deviation and display classes with I/O ports. Instances of them can then be wired together by the system abstraction. While the standard deviation and display abstractions know nothing about each other, the instances can communicate directly at run-time. As we shall see shortly, the next layer down will provide an abstract interface which we call a programming paradigm.</p>
</div>
<div class="paragraph">
<p><strong>All dependencies are knowledge dependencies</strong></p>
</div>
<div class="paragraph">
<p>A dependency on an abstraction means you need to understand the concept the abstraction represents. We often call it a knowledge dependency. You could not understand the code that calculates standard deviation without first knowing about the concept of squareroot. However, to understand the code that calculates standard deviation does not require knowledge of the concept of a display, so that dependency is illegal.</p>
</div>
<div class="paragraph">
<p>Going one layer up, to understand the code in the system abstraction requires knowledge of both the concept of standard deviation and the concept of display. It is fine for the system to have dependencies on both so it can compose a standard deviation and a display.</p>
</div>
<div class="paragraph">
<p><strong>Good and bad dependencies</strong></p>
</div>
<div class="openblock float-group">
<div class="content">
<div class="imageblock right">
<div class="content">
<img src="images/dependencyimage.png" alt="dependencyimage.png" width="400">
</div>
</div>
<div class="paragraph">
<p>Conventional code contains both good and bad dependencies.</p>
</div>
<div class="paragraph">
<p>Good dependencies are ones on abstractions such as math library classes. There will typically be many bad dependencies. These bad dependencies were put there for different parts of a program to inter-communicate. They are also used to break a program up into smaller but more specific pieces. Bad dependencies make the dependency diagram look like the one on the right. My partner says these look like two ferris wheels engaged in a mating act. Even if there are no cyclic dependences, there are still typically many bad dependencies.</p>
</div>
<div class="paragraph">
<p>In ALA, both types of bad dependencies are illegal. Normally in conventional code we don&#8217;t distinguish between good and bad dependencies. We consider them all to be necessary if the system is to work. But it turns out that systems can be built using only good dependencies.</p>
</div>
<div class="paragraph">
<p>Good dependencies are not just good - they are really good. We want as many of them as possible, because then we are reusing our abstractions. Bad dependencies are not just bad - they are really bad. They cause a growing tangled network of complexity.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Since bad dependencies are illegal in ALA, how do parts of the system communicate? Each bad dependency becomes a line of code inside a higher layer abstraction. That line of code connects two instances of abstractions. There it is cohesive with other lines of code that connect other instances of abstractions to make the system.</p>
</div>
<div class="paragraph">
<p>If you think about it, circular dependencies come about because there is circular communications. When you stop representing communications with dependencies, and start representing them with wiring code, circular wiring makes perfect sense. When you use only knowledge dependencies, the whole dependency problem just goes away.</p>
</div>
<div class="paragraph">
<p>Association relationships in the UML class diagram are bad dependencies, and are illegal in ALA. The only legal UML class relationship is composition (filled diamond arrow), and then <em>only</em> if the class being used is more abstract. Now when you use such an abstraction you refer to it by name, not use an arrow on a diagram. So if you draw a UML class diagram of an ALA application, you will just get disconnected boxes sitting in space. They will be arranged in layers as described below, but there will be no lines at all. The UML class diagram is not only not useful in ALA, it is the cause of much unnecessary complexity.</p>
</div>
<div class="paragraph">
<p><strong>Emerging layers</strong></p>
</div>
<div class="openblock float-group">
<div class="content">
<div class="imageblock right">
<div class="content">
<img src="images/Layers.png" alt="Layers.png" width="600">
</div>
<div class="title">Figure 3. Abstraction layers</div>
</div>
<div class="paragraph">
<p>Because of the constraint that an abstraction that is depended on must be significantly more abstract, abstractions form layers. This gives the architecture its name: abstraction layered architecture. We give the layers names that reflect the types of abstractions that tend to go in them - <em>application layer</em>, <em>domain abstractions layer</em> and <em>programming paradigms layer</em>. Each layer becomes a folder and a namespace.
For large applications, another layer called <em>features layer</em> or <em>user stories layer</em> comes into the picture between the application and domain abstraction layers.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>There is no 'hierarchical' structure in ALA. In other words, abstractions cannot be contained within abstractions. Layers replace hierarchical containment. This is because lower layer abstractions must be public for reuse, not hidden inside an encapsulation hierarchy.</p>
</div>
<div class="paragraph">
<p>Once you know the set of abstractions available in lower layers, it is easy to read and understand code in higher layers that use instances of them. Reading a line of code that uses an abstraction by name is like reading any other line of code. A good abstraction is when we don&#8217;t need to follow the indirection and go and read the code that implements the abstraction. For example, when we see a use of squareroot, if our brain has already learned he concept of squareroot once, we can just stay in the context of the code that is using the squareroot. Squareroot is just part of the language. ALA is about achieving that level of readability for every single dependency in the entire application.</p>
</div>
<div class="paragraph">
<p><span class="big"><strong>All abstractions must be small</strong></span></p>
</div>
<div class="openblock float-group">
<div class="content">
<div class="imageblock right">
<div class="content">
<img src="images/smalltree.jpg" alt="smalltree.jpg" width="200">
</div>
</div>
<div class="paragraph">
<p>The final constraints prevents us from conforming to the first two constraints by simply putting everything into one big abstraction. That&#8217;s obviously not desirable, so we need this constraint to force us to create abstractions from which we can compose applications.</p>
</div>
<div class="paragraph">
<p>Abstractions are internally highly cohesive, which means that all code inside them is inter-related. Internally they are a small ball of mud. If all that inter-related code is to be understood, it needs to be small.</p>
</div>
<div class="paragraph">
<p>A rule of thumb is around 100 to 500 lines of code. If the code is in diagram form (which will often be the case for reasons we will explain later), we should limit the size to 100-500 nodes and edges.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>If an abstraction contains more than 500 lines, it is starting to get over the brain limit for other programmers to understand. If abstractions average less than 100 lines of code, we will have more abstractions than we needed to, and burden ourselves with an unnecessarily high number of them to learn. The sweet spot is somewhere in between.</p>
</div>
<div class="paragraph">
<p><span class="big"><strong>Other emergent patterns</strong></span></p>
</div>
<div class="openblock float-group">
<div class="content">
<div class="imageblock right">
<div class="content">
<img src="images/ropespiral.jpg" alt="ropespiral.jpg" width="200">
</div>
</div>
<div class="paragraph">
<p>ALA emerges many other patterns and properties. Many of them are already known about in software engineering, which is not surprising - such things as DSLs (Domain Specific Languages), Dependency Injection, Composite and Decorator patterns, monad like composition, etc. However, there are often subtle but important differences. For example the observer pattern (publish/subscribe) can be used to achieve calls going up the layers at run-time, but may not be used between abstractions in the same layer. The subscribers&#8217;s reference to the publisher would be an illegal dependency. A line of code in an abstraction in a higher layer must do the subscribing, which is effectively what the wiring pattern described below is.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Inheritance is not used in ALA. We only use composition because inheritance breaks abstractions.</p>
</div>
<div class="paragraph">
<p><span class="big"><strong>Wiring pattern</strong></span></p>
</div>
<div class="openblock float-group">
<div class="content">
<div class="imageblock right">
<div class="content">
<img src="images/WiringPattern.png" alt="WiringPattern.png" width="500">
</div>
<div class="title">Figure 4. <strong>Wiring pattern frequently used in ALA</strong></div>
</div>
<div class="paragraph">
<p>I use the wiring pattern shown on the right frequently to build ALA applications.</p>
</div>
<div class="paragraph">
<p>Abstraction A in the application layer has legal dependencies on abstractions B and C in the domain abstractions layer. B and C have dependencies on D in the programming paradigms layer.</p>
</div>
<div class="paragraph">
<p>D is a programming paradigm interface. This interface is not owned by B or C. It is its own abstraction representing a compositional idea, such as Dataflow.</p>
</div>
<div class="paragraph">
<p>B and C have ports of type D. B&#8217;s port is implemented as a field in the class, and C&#8217;s port is implemented by implementing D&#8217;s interface.</p>
</div>
<div class="paragraph">
<p>A can create an instance of B and an instance of C and wire them together because they have compatible ports. Wiring assigns C causes the instance of C, cast as the interface, to be assigned to the field in B.</p>
</div>
<div class="paragraph">
<p>While abstraction B and abstraction C know nothing about each other, the instances of B and C can communicate with each other at run-time.</p>
</div>
</div>
</div>
<div class="paragraph">
<p><span class="big"><strong>Going forward</strong></span></p>
</div>
<div class="paragraph">
<p>When the idea first occurred that zero coupling could be achieved through the stated constraints, we did not know what it would be like, or even if it was possible, to create a working system. Our experience since then is that zero-coupling has always been possible, but coming up with the abstractions is sometimes obvious and sometimes not so obvious. Also, some (but not all) conventional habits, languages, patterns, and architectural styles will conspire against you to break the fundamental constraints.</p>
</div>
<div class="paragraph">
<p>In time there will be tools to help enforce the ALA constraints. As Robert Martin points out, an indication of a good abstraction can be the number of times it is used, but ultimately this may require AI. When that is achieved, it will be possible to automatically refactor legacy code into ALA code.</p>
</div>
<hr>
<div class="paragraph">
<p><span class="big"><strong>A tiny example</strong></span></p>
</div>
<div class="paragraph">
<p>Every chapter has an example, and we do the same here in the summary section. Unlike most pedagogical sized examples, these examples progressively become non-trivial. Yet because of ALA&#8217;s power, they remain uncomplicated and easy to understand.)</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Requirement: Make a switch control a light.</pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/diagram-switch-light.png" alt="diagram switch light">
</div>
</div>
<div class="paragraph">
<p>The diagram above is not documentation. Nor is it a high-level architectural view of the solution. It is the solution. It contains all the detail needed for an executable application. The diagram is literally compiled. Let&#8217;s do that now by hand:</p>
</div>
<div class="paragraph">
<p><strong>Application layer</strong></p>
</div>
<div class="listingblock">
<div class="title">System.cs</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">var system = new Switch().WireTo(new Light());
system.Run();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Given this code, it is not difficult for any programmer to write the necessary Switch and Light domain abstractions, together with a dataflow programming paradigm abstraction to make that code execute.</p>
</div>
<div class="paragraph">
<p>In conventional code, we would likely have broken the system up into two modules, one for the switch and one for the light. The switch might directly call a method in the interface for the light, or vice versa. In ALA you can&#8217;t do that. The concepts of Switch and Light, already handed to us as abstractions in the words of the requirements, must remain as abstractions. They can&#8217;t know about or communicate with one another and they can&#8217;t know about the specific system.</p>
</div>
<div class="paragraph">
<p>A concept of dataflow is invented to allow <em>instances</em> of Switch and Light to communicate at run-time. Dataflow is an even more abstract abstraction. It resides in the programming paradigms layer. It is a steam of data without end. It is not a specific interface of either Switch or Light. It allows Switches and Lights to be wired arbitrarily to anything using the same dataflow concept and data type.</p>
</div>
<div class="paragraph">
<p>The <em>system</em> is also an abstraction, albeit a more specific one than Switch and Light. Instances of it can be reused in a building. Its purpose is to know about the system comprising a light and a switch connected together. It knows about Switches,  Lights and Dataflows as abstract concepts but doesn&#8217;t know anything about their implementation details.</p>
</div>
<div class="paragraph">
<p>The system diagram is a direct, formal restatement of the requirements. So the diagram is three things in one: The formal statement of requirements, the high level architecture, and the executable. One source of truth for all three. Conventional software engineering usually has three different documents for these which must be kept synced.</p>
</div>
<div class="paragraph">
<p>When the program is this small, it looks like we just created four abstractions when two modules would have done. However, by creating an abstraction to represent the system level knowledge, and a dataflow programming paradigm abstraction to allow the lines on the diagram to have a meaning, we make several powerful improvements to the code that are important as the application scales:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>There is now an explicit place that cohesively implements the requirement instead of having the requirement&#8217;s implementation distributed in an obviscated way inside Switch and Light. What is loose coupling between modules in conventional code becomes cohesive code inside a higher (more specific) abstraction in ALA. Changes to the system are made in this one place.</p>
</li>
<li>
<p>The code inside System, Switch, Light and Dataflow are zero-coupled with one another.</p>
</li>
<li>
<p>Being abstractions, Switch and Light are reusable. They are reusable in the same application or in other applications in the domain. Dataflow is even more reusable.</p>
</li>
<li>
<p>Switch and Light are testable with unit tests.</p>
</li>
<li>
<p>Testing the system abstraction is exactly acceptance testing. In ALA, you always test with dependencies in place (but mock the ports). Just as you would not mock out a dependency such as squareroot, you do not mock any dependencies in ALA, because all dependencies are on knowledge.</p>
</li>
<li>
<p>The Switch and the Light can be handed off to different individuals or teams because as abstractions they know nothing about each other, and they know nothing about the System. In fact abstractions will be better quality if the teams do not collaborate with each other on their implementations so that the abstractions themselves do not collaborate.</p>
</li>
<li>
<p>Programming paradigms provide the <em>meaning</em> of connecting together two instances of domain abstractions. We can use multiple different programming paradigms in the one top level design. ALA is said to be polyglot in programming paradigms. This makes it very expressive.</p>
</li>
<li>
<p>In terms of methodology, instead of <em>decomposing</em> the Switch-Light system into parts, we <em>composed</em> it from abstractions. This point may seem subtle at first, but it is profoundly important. The method of dividing a system into smaller parts until the parts are small enough to implement is arguably the prevalent approach in traditional software engineering. However it tends to result in parts that are more specific than the system (can&#8217;t be reused for anything) and generally inter-collaborating parts that have implicit knowledge of each other to work.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Here is skeleton code of the two domain abstractions.</p>
</div>
<div class="paragraph">
<p><strong>Domain abstractions layer</strong></p>
</div>
<div class="listingblock">
<div class="title">Switch.cs</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">// domain abstraction
class Switch
{
    // port
    private IDataFlow&lt;bool&gt; output;

    // called from internal code (not shown) when it detects a hardware change
    private void SwitchChange(bool newState)
    {
        output.Send(newState);
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Light.cs</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">// domain abstraction
class Light : IDataFlow&lt;bool&gt;
{
    // port
    IDataFlow&lt;bool&gt;.Send(bool data)
    {
        if (data) // turn on the light
        else // turn off the light
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Each of these abstractions implements a <em>port</em>, which allows instances of them to be wired using the programming paradigm, DataFlow.</p>
</div>
<div class="paragraph">
<p>Here is our programming paradigms layer which contains IDataFlow:</p>
</div>
<div class="paragraph">
<p><strong>Programming Paradigms layer</strong></p>
</div>
<div class="listingblock">
<div class="title">DataFlow.cs</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">// Programming paradigm: DataFlow
interface IDataFlow&lt;T&gt;
{
    void Send(T data);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In ALA, we frequently use a <strong>wiring pattern</strong>, as depicted by the diagram in Figure 4, which consists of instantiating domain abstractions and wiring them together by ports that use an even more abstract interface representing a programming paradigm. The wiring pattern is quite ubiquitous, and therefore comes from a foundation layer that resides below the Programming Paradigms layer:</p>
</div>
<div class="paragraph">
<p><strong>Foundation layer</strong></p>
</div>
<div class="listingblock">
<div class="title">Wiring.cs</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">public static object WireTo(this object a, object b)
{
    // using reflection:
    // 1. Find a private field in object "a" that matches in type an interface implemented by object "b".
    // 2. Assign object "b" to that field in object a.
    // 3. Return object "a".
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note: A basic implementation of WireTo is listed in Chapter Two. You can get the source for a WireTo extension method from one of the Github repositories for the example projects in several following chapters.</p>
</div>
<div class="paragraph">
<p>Note: ALA does not require the use of reflection. I use reflection because it allows me to use an extension method to get a WireTo operator implemented on all objects. It allows me to make specifying the port name optional. It also allows me to make the port fields in the class private so they do not look like part of the public configuration interface to the layer above.</p>
</div>
<div class="paragraph">
<p>If you are generating wiring code from the diagram automatically using a tool, and you make the port fields public, you could generate code like the following:</p>
</div>
<div class="listingblock">
<div class="title">Application.cs</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">new Switch().output = (IDataFlow&lt;double&gt;) new(Light);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now that we know how to express requirements by composition of domain abstractions, let&#8217;s quickly demonstrate the ease of maintenance of our application:</p>
</div>
<div class="paragraph">
<p>Requirement: Add a sensor to turn on the light when the switch is on and it is dark. And give a feedback indication:</p>
</div>
<div class="paragraph">
<p>(For these small examples, we will manually generate code from the diagrams.)</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/diagram-switch-light-sensor.png" alt="diagram switch light sensor">
</div>
</div>
<div class="listingblock">
<div class="title">Application.cs</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">var andGate = new AndGate();
new Main
    .WireTo(new Switch()
        .WireTo(andGate
            .WireTo(new Light())
            .WireTo(new Indicator())))
    .WireTo(new Sensor(threshold:0.5)
        .WireTo(andGate))
    .Run();</code></pre>
</div>
</div>
<div class="paragraph">
<p>We just invented some new domain abstractions: AndGate and Sensor, again directly implied by the requirements.</p>
</div>
<div class="paragraph">
<p>One of the domain abstraction instances has a configuration of 0.5. This is a threshold for expressing the requirement clause "is dark".</p>
</div>
<div class="paragraph">
<p>Notice that this application is easier to write in this way than it would be in conventional C code. This is because the programming paradigm we are using, dataflow, suits the expression of these requirements. Most C code to do even such a simple requirement as this would likely already be messy in the way it handles run-time execution.</p>
</div>
<div class="paragraph">
<p>The astute reader will notice that the AndGate can&#8217;t implement IDataFlow&lt;bool&gt; twice for its two inputs. In later projects, we will show how we work around this language constraint.</p>
</div>
<div class="paragraph">
<p>You may also notice that the fanout from the output of the AndGate to both the Light and the Indicator won&#8217;t work. We show how this implementation problem is solved in later projects as well.</p>
</div>
<div class="paragraph">
<p>Now that we have some reusable domain abstractions and programming paradigms, let&#8217;s quickly write another trivial application:</p>
</div>
<div class="paragraph">
<p>Requirement: Turn on the light from a tick item in the Tools menu of a PC application, and give an indication in the status bar when the light is on.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/diagram-menu-light-status.png" alt="diagram menu light status">
</div>
</div>
<div class="listingblock">
<div class="title">Application.cs</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">var indicator = new Indicator( {"Light is off", "Light is On"} );
new MainWindow()
    .WireTo(new Menu())
        .WireTo(new Menu("Tools")
            .WireTo(new TickBox(label:"Light")
                .WireTo(new Light())
                .WireTo(indicator)
            )
        )
    )
    .WireTo(new StatusBar()
        .WireTo(indicator) // put the indicator on the UI
    )
    .Run();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here we are introducing some graphical UI, so we invented another programming paradigm for "UI layout". It is used between all the UI elements: MainWindow, Menu, Tickbox, StatusBar, Indicator. Wiring things together using that programming paradigm means things are arranged inside things on the UI.</p>
</div>
<div class="paragraph">
<p>Notice how ALA is polyglot in programming paradigms. We use UI layout and dataflow in the same diagram. Notice also that we don&#8217;t separate UI from business logic and data models. These are highly cohesive things from the perspective of user stories. Instead we separate the implementations of the domain abstractions. It is still easy to swap out, for example, the UI implementation. The diagram above could be implemented as a web application or a desktop application by swapping between two sets of UI domain abstraction implementations.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s do an application to browse for and display a (dynamic content) CSV file on a grid, filtered by a user specified name, and sorted by names. The CSV file has headings that will display in the grid.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/diagram-csv-to-grid.png" alt="diagram csv to grid">
</div>
</div>
<div class="paragraph">
<p>The wiring between the CSVReadWriter, Filter, Sort and Grid uses a new programming paradigm alloes dynamic row and columns of data to flow.  The Grid abstraction is able to pull rows of data.</p>
</div>
<div class="paragraph">
<p>The wiring between the MeniItem and the OpenFileBrowser is uses an Event-driven programming paradigm.</p>
</div>
<div class="listingblock">
<div class="title">Application.cs</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">var grid = new Grid();
var csvReaderWriter = new CsvReaderWriter
var filter = new Filter() {Column = "Name"};
new MainWindow()
    .WireTo(new Menu()
        .WireIn(new Menu("File"))
        .WireIn(new MenuItem("Open"))
        .WireIn(new OpenFileBrowser(extensions = {"csv"} ))
        .WireIn(csvReaderWriter)
        .WireIn(filter)
        .WireIn(new Sort() { Column="Name" })
        .WireIn(grid) { Column="Name" }
    )
    .WireTo(new TextBox(Label="Filter by name")
        .WireTo(filter)
    )
    .WireTo(grid)
    .Run();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note: WireTo() returns its first operand (this). WireIn() is the same as WireTo() except that it returns its second operand. These operators support the fluent coding style being used in this hand compiled code so that we do&#8217;t have to think of names for every instance of an abstraction.</p>
</div>
<div class="paragraph">
<p>The methodology we have been following is that you write the application code (diagram) first (or part of it), just focusing on expressing the requirements. This causes you to invent domain abstractions and programming paradigms. Then you come up with an execution model that will make the programming paradigms execute. For example, the two interfaces listed below might be what you would come up with for Event and PullTable.</p>
</div>
<div class="listingblock">
<div class="title">Event.cs</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">// Programming paradigm: Event driven
interface IEvent
{
    void Execute();
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">PullTable.cs</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">// Programming paradigm: TableDataFlow
interface IPullTable&lt;T&gt;
{
    event DataReadyDelegate SourceReady;
    List&lt;string&gt; GetHeaderLabels();
    IEnumerable&lt;T&gt; GetIEnumerable&lt;T&gt;();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We then expect Grid to have a field of type IPullTable&lt;List&lt;string&gt;&gt; and CsvFileReaderWriter to implement it. This interface is abstract. Both Filter and Sort will also have both input and output ports of type  IPullTable&lt;List&lt;string&gt;&gt;. The List represents one row of the table. If the columns are known at compiletime, T can be a tuple.</p>
</div>
<div class="paragraph">
<p>Don&#8217;t worry, we won&#8217;t be creating new programming paradigm abstractions at this rate for long. In fact we already have most of the ones we will use in all our example projects.</p>
</div>
<div class="paragraph">
<p>Notice how in the above examples, we have used software engineering patterns we already know about, just in a different way. There is DSL (Domain Specific Language), Dependency Injection (which is what the WireTo operator does), Event driven programming, XAML-like UI layout (without the XML), RX (Reactive programming), monad-like wiring up of objects, and the fluent style.</p>
</div>
<div class="paragraph">
<p>Notice how the application diagram in each case is both a direct representation of the requirements and executable.
Application diagrams do not leave out details from requirements because ultimately they are a complete expression of them. Instead, they leave out details of implementation.</p>
</div>
<div class="paragraph">
<p>To the extent that the requirements are cohesive, so the code that expresses them should be. For example, we do not try to separate the specific UI, I/O, business logic, persistent data etc into different modules because they are highly cohesive for a given requirement. Most other architectural patterns do separate in this way, which creates coupling. Instead we reduce the problem in a different way - through the use of domain abstractions which provide reusable aspects of implementation. All knowledge and details from the requirements end up in the application layer, but that&#8217;s all that goes there.</p>
</div>
<div class="paragraph">
<p>Note: A network-like structure is showing up in these small applications because each requirement in itself contains a network of relationships. ALA embraces this and makes it explicit, which is why the requirements are best expressed as diagrams.</p>
</div>
<div class="paragraph">
<p>Although the fluent style is a nice way to hand-compile these small diagrams, code like this with indenting and nested brackets does not scale up well for large diagrams. (It is still better than the tangled web of dependencies they would form in conventional modular code though.) But we can do better. We will not be hand-writing code like this for large applications - we will automatically generate the code from the diagrams.</p>
</div>
<div class="paragraph">
<p>Finally, the wiring pattern used in the examples above is only one possible way of meeting the fundamental ALA constraints. For example, ALA can also be applied to functional programming. Indeed monads use a comparable wiring pattern. But we will use the wiring pattern shown above in most of our examples. ALA may appear to be synonymous with this wiring pattern, but actually ALA is just the three fundamental constraints stated at the beginning of this introduction.</p>
</div>
<hr>
<div class="paragraph">
<p>This web site is a work in progress. ALA is a research in progress. Please don&#8217;t hesitate to provide feedback to the e-nail address given at the end.</p>
</div>
<div class="paragraph">
<p>I would like to acknowledge the help of Roopak Sinha at AUT (Auckland University of Technology) for his significant academic contributions and ideas for ALA, and his work in rigorously testing ALA.</p>
</div>
<div class="paragraph">
<p><a href="Abstraction_Layered_Architecture_Paper_ECSA_2018.pdf">ALA Paper presented at ECSA 2018</a></p>
</div>
<div class="paragraph">
<p><a href="Building_Maintainable_Software_Using_Abstraction_Layering_IEEE_TSE_2022.pdf">ALA Paper published in IEEE Transactions on Software Engineering 2022</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="truechapter-one-what-problem-does-it-solve"><a class="anchor" href="#truechapter-one-what-problem-does-it-solve"></a>1. Chapter one - What problem does it solve?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>If you already have some experience writing code, skip this chapter. If you already know about difficult to maintain code, big balls of mud or spaghetti code, skip this section. If you already find it hard to trace out the large scale structure through the modules of a design, skip this chapter. If you already find it hard to get your head around the plethora of design patterns and architectural styles, skip this section. However, the example at the end is pretty cool - it starts with the type of typical C code that I see most students write, and then refactors, it step by step, into ALA compliant code - you should take a look at that.</p>
</div>
<div class="paragraph">
<p>The problem that ALA solves can be seen as any one of the following perspectives.</p>
</div>
<div class="sect2">
<h3 id="truethe-big-ball-of-mud"><a class="anchor" href="#truethe-big-ball-of-mud"></a>1.1. The Big Ball of Mud</h3>
<div class="paragraph">
<p>ALA is an in-the-large strategy to organise code. It provides the constraints needed for the code structure to never degenerate into sphagetti code, or what Brian Foote and Joseph Yoder describe as a "big ball of mud". As the software  life cycle continues, retaining the organisation becomes easier rather than harder.</p>
</div>
</div>
<div class="sect2">
<h3 id="truesimplify-down-the-overwhelming-set-of-architectural-styles-patterns-principles-and-paradigms"><a class="anchor" href="#truesimplify-down-the-overwhelming-set-of-architectural-styles-patterns-principles-and-paradigms"></a>1.2. Simplify down the overwhelming set of architectural styles, patterns, principles and paradigms</h3>
<div class="paragraph">
<p>There are many traditional so-called architectural styles, patterns, principles and paradigms. The problem of structuring software code to meet quality attributes involves mastering an overwhelming number of them. Here are some examples:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>loose coupling and high cohesion, information hiding, separation of concerns</p>
</li>
<li>
<p>DSLs, components and connectors, aspects, model driven, MVC, inversion of control, functional programming, UML Class diagrams, sequence diagrams, activity diagram.</p>
</li>
<li>
<p>Views, Styles, Patterns, Tactics, Models, ADL&#8217;s, ADD, SAAM, ATAM, 4+1, Decomposition</p>
</li>
<li>
<p>CBD/CBSE, C&amp;C, Pipes &amp; Filters, n-tier, Client/Server, Plug-in, Microservices, Monolithic, Contracts, Message Bus</p>
</li>
<li>
<p>Modules, Components, Layers, Classes, Objects, Abstraction, Granularity</p>
</li>
<li>
<p>Semantic coupling, Syntax coupling, Temporal coupling, existence coupling, Dependencies, Interactions, Collaboration</p>
</li>
<li>
<p>Interfaces, Polymorphism, Encapsulation, Contracts, Interface Intent</p>
</li>
<li>
<p>Execution models, Event-Driven, Multithreaded, Mainloop, Data-driven, Concurrency, Reactor pattern, Race condition, Deadlock, Priority Inversion, Reactive</p>
</li>
<li>
<p>Principles: SRP, OCP, LSP, ISP, DIP; MVC, MVP, etc</p>
</li>
<li>
<p>Design Patterns: Layers, Whole-Part, Observer, Strategy, Factory method, Wrapper, Composite, Decorator, Dependency Injection, Callbacks, Chain of Responsibility, etc</p>
</li>
<li>
<p>Expressiveness, Fluency, DDD, Coding guidelines, Comments</p>
</li>
<li>
<p>Programming Paradigms, Imperative, Declarative, Object oriented design, Activity-flow, Work-flow, Dataflow, Function blocks, Synchronous, State machine, GUI layout, Navigation-flow, Data Schema, Functional, Immutable objects, FRP, RX, Monads, AOP, Polyglot-Programming Paradigms</p>
</li>
<li>
<p>Messaging: Push, Pull, Synchronous, Asynchronous, Shared memory, Signals &amp; Slots</p>
</li>
<li>
<p>Memory management, Heap, Persistence, Databases, ORMs</p>
</li>
<li>
<p>Waterfall, Agile, Use cases, User stories, TDD, BDD, MDSD</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Mastering all these topics takes time. Even if you can, juggling them all and being able to use the right ones at the right time is extremely taxing on any developer. Add to that the mastering of technologies and tools, keeping to agile sprint deadlines, and commitment to your team and management, it is an almost impossible task. 'Working code' tends to be what the team is judged on, especially by project managers or product owners who have no direct interest in architecture or even the Definition of Done. They don&#8217;t want to know about the rather negative sounding term, "technical debt".</p>
</div>
<div class="paragraph">
<p>Most texts will tell you that these are all tools and that you need to use the right tools for each job. It all depends, they say, on the particular system, and its particular functional and non-functional requirements. In most cases they end up being used in an ad-hoc manner that doesn&#8217;t work well. In some cases their use is actually harmful.</p>
</div>
<div class="paragraph">
<p>ALA says this is incorrect. There exists a meta-architecture consisting of two fundamental constraints that all software should follow. Then styles, patterns, principles and paradigms like the ones listed above will emerge easily. Some, like MVC, will be revealed as being bad.</p>
</div>
<div class="paragraph">
<p>Being a pre-worked recipe of the aforementioned styles and patterns, ALA actually contains no truly novel ideas. Some ingredients are accentuated in importance more than you might expect (such as abstraction). Some are relatively neutral. Some are purposefully left out. The biggest surprise for me during the conception process of ALA was that some well-established software engineering memes seemed to be in conflict. Eventually I concluded that they were in-fact bad. We will discuss these in detail in subsequent chapters.</p>
</div>
<div class="paragraph">
<p>Like any good recipe, the ingredients work together to form a whole that is greater than the sum of parts. The resulting code quality is significantly ahead of what the individual memes do by themselves. It continues to surprise me just how effective, and enjoyable, it is.</p>
</div>
</div>
<div class="sect2">
<h3 id="truean-optimal-reference-architecture-for-quality-attributes"><a class="anchor" href="#truean-optimal-reference-architecture-for-quality-attributes"></a>1.3. An optimal reference architecture for quality attributes</h3>
<div class="paragraph">
<p>ALA is a reference architecture. It is independent of any specific domain, so it is a general reference architecture. The reference architecture is 'optimal' for certain non-functional requirements. By optimal, I mean that it makes these qualities as good as they can be:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Readability</p>
</li>
<li>
<p>Complexity</p>
</li>
<li>
<p>Maintainability</p>
</li>
<li>
<p>Testability</p>
</li>
<li>
<p>Understandability</p>
</li>
<li>
<p>Modifiability</p>
</li>
<li>
<p>Extensibility</p>
</li>
<li>
<p>Dependability</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If other non-functional requirements are also important, ALA provides a good starting point. Even if the ALA structure must be compromised for other qualities, it is still better to start with these quality attributes optimised and deviate from them as necessary. As it happens, the maintainability resulting from ALA frequently makes other quality attributes easy to achieve as well. For example, in an ALA application it is often easy to make performance optimizations in the execution model that don&#8217;t affect the application code. Or, you can port an application without changing the application code.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Performance</p>
</li>
<li>
<p>Availability</p>
</li>
<li>
<p>Scalability</p>
</li>
<li>
<p>Portability</p>
</li>
<li>
<p>Security</p>
</li>
<li>
<p>Usability</p>
</li>
<li>
<p>Fault-tolerance</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="truereadability"><a class="anchor" href="#truereadability"></a>1.3.1. Readability</h4>
<div class="openblock float-group">
<div class="content">
<div class="imageblock right">
<div class="content">
<img src="images/close_up_code.jpg" alt="close_up_code.jpg" width="400">
</div>
<div class="title">Figure 5. Code quickly becomes a big ball of mud</div>
</div>
<div class="paragraph">
<p>ALA code is readable, not because of style, convention, comments or documentation, but because any one piece of code appears to you as a separate uncoupled little program.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="truecomplexity"><a class="anchor" href="#truecomplexity"></a>1.3.2. Complexity</h4>
<div class="paragraph">
<p>There is a meme in the software industry that says that the complexity of software must be some function of its size. This need not be so. With proper use of abstraction it is possible to have complexity that is constant regardless of program size. ALA makes use of this.</p>
</div>
<div class="paragraph">
<p><a id="ComplexityGraph1"></a></p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/complexity_curve.png" alt="complexity curve">
</div>
</div>
<div class="paragraph">
<p>This is a qualitative graph comparing the complexity of an ALA application with that of a big ball of mud and an average loosely coupled application. This is further explained later <a href="#ComplexityGraph2">here</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="truemaintainability"><a class="anchor" href="#truemaintainability"></a>1.3.3. Maintainability</h4>
<div class="paragraph">
<p>The maintainability effort over time should qualitatively follow the green curve in the graph below because as software artefacts are written, their reuse should reduce the effort required for other user stories. Product owners seem to have an innate sense that we manage to organise our code such that this happens. That is why they get so frustrated when things seem to take longer and longer over time, and they often ask us "haven&#8217;t we done this before". In practice, too often we follow the red curve. Maintenance eventually gets so difficult that we want to throw it away and start again. We reason we can do better. My experience is that we don&#8217;t do better when we rewrite. We just create another mess. It is just a psychological bias on the part of the developer caused by a combination of a) the Dunning Kruger effect and b) the fact that it is easier to read our own recently written code than someone else&#8217;s.</p>
</div>
<div class="paragraph">
<p>If we apply all the well known styles and principles, the best we seem to be typically manage is the orange curve, which comes from the COCOMO models, and which still has maintenance effort continuously increasing.</p>
</div>
<div class="paragraph">
<p>When we did an experimental re-write of a legacy application using ALA, and measured its maintainability attribute, it comes out as improving over time by several different measures.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/effort_curve.png" alt="effort curve">
</div>
</div>
<div class="paragraph">
<p>ALA is based on the theoretical architectural constraints needed to follow the green curve.</p>
</div>
</div>
<div class="sect3">
<h4 id="truetestability"><a class="anchor" href="#truetestability"></a>1.3.4. Testability</h4>
<div class="paragraph">
<p>In ALA all code is testable. ALA makes it clear when to mock and when to test with dependencies in place. All dependencies are left in place, because all dependencies are design-time or knowledge dependencies.</p>
</div>
<div class="paragraph">
<p>Therefore, when testing the application layer abstractions, they are tested with their domain abstraction dependencies. In other words, testing the application is acceptance testing.</p>
</div>
<div class="paragraph">
<p>Testing domain abstractions is easy with units tests because abstractions are zero-coupled. Mocks objects are wired to ports.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="truestructure-hidden-inside-the-modules"><a class="anchor" href="#truestructure-hidden-inside-the-modules"></a>1.4. Structure hidden inside the modules</h3>
<div class="paragraph">
<p>The problem in most large code bases is that the system structure, the in-the-large structure, is not explicit. It is distributed inside the modules themselves. If there is any collaboration between modules, it is implicitly hidden inside them. Finding this structure, even for a single user story can be time consuming. I have often spent a whole day doing that, doing countless all-files searches following function calls or method calls of the user story through many modules just to end up changing one line of code. Many developers I have spoken to can identify with this experience.</p>
</div>
<div class="paragraph">
<p>It can get a lot worse as the system gets larger. In a seemingly bizarre twist, the more loosely coupled you make the elements, the harder it gets to trace a user story because of the indirections. Some people conclude that loose coupling and being able to trace through a user-story are naturally in conflict.</p>
</div>
<div class="paragraph">
<p>I call this situation SMITA (Structure Missing in the Action). The internal structure is sometimes drawn as a model - high-level documentation of the hidden structure. But such models are a secondary source of truth.</p>
</div>
<div class="paragraph">
<p>ALA completely eliminates this problem and this conflict. The structure is explicitly coded in one place, without any indirections. Yet the abstractions are zero-coupled.</p>
</div>
</div>
<div class="sect2">
<h3 id="truethe-software-engineers-trap"><a class="anchor" href="#truethe-software-engineers-trap"></a>1.5. The software engineer&#8217;s trap</h3>
<div class="paragraph">
<p>Typical bright young engineers come out of university knowing C++ or Java (or other C*, low-level, imperative, language that mimics the silicon), and are confident that, because the language is Turing-complete, if they string together enough statements, they can accomplish anything. At first they can. There hardly seems a need for a software architect to be involved. And besides, we are told that a design can emerge through incremental refactoring.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/Cynefin.jpg" alt="Cynefin.jpg" width="800">
</div>
<div class="title">Figure 6. Code can quickly get complex</div>
</div>
<div class="paragraph">
<p>As the program gets larger, things get a little more complicated, but the young developer&#8217;s brain is still up to the task, not realizing he has already surpassed anyone else&#8217;s ability to read his code. He is still able to get more features working. One day parts of the 'transition'. It becomes somewhere you don&#8217;t want to go. On the Cynfin diagram, it has transitioned from the complicated quadrant to the complex quadrant. And now it is trapped there. It is too complex for refactoring.</p>
</div>
<div class="paragraph">
<p>The incremental effort to maintain starts to eat away and eventually exceed the incremental increase in value. This now negative return causes the codebase itself to eventually lose value, until it is no longer an asset to the business.</p>
</div>
<div class="paragraph">
<p>It has transitioned to chaos. It will be abandoned. When a new bright young engineer who knows C* arrives, he looks at the legacy codebase and is convinced that he can do better. And the cycle repeats. This is the CRAP cycle (Create, Repair, Abandon, rePlace). ALA is the only method I know that can prevent the CRAP cycle.</p>
</div>
</div>
<div class="sect2">
<h3 id="truea-short-history-of-ala"><a class="anchor" href="#truea-short-history-of-ala"></a>1.6. A short history of ALA</h3>
<div class="paragraph">
<p>From early on in my career, I experienced the CRAP cycle, not so much rewriting applications, but trying to avoid the mess when writng new ones. Each time I wanted to find a way to not fall into it. I would research and use all the architectural styles and principles I could find. I would come across things like 'loose coupling', and I remember asking myself, yes but how does one accomplish that?, and still fail.</p>
</div>
<div class="paragraph">
<p>I started searching for a pre-worked, generally applicable, 'template architecture' that would tell me what the organisation of the code should look like for any program. I searched for such a thing many times and never found one. Some would say that this is because the highest level structure depends on project specific requirements.</p>
</div>
<div class="paragraph">
<p>Forty years worth of mistakes later, I finally have that template meta structure that all programs should have. The turning point was when I noticed two (accidental) successes in parts of two projects. These successes were only noticed years later, 15 years in one case and 5 years in the other. They had each undergone considerable maintenance during that time. But their simplicity had never degraded and their maintenance had always been straightforward. It was like being at a rubbish dump and noticing two pieces of metal that had never rusted. "That&#8217;s weird", you think to yourself. "What is going on here?"</p>
</div>
<div class="paragraph">
<p>One of them had the same functionality as another piece of software that I had written years earlier. That software was the worst I had ever written. It was truly a big ball of mud, and maintenance had become completely impossible, causing the whole product to be abandoned. So it wasn&#8217;t what the software did that made the difference between good and bad. It was how it was done.</p>
</div>
<div class="paragraph">
<p>Analysing the common properties of those two code bases, gave clues that eventually resulted in a theoretical understanding of how to deal with complex systems. This meta-structure is what I now call Abstraction Layered Architecture.</p>
</div>
<div class="paragraph">
<p>Subsequently, I ran some experiments to see if the maintainability and non-complexity could be predictably reproduced. These experiments, which have worked spectacularly well so far, are discussed as a project at the end of every chapter.</p>
</div>
</div>
<div class="sect2">
<h3 id="trueexample-project-thermometer"><a class="anchor" href="#trueexample-project-thermometer"></a>1.7. Example project - Thermometer</h3>
<div class="paragraph">
<p>In this example project, we will first do conventional code using functions, then refactor it into abstraction layers, and finally improve on that using classes. The ALA layering rules work the same for both functions or classes.</p>
</div>
<div class="paragraph">
<p>Functions have an execution model we are already familiar with, making this first example easier to understand. However, keep in mind that, for whole programs, this execution model does not usually make a good programming paradigm. An emergent property of ALA its support of multiple and diverse poogramming paradigms including your own. We do this to improve expressiveness of the requirements.</p>
</div>
<div class="paragraph">
<p>Nevertheless, functional composition is a passable programming paradigm for a tiny, dedicated embedded program in a micro-controller such as our thermometer. Let&#8217;s have a look at some typical code:</p>
</div>
<div class="sect3">
<h4 id="truebad-code"><a class="anchor" href="#truebad-code"></a>1.7.1. Bad code</h4>
<div class="listingblock">
<div class="title">configurations.h</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C" class="language-C hljs"> #define BATCHSIZE 100</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">main.c</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C" class="language-C hljs"> #include "configurations.h"
 void main()
 {
    int temperatures[BATCHSIZE];
    ConfigureTemperaturesAdc();
    while (1)
    {
        GetTemperaturesFromAdc(temperatures); // gets a batch of readings at a time
        ProcessTemperatures(tempertures)
    }
 }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">process.c</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C" class="language-C hljs"> void ProcessTemperatures(int adcs[])
 {
    float temperature;
    for (i = 0; i&lt;BATCHSIZE; i++) {
        temperature = (adcs[i] + 4) * 8.3; // convert adc to celcius
        temperature = SmoothTemperature(temperature);
        ResampleTemperature(temperature);
    }
 }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Resample.c</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C" class="language-C hljs"> void ResampleTemperature(float temperature)
 {
    static int counter = 0;
    counter++;
    if (counter==15)
    {
        DisplayTemperature(temperature);
        counter = 0;
    }
 }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">smooth.c</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C" class="language-C hljs"> // smooth the reading before displaying
 float SmoothTemperature(float temperature)
 {
    static filtered = 0;
    filtered = filtered*9/10 + temperature/10;
    return filtered;
 }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">adc.c</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C" class="language-C hljs"> #include "configurations.h"
 void ConfigureTemperaturesAdc()
 {
    // configure ADC channel 2 to do DMA BATCHSIZE values at a time
 }
 float GetTemperaturesFromAdc(int temperatures[])
 {
    for (i = 0; i&lt;BATCHSIZE; i++) {
        temperature[i] = ReadAdcChannel(2);  // pseudocode here for the adc read
    }
 }</code></pre>
</div>
</div>
<div class="paragraph">
<p>At first this code wont look that bad, but that&#8217;s only because the whole program is so small. You have to read it all to understand any part of it, but that&#8217;s possible for small programs. Of course that strategy won&#8217;t scale up.</p>
</div>
<div class="paragraph">
<p>As we are taught to do, different responsibilities of the thermometer implementation have been separated out into smaller pieces with smaller responsibilities, although ProcessTemperatures appears to have three responsibilities. The problem is that all the pieces are in some way collaborating to make a thermometer. They are all coupled in some way, either explicitly or implicitly. That&#8217;s why we have to read all the code to understand the thermometer. Scale this up to 5000 lines of code, and we will have a big mess.</p>
</div>
<div class="paragraph">
<p>We are going to refactor the program using the ALA strategy:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>every piece of knowledge about 'being a thermometer' will be in one function</p>
</li>
<li>
<p>that 'Thermometer' function will be at the top</p>
</li>
<li>
<p>that function will do nothing else itself</p>
</li>
<li>
<p>how to do things will be put into other functions</p>
</li>
<li>
<p>those functions will not know anything about thermometer</p>
</li>
<li>
<p>those functions will, therefore, be more abstract than a thermometer</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="truetoward-ala-code"><a class="anchor" href="#truetoward-ala-code"></a>1.7.2. Toward ALA code</h4>
<div class="listingblock">
<div class="title">application.c</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C" class="language-C hljs"> #define BATCHSIZE 100
 void main()
 {
    int adcs[DMABATCHSIZE];
    float temperatureCelcius;
    float smoothedTemperatureCelcius;
    while (1)
    {
        GetAdcReadings(adcs, 2, DMABATCHSIZE);  // channel=2
        for (i = 0; i&lt;BATCHSIZE; i++) {
            temperatureInCelcius = OffsetAndScale(adc, offset=4, slope=8.3);
            smoothedTemperatureCelcius = Filter(temperatureCelcius, 10);
            if (SampleEvery(15))
            {
                Display(FloatToString(smoothedTemperatureCelcius, "#.#"));
            );
        }
    }
 }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">offsetandscale.c - (domain abstraction)</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C" class="language-C hljs"> // offset and scale a value
 void OffsetAndScale(float data, float offset, float scale)
 {
    return (data + offset) * scale;
 }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">filter.c - (domain abstraction)</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C" class="language-C hljs"> // IIR 1st order filter, higher filterstrength is lower cutoff frequency
 float Filter(float input, int strength)
 {
    static float filtered = 0.0;
    filtered = (filtered * (strength-1) + input) / strength
    return filtered;
 }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">resample.c - (domain abstraction)</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C" class="language-C hljs"> // Returns true every n times it is called
 bool SampleEvery(int n)
 {
    static counter = 0;
    counter++;
    if (counter&gt;=n)
    {
       counter = 0;
       rv = true;
    }
    else
    {
       rv =  false;
    }
    return rv;
 }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The code now begins to be arranged into two abstraction layers, the application layer and the domain abstractions layer. The application is now the only function that knows about being a thermometer. (It is still doing some logic work - the 'for loop' and 'if statement', which we we will address soon.)</p>
</div>
<div class="paragraph">
<p>All the other functions are now more abstract - they know nothing about thermometers - GetAdcReadings, OffsetAndScale, SampleEvery, Filter, FloatToString, and Display. Notice that the word 'thermometer' has been removed from their names, and none of them contain constants or any other references that are to do with a thermometer or temperature.</p>
</div>
<div class="paragraph">
<p>These abstract functions give you six things:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Abstract functions are way easier to learn and remember what they do</p>
</li>
<li>
<p>Abstract functions give <strong>design-time</strong> encapsulation i.e. zero coupling.</p>
</li>
<li>
<p>Abstract functions can be understood by themselves</p>
</li>
<li>
<p>Abstract function interfaces are way more stable - as stable as the concept of the abstraction itself</p>
</li>
<li>
<p>Abstract functions are reusable</p>
</li>
<li>
<p>As a consequence of 1., the application function can also now be understood by itself</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Now let&#8217;s go one more step and create an abstraction to do what that for loop does: This may seem like a retrograde step, but we need to understand this mechanism to move to our final goal of expressing the requirements through pure composition of abstractions. We want to move the 'for loop' out into its own abstraction, but we don&#8217;t want to move the code that&#8217;s inside it. We accomplish this by putting the code inside it into another function and passing that function to the for loop function:</p>
</div>
</div>
<div class="sect3">
<h4 id="truefurther-toward-ala-code"><a class="anchor" href="#truefurther-toward-ala-code"></a>1.7.3. Further toward ALA code</h4>
<div class="listingblock">
<div class="title">application.c</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C" class="language-C hljs"> #define DMABATCHSIZE 100
 void main()
 {
    int adcs[DMABATCHSIZE];
    float temperatureCelcius;
    float smoothedTemperatureCelcius;
    ConfigureAdc(2, DMABATCHSIZE)
    while (1)
    {
        GetAdcReadings(adcs, 2, DMABATCHSIZE);  // channel=2
        foreach(adcs, func1);
    }
 }
 void func1(float adc)
 {
    temperatureInCelcius = OffsetAndScale(adc, offset=4, slope=8.3);
    smoothedTemperatureCelcius = Filter(temperatureCelcius, 10);
    if (SampleEvery(15))
    {
        Display(FloatToString(smoothedTemperatureCelcius, "#.#"));
    );
 }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">foreach.c</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C" class="language-C hljs"> void foreach(int values[], void (*f)(int))
 {
    for (i = 0; i&lt;sizeof(values)/sizeof(*values); i++) {
        (*f)(values[i]);
    }
 }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now let&#8217;s deal with that problematic "func1". "func1" is not an abstraction - you cannot give it a name and learn a simple concept of what it does. That&#8217;s why I gave it a non-descript name. The content of func1 is cohesively just part of the thermometer application. The name func1 only serves as a symbolic connection within cohesive code - nothing more than a wiring between two points in the program. In this case func1 is immediately below where it is used in the same small file, but as the program grows, these symbolic wirings are always hard to follow. You would need to resort to text searches to find these connections. These types of connections can be numerous and unstructured in larger programs, and the best way to deal with them is usually diagrams. However, this particular one can be dealt with in text form. So let&#8217;s go ahead and remove it by using an anonymous function directly as the second parameter of foreach:</p>
</div>
<div class="listingblock">
<div class="title">application.c</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C" class="language-C hljs"> #define DMABATCHSIZE 100
 void main()
 {
    int adcs[DMABATCHSIZE];
    float temperatureCelcius;
    float smoothedTemperatureCelcius;
    ConfigureAdc(2, DMABATCHSIZE)
    while (1)
    {
        GetAdcReadings(adcs, 2, DMABATCHSIZE);  // channel=2
        foreach(adcs, (adc)=&gt;{
            temperatureInCelcius = OffsetAndScale(adc, offset=4, slope=8.3);
            smoothedTemperatureCelcius = Filter(temperatureCelcius, 10);
            if (SampleEvery(15))
            {
                Display(FloatToString(smoothedTemperatureCelcius, "#.#"));
            );
        });
    }
 }</code></pre>
</div>
</div>
<div class="paragraph">
<p>It uses the lambda syntax '()&#8658;{}', which if you are not already familiar with, is worth getting used to. It really helps to get code into the right layers according to their abstraction level.</p>
</div>
<div class="paragraph">
<p>The next thing we want to do is get rid of the while loop, get rid of the indenting, and stop handling the data that is being passed from one function to another. None of them have anything to do with a thermometer. All those intermediate holding variables, adcs, temperatureCelcius, etc are all just symbolic connections. They are too much work when we just want to compose our thermometer from abstractions.</p>
</div>
<div class="paragraph">
<p>The while loop and all the indenting are there only because we have 'execution flow' tied in with our composition of abstractions.</p>
</div>
<div class="paragraph">
<p>To do this we will first show how its done using monads. Don&#8217;t worry if you don&#8217;t understand monads, we don&#8217;t really need this step to understand our final goal. But for those who do know monads, it is interesting to visit this step to see why the functional programming guys invented them. In the next step we will use ordinary classes, which will be more versatile than monads.</p>
</div>
</div>
<div class="sect3">
<h4 id="truebrief-detour-composing-with-monads"><a class="anchor" href="#truebrief-detour-composing-with-monads"></a>1.7.4. Brief detour: composing with monads</h4>
<div class="listingblock">
<div class="title">application.c</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C" class="language-C hljs"> void main()
 {
    program = new ADC(channel=2, batchSize=100)
    .foreach()
    .OffsetAndScale(offset=4, slope=8.3)
    .Filter(strength=10)
    .SampleEvery(15)
    .NumberToString(format="#.#")
    .Display();

    program.Run();
 }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Monads have allowed us to separate execution flow from composition flow. The composition flow is now a pure dataflow paradigm. Data will flow from the ADC to the display, so that is directly represented by the composition. How it executes is now separated out, and we will go into how that works shortly. Let&#8217;s first understand the 'composition' and why this is so important.</p>
</div>
<div class="paragraph">
<p>Even if you don&#8217;t understand how the monads work, you can see that syntactically the program is now very nice because all it does is compose instances of abstractions, and configure them with constants to be a thermometer. The composition is not declarative - it is <em>dataflow</em>, because dataflow suits how to describe the thermometer.</p>
</div>
<div class="paragraph">
<p>We are using the word 'composition' here to mean the things we are joining together in adjacent lines of code. It can also mean joining boxes with lines in a diagram. Think of a composition as analogous to the adjacent notes in a music score, which are always played successively. If the lines of code are statements or function calls, we are composing things for successive synchronous execution by the CPU. If the lines of code are data processors, we are composing things for successive processing of data and passing their output to the next data processor.</p>
</div>
<div class="paragraph">
<p>Here we are composing for successive processing of data, or dataflow composition. If we are stuck with thinking in terms of imperative execution flow (the only way of thinking in the C language) we will need to try hard to let that go, and realize that in ALA, 'composition' can be any programming paradigm you want.</p>
</div>
<div class="paragraph">
<p>Also notice that the first statement just builds the program. Then the second statement sets it running. This two stage aspect of monads is common in the programming paradigms we will use in ALA. It is because the underlying execution flow is not the same as the flow of the programming paradigm. We first wire it up, and then we tell it to 'execute'.</p>
</div>
<div class="paragraph">
<p>The while loop code version we had above handled the data itself. Each function returned the data which was stored in a local otherwise useless variable and then passed into the next function. The monad code doesn&#8217;t do that. Instead, it creates and wires together objects which will, at run-time, send the data directly from one to another. This does not mean that the abstractions themselves know anything about each other - they are still zero coupled.</p>
</div>
<div class="paragraph">
<p>Lastly, here&#8217;s how monads actually execute - the execution model. Don&#8217;t worry if this doesn&#8217;t make sense.</p>
</div>
<div class="paragraph">
<p>Each function in the program statement (the function after each dot) executes once when the program starts. They are not executed when the program is running. Each of these functions first instantiates an object (using new), and secondly wires that object to the previous object.</p>
</div>
<div class="paragraph">
<p>The functions wire the objects together using a common abstract interface. Common interfaces used for monads are like IEnumerable or IObservable. These interfaces support iteration of data, by returning an IEnmerator or IObserver. If using the IEnumerator interface, there is a simple method in the interface that pulls data from the previous object. If using the IObseravble interface, there is a simple method in the interface that pushes data to the next object. The execution can be done either way.</p>
</div>
</div>
<div class="sect3">
<h4 id="truecomposing-with-plain-objects"><a class="anchor" href="#truecomposing-with-plain-objects"></a>1.7.5. Composing with plain objects</h4>
<div class="paragraph">
<p>Here is the same program as above, but we are using plain objects instead of monads. We use the 'new' keyword ourselves to create the instances of abstractions, and explicitly wire them together using a wiring function. It&#8217;s a little less succinct than the monad version, but easier to understand, and more versatile when we want multiple ports and different programming paradigms.</p>
</div>
<div class="listingblock">
<div class="title">application.c</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C" class="language-C hljs"> void main()
 {
    program = new ADC(channel=2,batchSize=100)
        .WireIn(new Foreach())
        .wireIn(new OffsetAndScale(offset=4, slope=8.3))
        .wireIn(new Filter(strength=10))
        .wireIn(new SampleEvery(15))
        .WireIn(new NumberToString(format="#.#")
        .wireIn(new Display());

    program.Run();
 }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The wireIn method is doing dependency injection.</p>
</div>
<div class="paragraph">
<p>The WireIn method returns the new object, so it is possible to string WireIns together. This is called fluent syntax.</p>
</div>
</div>
<div class="sect3">
<h4 id="trueusing-multiple-programming-paradigms"><a class="anchor" href="#trueusing-multiple-programming-paradigms"></a>1.7.6. Using multiple programming paradigms:</h4>
<div class="paragraph">
<p>Monads are not versatile enough to handle arbitrary wirings of multiple programming paradigms, which we will want in ALA programs. They usually only give us dataflow. But what if we want to compose the UI? What if we want to compose the flow of navigation around an application? What if we want to compose transitions in a state machine? In ALA, we are able to do all this in the one application, in the same way - using whatever programming paradigms are the best way to express the requirements.</p>
</div>
<div class="paragraph">
<p>Some instances of abstractions will need to take part in multiple paradigms, such as both UI and dataflow. When we boil down the description of our application to pure composition, our composition will often be a network of relationships. And when you have a network, your composition is best described by a diagram.</p>
</div>
<div class="paragraph">
<p>To illustrate this let&#8217;s add some UI to our thermometer:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/ThermometerDiagram.png" alt="ThermometerDiagram.png" width="500">
</div>
<div class="title">Figure 7. Thermometer application complete with UI</div>
</div>
<div class="paragraph">
<p>The diagram has both UI composition and dataflow composition. Once we have this diagram, it is easy to conceive how we might add features. For example, we could add a button into the UI, and wire it to a switcher abstraction that changes between Celcius and Faranheit.</p>
</div>
<div class="paragraph">
<p>For the UI part of the composition, the lines obviously don&#8217;t mean dataflow - they mean 'display inside'. So now different lines in our diagram have different meanings. Here is how that diagram is represented as text.</p>
</div>
<div class="listingblock">
<div class="title">application.c</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C" class="language-C hljs"> void main()
 {
    FloatField temperature;

    program = new ADC(channel=2)
        .WireIn(new Foreach())
        .wireIn(new OffsetAndScale(offset=4, slope=8.3))
        .wireIn(new Filter(10))
        .wireIn(new SampleEvery(100))
        .WireIn(new NumberToString()
        .wireIn(temperature = new FloatField());

    mainwindow = new Window()
       .wireTo(new Label("Temperture:"))
       .WireTo(temperature);

    mainwindow.Run();
 }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The text of the ALA thermometer has a symbolic connection for one of the wirings, "temperature". This is ok in this small program, but doing that won&#8217;t scale up. That is why we consider the diagram to be the source, and this text version is generated from it.</p>
</div>
<div class="paragraph">
<p>Looking once again at the diagram, you can see that ALA has allowed us to keep all cohesive knowledge about a thermometer together, and quite succinctly. It contains all the details needed to describe a thermometer, but does so in terms of domain abstractions that are not specific to a thermometer at all. There is no implementation in the application code. All implementation is done by domain abstractions. If you can see that point in the example code, then you are pretty much understanding ALA.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="truechapter-two-the-structure"><a class="anchor" href="#truechapter-two-the-structure"></a>2. Chapter two - The structure</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In this section we describe the structure of ALA without trying to explain too much about why it looks that way. An analogy is if we described the physical anatomy of the human body without explaining how it works. How ALA works will be covered in chapter three, and why it works in chapter six.</p>
</div>
<div class="paragraph">
<p>The organisation of this chapter is to describe the structure from a few different perspectives. We all have different prior knowledge on which we build new knowledge. So we will each have a different way to understand what ALA is.</p>
</div>
<div class="sect2">
<h3 id="truesoftware-elements-relations-among-them"><a class="anchor" href="#truesoftware-elements-relations-among-them"></a>2.1. Software elements, relations among them</h3>
<div class="paragraph">
<p>Some definitions of software architecture see it in terms of software elements and the relations among them. Indeed the first two fundamental constraints of ALA define what elements are and what their relations are.</p>
</div>
<div class="paragraph">
<p>In this first perspective of ALA, we look at these two fundamental constraints in terms of code that lets us see how everything works right down to the C# executable level. We show all the code in all the layers so there are no gaps.</p>
</div>
<div class="sect3">
<h4 id="truethe-only-unit-of-code-is-an-abstraction"><a class="anchor" href="#truethe-only-unit-of-code-is-an-abstraction"></a>2.1.1. The only unit of code is an abstraction</h4>
<div class="paragraph">
<p>The only unit of code in ALA is an abstraction. Not module, not class, not function. An abstraction is more than a module, class or function in that it must be a 'generalized conceptual idea'. It must be learnable as a concept. Many modules, classes or functions in traditional code will not be good abstractions, especially if they have dependencies on peer modules, classes or functions.</p>
</div>
<div class="paragraph">
<p>Abstraction goes hand in hand with reuse. Krueger said that abstraction and reuse are two sides of the same coin. Abstractions tend to be stable, as stable as their conceptual idea. When we have a dependency on an abstraction, it is a dependency on a conceptual idea.</p>
</div>
<div class="paragraph">
<p>Here is an example abstraction which smooths data arriving on its input and outputs it at a slower rate.</p>
</div>
<div class="listingblock">
<div class="title">DomainAbstractions\LowPassFilter.cs</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">using ProgrammingParadigms;

namespace DomainAbstractions
{
    /// &lt;summary&gt; <i class="conum" data-value="6"></i><b>(6)</b>
    /// ALA Domain abstraction.
    /// Has one DataFlow input port and one DataFlow output port, both type double.
    /// Smooths the incoming data and outputs it at a lower frequency.
    /// The strength parameter sets the degree of filtering
    /// (cutoff frequency relative to input frequency).
    /// and also sets the lower rate of output.
    /// e.g. if Strength is set to 10, then there is one output for every 10 input
    /// datas received.
    /// You need to understand the programming paradigm, IDataFlow,
    /// to understand this code.
    /// &lt;/summary&gt;
    class LowPassFilter : IDataFlow&lt;double&gt; // input port <i class="conum" data-value="1"></i><b>(1)</b>
    {
        public LowPassFilter(int strength, double initialOutput = 0.0) <i class="conum" data-value="3"></i><b>(3)</b>
        {
            this.strength = strength;
            this.lastOutput = initialState;
        }

        private IDataFlow&lt;double&gt; output;  // output port <i class="conum" data-value="2"></i><b>(2)</b>

        private int strength;
        private double lastOutput = 0.0; <i class="conum" data-value="4"></i><b>(4)</b>
        private int resampleCounter = 0; <i class="conum" data-value="4"></i><b>(4)</b>

        void IDataFlow&lt;double&gt;.Push(double data) <i class="conum" data-value="5"></i><b>(5)</b>
        {
            lastOutput = (data + strength * lastOutput) / (strength+1);
            if (resampleCounter==0)
            {
                resampleCounter += strength;
                output?.Push(lastOutput);
            }
            resampleCounter--;
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The abstraction smooths an incoming data stream, and slow its down.</p>
</div>
<div class="paragraph">
<p>The abstraction has two ports:</p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Input port, the implemented interface</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>output port, simple private field of type interface
<div class="paragraph">
<p>The input port is the IDataFlow&lt;double&gt; interface that is implemented by the class. Dataflow is a programming paradigm which is a stream of data without end. Incoming data arrives via the Push method in this interface. We never know where the data comes from. The output port is the private field named "output". This field will be set pointing at an IDataFlow&lt;double&gt; input of an instance of another abstraction somewhere. We never know where the data goes to. How the <em>output</em> field gets set is described later.</p>
</div>
<div class="paragraph">
<p>Because the abstraction uses ports, it has no knowledge of other peer abstractions. If it did, it would not be an abstraction. It is self-understandable at design-time, except for the even more abstract concepts on which it depends. In this case that is DataFlow and the concept of Wiring, which will wire instances of this abstraction to instances of other abstractions with compatible ports. These are described more fully shortly.</p>
</div></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The public interface is only used by the layer above. It is only for creating and configuring instances of the abstraction. The abstraction has two configurations parameters. One is optional. Optional configurations can also be implemented with setters.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The abstraction keeps some internal state. This goes somewhat contrary to functional programming where we want all state to be passed in. In ALA a good abstraction trumps being stateless. As an abstraction that is naturally stateful, a filter should hide its state internally.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>The implementation of the input interface does the work of the filter. Note that port interfaces are always implemented explicitly. (If implemented implicitly, they would be part of the public API of the class, which we don&#8217;t wan&#8217;t. We only want the port accessed via the interface.)
<div class="paragraph">
<p>Internally, abstractions are cohesive (which means sticking together) or highly interconnected code collaborating for a single purpose.</p>
</div>
<div class="paragraph">
<p>In ALA, abstractions are implemented as files. The name of the file is the name of the abstraction. The code that implements an abstraction needs no internal organisation. We do not care about dependencies or any inter-relationships inside an abstraction. In fact the more cohesive everything is the better, as long as it is small. It will often be implemented as a single class or function, but may consist of a small number of items such as classes, functions, interfaces, enums, delegates, etc, as long as the total is small.</p>
</div></td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>When an abstraction is created, it is critically important to add comments that make it learnable by explaining the concept it provides, its ports, its configurations and an example of its use. In Visual Studio, I copy these comments before the constructor because that allows them to pop up in the IDE when hovering on the constructor name where instances are created with a <em>new</em> keyword.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Abstractions are the only mechanism that provides design-time <em>information hiding</em>. When David Parnas coined the term <em>information hiding</em> he meant at <em>design-time</em>. Unfortunately there is a popular meme that <em>information hiding</em> means <em>encapsulation</em>. The same idea of design-time information hiding has other names such as Alistair Cockburn&#8217;s <em>protected variations</em>, and Robert Martin&#8217;s version of the OCP (open closed principle).</p>
</div>
<div class="paragraph">
<p>A module or class can encapsulate information at compile-time but does not necessarily hide information at design-time. In the case of our LowPassFilter, the fact that it is just a low pass filter means that its internals cannot be coupled or collaborating with other modules. It&#8217;s bounded by its conceptual idea. If it were a module instead, it might primarily perform the filter function for a specific application, but knowing which application it is part would cause it to take on ancilliary functions, such as  offset and scale to output the units needed by the application. Or it might grab its input knowing where it comes from, or it might send it&#8217;s output to two different places. It might connect to the applications setting menu for its settings. All these things can be encapsulated, but they are all causing design-time coupling.</p>
</div>
<div class="sect4">
<h5 id="truemeaning-of-abstraction"><a class="anchor" href="#truemeaning-of-abstraction"></a>Meaning of abstraction</h5>
<div class="paragraph">
<p>Unfortunately, there are now two distinct meanings for the meme 'higher level of abstraction' in common usage in software engineering. We need to take a moment to understand the difference. In ALA, abstraction means the original dictionary meaning:</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>Etymology: abstract literally means <em>draw away</em> [a common idea or concept from specific examples]</p>
</div>
<div class="paragraph">
<p>Miriam Webster: relating to or involving general ideas or qualities rather than specific people, objects or actions.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>The other meaning of 'higher level of abstraction' used in the software engineering community appears to be 'further away from the domain of the computer and closer to the problem domain'. For example, layers are often shown building up from the hardware. They can also build up from the database, or a physical communication medium, such as the layers of the OSI communications model. In this meaning, the application is considered the most abstract. For example, a 3-tier system or a communication stack uses this type of layering. The perception is that because we no longer have to deal with computer domain details such as data storage, communications protocols, hardware, etc, we must be more abstract. The problem with this is that the problem domain also deals with details. These details come from the real world and are described by detailed requirements. The modules that contain these details are no more abstract than those in the various domains of computing.</p>
</div>
<div class="paragraph">
<p>Conventional layering tends to use this second meaning of 'abstract'; layers are said to be more abstract as you go up. ALA layers use the original meaning of the word 'abstract' and layers get more abstract as you go down.</p>
</div>
<div class="paragraph">
<p>The layers are not the same either. To convert conventional layers to ALA, you generally just tip them on their side so that they are not layers but independent disconnected abstractions. Each of them knows about details of something but they no longer directly connect to each other in either direction. On their own they will do nothing. The layer above, whose job is to know the details of a specific application or system, composes instances of them by instantiating them, configuring them, and wiring them together. Conventional layers can be many. ALA layers are few.</p>
</div>
<div class="paragraph">
<p>A final note about abstractions versus the SRP (single responsibility principle). The SRP is not really the best way to think about abstractions. It is better to think about what details an abstraction implementation knows about. It can be a specific user story, a specific feature, a type of UI element, a type of database, a protocol, a hardware device, etc. It will contain all the cohesive knowledge about that thing. In doing so, it may have multiple responsibilities. For example an abstraction that knows about a protocol or a hardware device may have responsibility for both input and output. It may have responsibility for configuring the hardware device and getting data. A filter abstraction may both smooth the input data and resample the input, because resampling is cohesive with smoothing.</p>
</div>
<div class="paragraph">
<p>We will look further at what 'abstraction' means in chapter six.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="trueala-uses-only-one-relationship-type"><a class="anchor" href="#trueala-uses-only-one-relationship-type"></a>2.1.2. ALA uses only one relationship type</h4>
<div class="paragraph">
<p>This is the second of the three fundamental constraints. ALA uses a single type of relationship - a dependency on an abstraction that is more abstract than the one whose implementation uses it.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/diagram-05a.png" alt="diagram 05a">
</div>
</div>
<div class="paragraph">
<p>In terms of our previous example, LowPassFilter is Abstraction A and IDataFlow is Abstraction concept B.</p>
</div>
<div class="paragraph">
<p>Notice how in the diagram the relationship arrow comes from inside A. This is significant. It is the code that implements A that requires knowledge of abstraction concept B. We never actually draw lines when using abstractions, so you wont see this type of line in ALA diagrams. We only use it here while describing this one relationship that we are allowed to use.</p>
</div>
<div class="paragraph">
<p>B must be more abstract than A. "More abstract" means more general, not specific to A, and have a greater scope of reuse than A.</p>
</div>
<div class="paragraph">
<p>Because B is more abstract, it is more stable. ALA therefore automatically enforces the Stable Dependencies Principle.</p>
</div>
<div class="paragraph">
<p>The relationship means that, to read and understand the code inside A, you must know the abstraction concept B - not how the insides of abstraction B work. The word "abstraction" implies that it should be learnable in a short time and easy to retain. When we get an abstraction concept is sometimes described as a moment of insight.</p>
</div>
<div class="paragraph">
<p>Here are some more legal dependencies, this time from the application layer to the domain abstractions layer.</p>
</div>
<div class="listingblock">
<div class="title">Application\Thermometer.cs</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">    new AnalogInput(channel: 2)
    .WireIn(new LowPassFilter(strength: 10))
    .WireIn(new OffsetAndScale(offset: -31, scale: 0.2))
    .WireIn(new Display(label: "Temperature"));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Legal dependencies from a <em>Thermometer</em> user story abstraction on abstractions <em>AnalogInput</em>, <em>LowPassFilter</em>, <em>OffsetAndScale</em>, <em>Display</em> and <em>WireIn</em>. The user story takes input from an analog to digital converter, filters them to remove noise, scales them to be in degrees, and displays them.</p>
</div>
<div class="paragraph">
<p>This type of dependency has zero coupling. Because of the way our brains have evolved to understand a complex world in terms of abstractions, abstractions are the only mechanism that hide knowledge at design-time. The dependency has zero coupling between all codes using the abstraction and the code that implements the abstraction.</p>
</div>
<div class="paragraph">
<p>This type of dependency also tells us explicitly what other knowledge we need in order to <em>understand</em> code. For example, if abstraction A is <em>standard deviation</em> and abstraction B is <em>square root</em>, then to understand the code that implements standard deviation requires knowledge of the concept of square root. That&#8217;s why we sometimes refer to it as a knowledge dependency. Such a dependency always applies at design-time, as well as compile-time and run-time. Some knowledge dependencies may be implicit and so apply at design-time only. For example a dependency may be on a convention, or it may be simply the knowledge of ALA. You need knowledge of those things to fully understand the code. We want to be explicit and clear about knowledge dependencies for every bit of code inside every abstraction, so we endeavour to always state implicit dependencies in comments.</p>
</div>
<div class="paragraph">
<p>Architectures generally work by applying constraints that restrict the infinite variety of ways code could be organised. The ALA constraints seem severe at first, but after some practice they are exceedingly helpful in guiding the design. There is essentially one right way to organise the code. Sometimes the abstractions come easily and sometimes they require sustained inventive thought processes, especially in a new domain. In most domains, I usually start with the UI description in the requirements as they most readily reveal their abstractions. Then it becomes apparent that dataflows must be connected to these instances of UI abstraction elements. Data transformation and state abstractions will then become apparent next.</p>
</div>
<div class="sect4">
<h5 id="trueala-compared-with-the-uml-class-diagram"><a class="anchor" href="#trueala-compared-with-the-uml-class-diagram"></a>ALA compared with the UML class diagram</h5>
<div class="paragraph">
<p>All UML relationships except one are illegal in ALA, and that one is highly restricted to being a composition on a more abstract class. Such a relationship is always represented in code by just referring to the abstraction by name. You do not draw a line on a UML class diagram. For example, you would never use a library abstraction such as <em>regex</em> by drawing a line on a diagram to a box representing the regex class. You would just use the regex abstraction by name.</p>
</div>
<div class="paragraph">
<p>Furthermore, such a use of an abstraction by name is inside the class. It&#8217;s part of the class&#8217;s internal implementation. It makes no sense to show the relationship at the zoomed out scale outside the class with a filled diamond line coming from the border.</p>
</div>
<div class="paragraph">
<p>Class diagrams are evil. They have done more damage to software architecture than any other meme.</p>
</div>
<div class="paragraph">
<p>If a UML class diagram were drawn of an ALA application, there would be no lines at all, just boxes in space arranged in layers. This makes sense, because classes are used to implement abstractions, and abstractions have zero coupling with one another.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/ALAClassDiagram.drawio.png" alt="ALAClassDiagram.drawio.png" width="90%">
</div>
<div class="title">Figure 8. UML class diagrams for ALA have no relation lines.</div>
</div>
<div class="paragraph">
<p>The diagram is not useful. We will never use it again. That&#8217;s not to say we won&#8217;t use diagrams. Diagrams can be used in ALA to represent the internals of an abstraction. This is often done in the layer representing the application or a feature or user story. In ALA terms, it shows instances of (lower layer) abstractions wired together. In implementation terms it is a (static) UML object diagram.</p>
</div>
<div class="paragraph">
<p>Following are the UML relationships you cannot use, and what you do instead.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Associations</strong>: A conventional program will typically have many, many bad dependencies referred to as <em>associations</em> in UML. Most are there because data, messages, events, execution flow, etc, need to get from one place to another in the program. These are simply illegal in ALA. The whole difficult concept of dependency management vanishes. But where do these relationships go? How can the program still work? How is it possible for messages and events to travel around at run-time? The short answer is that all these associations become a line of code inside an abstraction in the layer above. Or they become a line on a diagram composing two <em>instances</em> of abstractions. Such lines are not relationships or dependencies - they are inside an abstraction, no different to a line of code that say calls one function and passes the result to another function. In ALA, you cannot use associations between classes. Instead you create objects in a higher level abstraction and then wire them together. The abstractions themselves will not know where their data comes from, nor where it goes.</p>
<div class="paragraph">
<p>Note that dependency injection or otherwise passing an object into another object doesn&#8217;t remove an association relationship between the classes. It only changes the relationship from composition to association, neither of which is allowed between peer classes. In other words, in ALA you are not allowed to know about the interface belonging to another class in the same layer, nor that of an abstract base class. Instead you use ports that use a much more abstract interface called a programming paradigm interface from a lower layer.</p>
</div>
</li>
<li>
<p><strong>Composition</strong>: Although the knowledge dependency relationship used in ALA can be implemented as a UML composition relationship (directed arrow with filled diamond), the ALA knowledge dependency is more constrained. It must be instantiating a class in a lower, more abstract, layer. This means that you cannot break a module up into pieces arbitrarily. Instead, you must invent abstractions. The composition relationship in ALA can go down by one or more layers, but never within a layer.</p>
</li>
<li>
<p><strong>Inheritance</strong>: ALA doesn&#8217;t need or use inheritance. It would break the abstraction of the (more abstract) base class in the lower layer. Instead we always use composition. Inheritance is often used to provides a 'calling up the layers at run-time' mechanism by its use of virtual functions. In ALA, we do this with ordinary observer pattern (events in C#), or by passing in a method as a configuration (usually anonymously or as a lambda expression), or with the strategy pattern.</p>
</li>
<li>
<p><strong>Packages</strong>: ALA does not use hierarchies or nesting. In other words, abstractions cannot be contained by other abstractions. Abstractions are never private. The reason they are never private is simple. An abstraction that is depended on should be more abstract than the abstraction using it. A more abstract abstraction needs to be public so it can be reused. ALA uses abstraction layers instead of encapsulation hierarchies. In ALA, packages would only be used as a distribution mechanism, not as part of the architecture for information hiding.</p>
<div class="paragraph">
<p>The word package means container. Packages are usually just a container of abstractions such as a library. We should not consider knowledge dependencies to be on the package because we can&#8217;t generally learn a package. We should consider knowledge dependencies to be on the individual abstractions inside the package.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s consider the situation where a conventional package is a good abstraction in itself. Because it was implemented as a package, it&#8217;s internal implementation is large (Facade pattern). Let&#8217;s say our conventional package hides a lot of complex implementation and contains  abstractions that we are not interested in using in the rest of our application. For example it could be a compiler that we can invoke from our application. The thing is, if the compiler abstraction is written using ALA, it will use lots of useful abstractions for the domain of compilers and parsing. We still want those abstractions to be public for reuse. It&#8217;s just that we don&#8217;t want them particularly visible to the rest of our application, which is in a different domain. To solve this problem we should still make the abstractions used by the compiler abstraction public, but put them into a different DomainAbstractions folder and namespace. When we do this, we will want the DomainAbstractions folders to be qualified with the name of the domain, such as CompilerDomainAbstractions.</p>
</div>
</li>
<li>
<p><strong>Namespaces</strong>: While not part of the UML, we can discuss namespaces here in case you think of them in some way similar to packeages. In ALA, namespaces are used for the layers. For example we use namespaces such as Application, DomainAbstractions and ProgrammingParadigms. This allows unrelated abstractions in different layers to have the same name. The files that implement abstractions are put inside folders that have the same names as the namespaces.</p>
<div class="paragraph">
<p>Note that unlike packages, namespaces are not encapsulations. Namespaces only make names unique. One 3rd party tool I used to generate dependency graphs showed dependencies on namespaces as if namespaces were abstractions. This gave a completely misleading view of the true nature of the dependencies in the code. I had to write a custom query for the tool to show the actual dependencies on the abstractions inside the namespaces.</p>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="trueabstraction-layers"><a class="anchor" href="#trueabstraction-layers"></a>2.1.3. Abstraction layers</h4>
<div class="paragraph">
<p>Because the target of a dependency must be more abstract, abstractions arrange themselves in discrete layers. This is what gives the architecture its name: Abstraction Layered Architecture.</p>
</div>
<div class="paragraph">
<p>Only a small number of layers are needed. Consider that we can construct the human body with just six layers: Atoms, Molecules, Proteins, Cells, Organs, Body. Probably need another two or three to build the human brain from neurons. Small applications generally use four. The layers are given standard names that describe their level of abstraction:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/Layers.png" alt="Layers.png" width="75%">
</div>
<div class="title">Figure 9. Abstraction layers</div>
</div>
<div class="paragraph">
<p>These layers are not fixed by ALA. But we tend to return to these ones in our experience so far. Following is discussion of each layer together with example code to see how everything works.</p>
</div>
<div class="sect4">
<h5 id="trueapplication-layer"><a class="anchor" href="#trueapplication-layer"></a>Application layer</h5>
<div class="paragraph">
<p>In describing example layers, we start with example code. This code will build into a complete running application so no holes are left in understanding the code level mechanics of how everything works. The accompanying bullet points then explain the high level theory of why the code is organised the way it is. The code is available here:
<a href="https://github.com/johnspray74/Thermometer">https://github.com/johnspray74/Thermometer</a></p>
</div>
<div class="listingblock">
<div class="title">Application\Thermometer.cs</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">using DomainAbstractions;
using ProgrammingParadigms;
using Foundation;

namespace Application
{
    class Thermometer
    {
        public static void Main()
        {
            Console.WriteLine("Wiring application");

            private ADCSimulator adc;

            adc = new ADCSimulator(channel: 2, period: 1000) { simulatedLevel = 400 }; <i class="conum" data-value="1"></i><b>(1)</b>
            adc.WireIn(new LowPassFilter(strength: 10)) <i class="conum" data-value="2"></i><b>(2)</b> <i class="conum" data-value="5"></i><b>(5)</b> <i class="conum" data-value="6"></i><b>(6)</b>
                .WireIn(new OffsetAndScale(offset: -200, scale: 0.2)) <i class="conum" data-value="3"></i><b>(3)</b>
                .WireIn(new DisplayNumeric&lt;double&gt;(label: "Temperature") { units = "C"} ); <i class="conum" data-value="4"></i><b>(4)</b>

            Console.WriteLine("Running application");
            adc.Run(); <i class="conum" data-value="7"></i><b>(7)</b>

            Console.WriteLine("press any key to stop");
            Console.ReadKey();
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To understand the code, you need to have knowledge of the abstraction concepts on which it depends. These are:</p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>ADCSimulator - domain abstraction simulates an analog to digital converter hardware peripheral. Has a single output port of type IDataFlow&lt;int&gt;</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>LowPassFilter - domain abstraction - we already met this at the beginning of this chapter</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>OffsetAndScale - domain abstraction - has a single input port and a single output port, both IDataFlow&lt;double&gt;. Adds a constant and Multiplies by another constant to transform data like a straight line on an x-y graph.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>DisplayNumeric - domain abstraction - has one input port of type IDataFlow&lt;double&gt;. Displays the value on the console with label and optional units.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>WireIn - foundation abstraction - wires compatible ports of instances of abstractions by setting the private field in the first object that matches the interface implemented by the second object.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>These wirings are using the Dataflow programming paradigm. Dataflow is used by the ports of the domain abstractions and allows their instances to push data from one to the next at runtime if they are wired together. For dataflow programming, we default to pushing data through the system (from ADC to display). We use pulling when there is good reason, usually for  performance.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>The adc, which is the source of the data that gets pushed through the system, needs to be told to start running.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Once you have knowledge of these abstractions, notice that the application code is readabable by itself. It holds all knowledge about thermometers.
That knowledge sits at the abstraction level of the requirements. It is highly cohesive - every line works with every other line to make a thermometer. It does none of the work itself - it just assembles and configures the needed worker objects.</p>
</div>
<div class="paragraph">
<p>The application layer is three things in one: The architecture design, the expression of requirements, and the executable. In conventional software development, these are three separate artefacts.</p>
</div>
<div class="paragraph">
<p>Execution typically occurs in two phases (similar to some monads). In the first phase the application wires together instances of abstractions. In the second phase the network of instances executes (which is what the finalizing call to Run starts).</p>
</div>
</div>
<div class="sect4">
<h5 id="truedomain-abstractions-layer"><a class="anchor" href="#truedomain-abstractions-layer"></a>Domain abstractions layer</h5>
<div class="paragraph">
<p>At the beginning of this chapter we had an example of a domain abstraction, LowPassFilter. Here is another example:</p>
</div>
<div class="listingblock">
<div class="title">DomainAbstractions\OffsetAndScale.cs</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">using ProgrammingParadigms;

namespace DomainAbstractions
{
    /// &lt;summary&gt; <i class="conum" data-value="1"></i><b>(1)</b>
    /// ALA domain abstraction
    /// Has one input port of type IDataflow and one output port of type IDataflow
    /// (both type double)
    /// Performs y = m(x+c) like operation where x is the input and y is the output
    /// If visualized as a straight line on an x,y graph, -c is the x axis intercept
    /// and m is the slope.
    /// You need to understand the programming paradigm abstraction, IDataFlow,
    /// to understand this code.
    /// &lt;/summary&gt;
    class OffsetAndScale : IDataFlow&lt;double&gt; // input <i class="conum" data-value="2"></i><b>(2)</b>
    {
        public OffsetAndScale(double offset, double scale) <i class="conum" data-value="4"></i><b>(4)</b>
        {
            this.offset = offset;
            this.scale = scale;
        }

        private double offset;
        private double scale;


        private IDataFlow&lt;double&gt; output; <i class="conum" data-value="3"></i><b>(3)</b>

        void IDataFlow&lt;double&gt;.Push(double data) <i class="conum" data-value="5"></i><b>(5)</b>
        {
            output.Push((data + offset) * scale);
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notes on the code:</p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Important to comment what the abstraction concept is.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The input port is the implemented interface.
<div class="paragraph">
<p>In the application code in the previous section, an instance of LowPassFilter was wired to an instance of OffsetAndScale. When wired, the <em>output</em> field of the LowPassFilter is set to the OffsetAndScale object, cast as the appropriate interface, in this case IDataFlow&lt;double&gt;.</p>
</div></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The output port <em>output</em> is private so that it does not appear as a configuration to the layer above. It is set by WireIn or WireTo using reflection.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>It has two compulsory configuration parameters.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>When data is pushed into the input, it is transformed and pushed out of the output port.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For completeness, here are the other two domain abstractions that we used in the Thermometer application example:</p>
</div>
<div class="listingblock">
<div class="title">DomainAbstractions\DisplayNumber.cs</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">using ProgrammingParadigms;

namespace DomainAbstractions
{
    /// &lt;summary&gt;
    /// ALA Domain Abstraction
    /// Ouptuts incoming data to the console with a preceding label and optional units.
    /// Has one input port of type IDataFlow which can take int, float, double
    /// The label must be passed in the constructor.
    /// The units property may be used to set the units.
    /// fixPoint Property sets the number of decimal places.
    /// You need to understand the programming paradigm abstraction, IDataFlow,
    /// to understand this code.
    /// &lt;/summary&gt;
    class DisplayNumeric&lt;T&gt; : IDataFlow&lt;T&gt;
    {
        public DisplayNumeric(string label)
        {
            this.label = label;
        }

        public int fixPoints { get; set; } = 0;

        private string label;
        public string units { get; set; }


        void IDataFlow&lt;T&gt;.Push(T data)
        {
            double d = (double)Convert.ChangeType(data, typeof(double));
            Console.WriteLine($"{label}: { d.ToString($"F{fixPoints}") } {units}");
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">DomainAbstractions\ADCSimulator.cs</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">using ProgrammingParadigms;

namespace DomainAbstractions
{
    /// &lt;summary&gt;
    /// ALA Domain Abstraction.
    /// Simulate a 10-bit ADC (analog to digital converter).
    /// Normally an ADC is a hardware peripheral, but here we just do a software
    /// simulation of one to use as a source of data for example applications.
    /// A real ADC driver would have properties for setting the channel and period.
    /// You would create one instance of this driver for each ADC channel.
    /// It would output raw data in adc counts.
    /// Since it is a 10 bit ADC, the adc counts are in the range 0-1023.
    /// We retain the channel although it is not used by the simulated version.
    /// The simulated version has two simulation properties, one to set the simulated
    /// ADC reading.
    /// and one to set the level of noise in the simulated readings.
    /// You need to understand the programming paradigm abstraction, IDataFlow,
    /// to understand this code.
    /// &lt;/summary&gt;
    class ADCSimulator
    {
        public ADCSimulator(int channel, int period = 100)
        {
            this.channel = channel;
            this.period = period;
        }

        private int channel;  // unused on simulated ADC
        private int period;   // milliseconds
        public int simulatedLevel { get; set; } = 512; // 0 to 1023
        public int simulatedNoise { get; set; } = 0; // 0 to 1023

        private IDataFlow&lt;int&gt; output;

        public void Run()
        {
            RunAsyncCatch();
        }

        public async Task RunAsyncCatch()
        {
            // because we are the outermost async method, if we let exceptions go,
            // they will be lost
            try
            {
                await RunAsync();
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.ToString());
            }
        }

        Random randomNumberGenerator = new Random();

        public async Task RunAsync()
        {
            while (true)
            {
                // add a bit of noise to the adc readings
                int data = simulatedLevel + randomNumberGenerator.Next(simulatedNoise)
                            - simulatedNoise/2;
                if (data &lt; 0) data = 0;
                if (data &gt; 1023) data = 1023;
                output.Push(data);
                // throw new Exception("exception test");
                await Task.Delay(period);
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As can be seen in the above examples, the domain abstractions layer contains concepts that can be composed into applications. These are typically building blocks for I/O, data transformations, and persistent state, but many other types of abstractions are possible.</p>
</div>
<div class="paragraph">
<p>Some of these types of things may also be found in general language libraries but domain abstractions are more specific to the types of applications we want to express using them. They are specific to a domain, making them more expressive, but less reusable than general purpose language abstractions. They are still reusable both within a single application and by other applications in the same domain.</p>
</div>
<div class="paragraph">
<p>Another difference between ALA domain abstractions and typical library abstractions is the use of ports. This supports building functionality by simply composing instances of abstractions. While the composing code controls who will communicate with whom, it does not actually handle the data at run-time. The data moves directly between instances via the wired ports.</p>
</div>
<div class="paragraph">
<p>A further difference between ALA domain abstractions and typical library abstractions is that when domain abstractions are composed, the meaning of composition can be a programming paradigm other than imperative. For example the application above uses a dataflow programming paradigm. Imperative is not usually a good programming paradigm for the expression of requirements, but it&#8217;s all your basic language gives you (unless you are using language integrated monads, which also give you dataflow programming).</p>
</div>
<div class="paragraph">
<p>The domain abstractions layer and programming paradigms layer together are like a DSL (Domain Specific Language). We can think of domain abstractions as composable domain language elements and the programming paradigms as providing the grammar.</p>
</div>
<div class="paragraph">
<p>It is an internal DSL because it uses the underlying language (<em>WireTo</em> method, and <em>new</em>). This allows you to easily fall back on the greater flexibility of the underlying language when you need to. For example, you can pass lambda expressions as configuration properties to a domain abstraction. Or, you can pass a whole object of a class that you write in the application layer (which is the strategy pattern).</p>
</div>
<div class="paragraph">
<p>Conventional libraries generally contain good abstractions. What makes them good abstractions is that their designers don&#8217;t know anything about the specific applications that will use them. Writing domain abstractions is best done in the same way. After the need for an abstraction is decided, pretend you don&#8217;t know anything about the application, and are writing something to be useful, reusable and learnable as a new concept. Then they should not just be specific parts of a specific application.</p>
</div>
<div class="paragraph">
<p>As we said, abstractions know nothing of each other at design-time, yet can still communicate directly with one another at run-time. It is the responsibility of the code in the layer above that composes them to know the meaning of the data. It knows the meaning of the data even though it does not handle the data. For example, our application above knows that data going from the ADC to the LowPassFilter is raw adc values representing temperature, and what the values mean. It knows that the data passing between the LowPassFilter and the OffsetAndScale is sufficiently smoothed and slowed down for a stable display. It knows that the data passing from the OffsetAndScale to the display is in degrees celsius. All these pieces of knowledge are cohesive in the design of the thermometer, and so belong together inside the Thermometer abstraction.</p>
</div>
</div>
<div class="sect4">
<h5 id="trueprogramming-paradigms-layer"><a class="anchor" href="#trueprogramming-paradigms-layer"></a>Programming paradigms layer</h5>
<div class="paragraph">
<p>For the Thermometer example application above, we wired four instances of domain abstractions. That wiring used a single programming paradigm, <em>Dataflow</em>. Here is the interface for the dataflow programming paradigm:</p>
</div>
<div class="listingblock">
<div class="title">IDataFlow.cs</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">namespace ProgrammingParadigms
{
    interface IDataFlow&lt;T&gt;
    {
        void Push(T data);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Programming paradigm interfaces are often this simple. Another example programming paradigm is <em>synchronous event driven</em>. The corresponding interface might be:</p>
</div>
<div class="listingblock">
<div class="title">IEvent.cs</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">namespace ProgrammingParadigms
{
    interface IEvent { void Execute(); }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here is the interface for another common programming paradigm, the UI layout. In this programming paradigm, a parent UI element is wired to its contained child elements.</p>
</div>
<div class="listingblock">
<div class="title">IUI.cs</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">namespace ProgrammingParadigms
{
    interface IUI { UIElement GetUIElement(); }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The interface returns the .NET WPF element of the child. This allows domain abstractions to construct the UI using underlying WPF elements. In effect, UI domain abstractions are wired together in a similar way to XAML. Both have descriptive, tree structured syntax, but ALA is using the underlying C# language whereas XAML is using XML.</p>
</div>
<div class="paragraph">
<p>You can conceive other programming paradigms to give different meanings to composition of domain abstractions in such a way as to allow the easiest representation of typical requirements. For example, for implementing game scoring, I used a programming paradigm called <em>ConsistsOf</em>. For tennis, I used it to express that a match consists of a sets, a set consists of a games, and a game consists of a points. See the example project at the end of chapter four which uses it to implement tennis and bowling. Being able to compose instances of domain abstractions together with meanings that you define in the programming paradigms layer is powerful.</p>
</div>
<div class="paragraph">
<p>ALA is polyglot in programming paradigms. An application typically mixes a small set of different paradigms. Each provides a different meaning when the application wires two instances of domain abstractions together. Examples might be Dataflow, UI Layout, Event driven, State machine transition, Data schema entity relationship. Some may have variations such as pushing or pulling, or synchronous and asynchronous.</p>
</div>
<div class="paragraph">
<p>Programming paradigms control the way the application actually executes. Execution models such as synchronous vs asynchronous, push vs pull, and fan-out and fan-in wiring are discussed in Chapter four.</p>
</div>
<div class="paragraph">
<p>Programming paradigms provide the rules for the way instances of domain abstractions can be composed by the application. They are the grammar of the DSL.</p>
</div>
<div class="paragraph">
<p>Programming paradigms provide the mechanism of direct communication between instances of domain abstractions. They do this without the abstractions themselves knowing anything about each other.</p>
</div>
<div class="paragraph">
<p>Through the use of programming paradigms, domain abstractions know nothing about each other at design-time, yet instances of them can communicate at run-time. Of course we could achieve this by making the application handle the run-time communications. The common example would be an application that calls one function which returns a result, and then calls another function passing the result to it. This would almost comply with ALA. The problem is we don&#8217;t really want the application to be concerned with run-time communications. The application really just wants to concentrate on representing user stories by composing instances of domain abstractions. So we use a layer below the domain abstractions called programming paradigms. The programming paradigms allow domain abstractions to have compatible ports, which in turn allows them to communicate directly with one another at run-time. The design of the communications is in the Application layer, but the execution is in the domain abstractions and programming paradigms layers.</p>
</div>
</div>
<div class="sect4">
<h5 id="truefoundation-layer"><a class="anchor" href="#truefoundation-layer"></a>Foundation layer</h5>
<div class="paragraph">
<p>The foundation layer contains code used to support ALA programs in general.</p>
</div>
<div class="paragraph">
<p>A common pattern I use is a WireIn() and WireTo() extension methods in the foundation layer. The application layer uses them to wire together instances of Domain Abstractions using ports.</p>
</div>
<div class="paragraph">
<p>WireIn() and WireTo() are dependency injection methods.</p>
</div>
<div class="paragraph">
<p>WireTo(), uses reflection. It&#8217;s not essential to use reflection for ALA. You could use dependency injection setters in every domain abstraction instead. You would need one setter per port on the left abstraction. You wouldn&#8217;t use constructor dependency injection because sometimes wiring a port is optional. I prefer using the WireTo extension method because it allows domain abstractions to not need all these setters.</p>
</div>
<div class="paragraph">
<p>Here is minimal code for the WireTo method.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Wiring.cs</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">namespace Foundation
{
    public static class Wiring
    {
        /// WireTo is an extension method on the type object.
        /// Wires instances of classes that have ports by matching interfaces.
        /// Port name can be optionally provided for the A side.
        /// If object A has a private field of type interface,
        /// and object B implements that interface,
        /// and the private field is not yet assigned,
        /// assigns B to the field in A.
        /// Uses reflection.
        /// Returns the left object for fluent style programming.
        public static T WireTo&lt;T&gt;(this T A, object B, string APortName = null)
        {
            // achieve the following via reflection
            // A.field = B;
            // if 1) field is private
            //    2) field type matches one of the implemented interfaces of B
            //    3) field is not yet assigned

            if (A == null) throw new ArgumentException("A is null "); <i class="conum" data-value="4"></i><b>(4)</b>
            if (B == null) throw new ArgumentException("B is null ");

            bool wired = false;
            var BType = B.GetType(); <i class="conum" data-value="1"></i><b>(1)</b>
            var AfieldInfos = A.GetType().GetFields(System.Reflection.BindingFlags.NonPublic
                | System.Reflection.BindingFlags.Instance)
                .Where(f =&gt; (APortName == null || f.Name == APortName)) // match portname if any
                .Where(f =&gt; f.GetValue(A) == null) // not yet assigned
            var BinterfaceTypes = BType.GetInterfaces().ToList(); // ToList to do the reflection once

            foreach (var AfieldInfo in AfieldInfos) <i class="conum" data-value="2"></i><b>(2)</b>
            {
                var BimplementedInterface = BinterfaceTypes
                    .FirstOrDefault(interfaceType =&gt; AfieldInfo.FieldType == interfaceType);
                if (BimplementedInterface != null)  // there is a matching interface
                {
                    AfieldInfo.SetValue(A, B);  // do the wiring <i class="conum" data-value="3"></i><b>(3)</b>
                    wired = true;
                    break;
                }
            }

            if (!wired) // throw exception <i class="conum" data-value="4"></i><b>(4)</b>
            {
                var AinstanceName = A.GetType().GetProperties()
                    .FirstOrDefault(f =&gt; f.Name == "InstanceName")?.GetValue(A);
                var BinstanceName = B.GetType().GetProperties()
                    .FirstOrDefault(f =&gt; f.Name == "InstanceName")?.GetValue(B);

                if (APortName != null)
                {
                    // a specific port was specified - see if the port was already wired
                    var AfieldInfo = AfieldInfos.FirstOrDefault();
                    if (AfieldInfo?.GetValue(A) != null)
                        throw new Exception($"Port already wired  {A.GetType().Name}[{AinstanceName}].{APortName} to {BType.Name}[{BinstanceName}]"
                    );
                }
                throw new Exception($"Failed to wire {A.GetType().Name}[{AinstanceName}].\"{APortName}\" to {BType.Name}[{BinstanceName}]");
            }
            return A;
        }



        /// Same as WireTo, but returns the right object instead of the left object
        public static object WireIn&lt;T&gt;(this T A, object B, string APortName = null)
        {
            WireTo(A, B, APortName);
            return B;
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>It first gets an IEnumerable of all the private fields in class A. If a port name is passed in, it must match. Then it gets a list of all the interfaces of class B.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>It iterates through the fields to find one that matches any of the interfaces of B.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>It sets the field in A pointing to B, cast as the interface type.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>When there are errors in wiring code, it would be nice to get errors at compile-time. The WireTo extension method can&#8217;t do that, but it does throw exceptions at wiring time when the application first starts. Since in ALA all wiring is generally done at this time, at least you wont have potential exceptions later during normal run-time.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Four different exceptions may be thrown. 1) Object A (left object being wired) is null. 2) Object B (right object being wired) is null. 3) A specific A side port was specified, but it is already wired. 4) No matching A side port was found.</p>
</div>
<div class="paragraph">
<p>Once again, slightly more complete code is available here:
<a href="https://github.com/johnspray74/Thermometer">https://github.com/johnspray74/Thermometer</a></p>
</div>
</div>
<div class="sect4">
<h5 id="trueextra-layer-for-larger-applications"><a class="anchor" href="#trueextra-layer-for-larger-applications"></a>Extra layer for larger applications</h5>
<div class="paragraph">
<p>If a single abstraction is used for the application, then as more and more user stories are added into it, it will eventually get too large for the ALA size constraint. Meanwhile, domain abstractions and programming paradigms are stable and do not generally grow larger with overall program size. They may increase in number, but it is the application that will go over the 500 line complexity limit.</p>
</div>
<div class="paragraph">
<p>ALA will need to be applied to the large application abstraction by adding a new layer below it. The requirements are likely already written in terms of abstractions which we call <em>features</em> or <em>user stories</em> or <em>use cases</em>. We can use these abstractions as the basis for the new layer. We call the layer "Features" or "UserStories". The application abstraction becomes a composition of features or user stories.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s extend the Thermometer example code we used above to have a new feature for measuring load. At the same time, let&#8217;s introduce a features layer with the two features: temperature and loadcell.</p>
</div>
<div class="paragraph">
<p>I have deliberately retained a need for communication between the two features to show how features can also have ports and be wired together.</p>
</div>
<div class="sect5">
<h6 id="trueapplication-layer-2"><a class="anchor" href="#trueapplication-layer-2"></a>Application layer</h6>
<div class="listingblock">
<div class="title">Application\Application.cs</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">using Features;
using Foundation;

namespace Application
{
    class Application
    {
        /// &lt;summary&gt;
        /// Instantiate two features: a temperature readout and a loadcel readout.
        /// Also wire the Temperature to the Loadcell for temperature compensation
        /// &lt;/summary&gt;
        public static void Main()
        {
            Console.WriteLine("Wiring application features");

            var temperature = new Temperature(); <i class="conum" data-value="1"></i><b>(1)</b>
            var load = new LoadCell(); <i class="conum" data-value="1"></i><b>(1)</b>

            temperature.WireTo(load); // for temperature compensation <i class="conum" data-value="2"></i><b>(2)</b>

            Console.WriteLine("Running application");
            Console.WriteLine("press any key to stop");
            temperature.Run();
            load.Run();
            Console.ReadKey();
        }
    }

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The code instantiates two features for this particular application.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The code wires together the feature to get temperatures sent to Loadcell at run-time. Feature abstractions can have ports. A common example of wiring between features would be to wire a feature instance&#8217;s menu items to a <em>main menu</em> feature.</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="truefeatures-layer"><a class="anchor" href="#truefeatures-layer"></a>Features layer</h6>
<div class="paragraph">
<p>The Features layer contains independent features or user story abstractions.</p>
</div>
<div class="paragraph">
<p>Each feature creates instances of domain abstractions, configures the instances with feature specific details, and connects them together as needed to express the feature or user story.</p>
</div>
<div class="paragraph">
<p>Here is the Thermometer application rewritten to be a Temperature feature:</p>
</div>
<div class="listingblock">
<div class="title">Features\Temperature.cs</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">using DomainAbstractions;
using ProgrammingParadigms;
using Foundation;

namespace Features
{
    /// &lt;summary&gt;
    /// Feature to coninuously measure temperature and periodically display it
    /// in degrees C on the console.
    /// Has an output port that outputs the temperature.
    /// &lt;/summary&gt;
    class Temperature
    {
        private IDataFlow&lt;double&gt; output; // temperature in celcius <i class="conum" data-value="1"></i><b>(1)</b>

        private ADCSimulator adc;

        public Temperature()
        {
            const int adcLevel = 400;  // 40 C
            adc = new ADCSimulator(channel: 2, period: 1000) { simulatedLevel = adcLevel, simulatedNoise = 100 };
            adc.WireIn(new ChangeType&lt;int, double&gt;()) <i class="conum" data-value="2"></i><b>(2)</b>
                .WireIn(new LowPassFilter(strength: 10, initialState: adcLevel))
                .WireIn(new OffsetAndScale(offset: -200, scale: 0.2)) // 200 adc counts is 0 C, 300 adc counts is 20 C
                .WireIn(new DataFlowFanout&lt;double&gt;()) <i class="conum" data-value="3"></i><b>(3)</b>
                .WireTo(new DisplayNumeric&lt;double&gt;(label: "Temperature") { units = "C"} ) <i class="conum" data-value="5"></i><b>(5)</b>
                .WireTo(new DataFlowExternalPort&lt;double&gt;((d) =&gt; output?.Push(d))); <i class="conum" data-value="4"></i><b>(4)</b>
        }


        public void Run()
        {
            adc.Run();
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The feature has an output port for temperature
<div class="paragraph">
<p>The wiring itself is the same as it was in the Thermometer application except that three extra objects are used to make the dataflow wiring work. Their classes come from the Dataflow programming paradigm abstraction. These classes are:</p>
</div></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>ChangeType: allows Dataflow ports of one type to be wired to Dataflow ports of a different type. In this case, the output of ADCSimlator is <em>int</em> and the input of LowPassFilter is <em>double</em>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>DataFlowFanout: A normal output port can only be wired once. DataFlowFanout allows you to wire to multiple places. In this case we wanted to wire the output of OffsetAndScale to both a DisplayNumeric and an external port.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>DataFlowExternalPort. We want to wire the output of the DataFlowFanout to the external port <em>output</em>. You might think you could just write .WireTo(output). The reason this doesn&#8217;t work is that when the Temperature constructor runs, the code on the outside is instantiating a Temperature. That same external code would not have wired our <em>output</em> port yet. It&#8217;s value will be null at this time. Therefore we instead wire to a simple class that takes a function as its configuration. For the function we pass in a lambda expression that will push the data via the <em>output</em> port.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Note that WireTo is used to wire DataFlowFanout to multiple places. WireIn wires things in a chain.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Here is the other feature used by our example application, the Loadcell.</p>
</div>
<div class="listingblock">
<div class="title">Features\Loadcell.cs</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">using DomainAbstractions;
using ProgrammingParadigms;
using Foundation;

namespace Features
{
    /// &lt;summary&gt;
    /// Class:
    /// Feature to coninuously measure a load from a load cell and display it in kg on the console.
    /// Displays with one decimal place.
    /// Has temperature compensation for better accuracy (optionally feed temperature into the input port in degress C)
    /// &lt;/summary&gt;
    class LoadCell : IDataFlow&lt;double&gt; // input for temperature compensation <i class="conum" data-value="1"></i><b>(1)</b>
    {
        private ADCSimulator adc;
        private DataFlowInitializer&lt;double&gt; defaultTemperature;
        private OffsetAndScale offsetAndScaleTemperature;

        /// &lt;summary&gt;
        /// Constructor:
        /// Feature to coninuously measure a load from a load cell and display it in kg /// on the console.
        /// Displays with one decimal place.
        /// Has temperature compensation for better accuracy (optionally feed temperature
        /// into the input port in degress C)
        /// &lt;/summary&gt;
        public LoadCell()
        {
            // Wire an adc to an OffsetAndScale to an Add to a DislayNumeric.
            adc = new ADCSimulator(channel: 3, period: 500) { simulatedLevel = 200, simulatedNoise = 0 }; <i class="conum" data-value="2"></i><b>(2)</b>
            var add = new Add(); <i class="conum" data-value="4"></i><b>(4)</b>
            adc.WireIn(new ChangeType&lt;int, double&gt;())
                .WireIn(new OffsetAndScale(offset: 0, scale: 0.5)) <i class="conum" data-value="2"></i><b>(2)</b>
                //.WireIn(new DataFlowDebugOutput&lt;double&gt;((s)=&gt; System.Diagnostics.Debug.WriteLine(s))) <i class="conum" data-value="3"></i><b>(3)</b>
                // .WireIn(new DataFlowDebugOutput&lt;double&gt;(Console.WriteLine)) <i class="conum" data-value="3"></i><b>(3)</b>
                .WireIn(add)
                .WireTo(new DisplayNumeric&lt;double&gt;(label: "Load") { fixPoints = 1, units = "kg" } ); <i class="conum" data-value="2"></i><b>(2)</b>

            // Wire the inut port for temperature to another OffsetAndScale to the other input of the Add.
            defaultTemperature = new DataFlowInitializer&lt;double&gt;(); <i class="conum" data-value="6"></i><b>(6)</b>
            offsetAndScaleTemperature = new OffsetAndScale(offset: -20, scale: -0.1); // compensate -0.1 kg/C from 20 C <i class="conum" data-value="2"></i><b>(2)</b>
            defaultTemperature.WireIn(offsetAndScaleTemperature) <i class="conum" data-value="7"></i><b>(7)</b>
                .WireIn(new DataFlowConvert&lt;double, Double2&gt;((d)=&gt;new Double2(d))) <i class="conum" data-value="5"></i><b>(5)</b>
                .WireIn(add);

        }



        void IDataFlow&lt;double&gt;.Push(double data)
        {
            ((IDataFlow&lt;double&gt;)offsetAndScaleTemperature).Push(data); <i class="conum" data-value="7"></i><b>(7)</b>
        }


        public void Run()
        {
            defaultTemperature.Push(20);  // in case no temperture is connected to the input port, set it to 20 C
            adc.Run();
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This time the feature has an input port for temperature, which is the implemented interface.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Notice the reuse of several domain abstractions in this feature. The DisplayNumber abstraction is configured to display one decimal place.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Debugging a dataflow can be done by inserting an object (decorator pattern) that outputs the values in the stream.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>A new domain abstraction called <em>Add</em> is used. It has two IDataflow&lt;double&gt; inputs and a IDataFflow&lt;double&gt; output. We assign the Add to a local variable so that we can wire the second input later. Note that a C# class cannot implement the same interface twice (even though there is no reason why not). There are several ways we have used to work around this limitation. The one used here is to make one of the ports a Double2, a struct containing a double. This allows to have a double with a different type.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>To wire to the Double2 input port, we convert from double to Double2 using a DataFlowConvert&lt;double, Double2&gt;() abstraction. This abstraction can do any transformation on Dataflow, so is analogous to the Select() or Map() functions used in query languages.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>DataFlow initializer is a domain abstraction that can be used to initialize inputs of a dataflow in case no input arrives in time at run-time. In this case one of the two inputs to <em>Add</em> may not arrive if the temperature input port is not connected to anything. We therefore want to initialize it with a default temperature of 20 C.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>Note that it is not a problem to do fan-in wiring. Both defaultTemperature and the input port are connected to the input port of  offsetAndScaleTemperature.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For completeness, here is the code for the Add domain abstraction. Note that this abstraction is doing more than what a single + operator would. It is adding two dataflows.</p>
</div>
<div class="listingblock">
<div class="title">DomainAbstraction\Add.cs</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">using System;
using ProgrammingParadigms;

namespace DomainAbstractions
{
    /// &lt;summary&gt;
    /// ALA domain abstraction to add two numeric dataflows.
    /// Currently only supports doubles.
    /// Two input ports are implemented interfaces.
    /// One output port called "output".
    /// Both inputs must receive at least one data before output begins.
    /// Thereafter output occurs when either input receives data.
    /// One of the inputs is type Double2, which is a struct containing a double.
    /// This is a work around for can't implement the same interface twice.
    /// When wiring to the Double2 port, do it via an instance of DataFlowConvert like this:
    /// .WireIn(new DataFlowConvert&lt;double, Double2&gt;((d)=&gt;new Double2(d))).WireIn(new Add());
    /// You need to understand the programming paradigm abstraction, IDataFlow,
    /// to understand this code.
    /// &lt;/summary&gt;
    class Add : IDataFlow&lt;double&gt;, IDataFlow&lt;Double2&gt; <i class="conum" data-value="1"></i><b>(1)</b>
    {
        private IDataFlow&lt;double&gt; output; <i class="conum" data-value="2"></i><b>(2)</b>

        private double? operand1; <i class="conum" data-value="3"></i><b>(3)</b>
        private double? operand2; <i class="conum" data-value="3"></i><b>(3)</b>

        void IDataFlow&lt;double&gt;.Push(double data) <i class="conum" data-value="4"></i><b>(4)</b>
        {
            operand1 = data;
            if (operand2.HasValue)
            {
                output.Push(operand1.Value + operand2.Value);
            }
        }

        void IDataFlow&lt;Double2&gt;.Push(Double2 data) <i class="conum" data-value="5"></i><b>(5)</b>
        {
            operand2 = data.Value;
            if (operand1.HasValue)
            {
                output.Push(operand1.Value + operand2.Value);
            }
        }
    }


    /// &lt;summary&gt;
    /// Wrap a double in a struct.
    /// We do this only to get a different type of double to effectively get multple inputs
    /// for the "Add" class because C# wont allow implementing the same interface
    /// twice (it should though).
    /// &lt;/summary&gt;
    struct Double2
    {
        public Double2(double value) { this.value = value; }
        private readonly double value;
        public double Value { get { return value; } }
        public override string ToString() =&gt; $"{value}";
    }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Two input ports</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>One output port</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>For storing the last value received on each input. They are nullables so that we know when we have had input.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Implement the first input port</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Implement the second input port</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="truefolders-files-classes-objects-interfaces-functions"><a class="anchor" href="#truefolders-files-classes-objects-interfaces-functions"></a>2.2. Folders, files, classes, objects, interfaces, functions</h3>
<div class="paragraph">
<p>This is the second perspective on ALA. In this perspective we look at the implementation language elements and see how they are used in ALA applications.</p>
</div>
<div class="sect3">
<h4 id="truefolders-and-namespaces"><a class="anchor" href="#truefolders-and-namespaces"></a>2.2.1. folders and namespaces</h4>
<div class="paragraph">
<p>If you see an ALA application, you will find three to five folders that correspond with abstraction layers (described in the previous section). For example:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Application</p>
</li>
<li>
<p>Features</p>
</li>
<li>
<p>DomainAbstractions</p>
</li>
<li>
<p>ProgrammingParadigms</p>
</li>
<li>
<p>Foundation</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Knowledge dependencies only go down these layers. So to understand the code inside files in the higher layers, you need to have knowledge of what all the files in lower layers do. There are no dependencies between files in any folder.</p>
</div>
<div class="paragraph">
<p>Namespaces exactly correspond with these folder names. Therefore we have namespaces called "Application", "DomainAbstractions", "ProgrammingParadigms", etc. This tells us which layer an abstraction comes from, and which folder it resides in.</p>
</div>
<div class="paragraph">
<p>Namespaces also avoid naming conflicts between layers. They are not useful beyond that. Unfortunately, there is no convenient way of telling the compiler or the IDE to not 'see' classes, interfaces etc in other files in the same namespace or folder.</p>
</div>
</div>
<div class="sect3">
<h4 id="truefiles"><a class="anchor" href="#truefiles"></a>2.2.2. Files</h4>
<div class="paragraph">
<p>Abstractions are implemented as files. Abstractions are often implemented as a single class, function, or interface, but sometimes an abstraction consists of a small cohesive group of them, with things like delegates, enums, or even variables. Internal to an abstraction, they interconnect with each other unconstrained. There are no dependency rules inside a file. The only constraint ALA makes is that the total must be small - of the order of 200-500 lines of code, or under the brain size limit. This applies to all abstractions, including the ones that make up the application itself in the top layer.</p>
</div>
<div class="paragraph">
<p>In time I hope languages catch up and give us visibility support for ALA abstraction. This would probably involve a new construct called <em>Abstraction{}</em> to group the elements of an abstraction. It does not need a name. This construct replaces the use of a file that we are currently using as a stand-in. Anything public inside the Abstraction is only visible to code in higher layer abstractions, i.e. abstractions in higher namespaces. It is not visible in your own namespace, nor to those of lower layers. The compiler would need to know the namespace layering order. If we had this, we would have compiler checking for illegal dependencies.</p>
</div>
</div>
<div class="sect3">
<h4 id="trueobjects"><a class="anchor" href="#trueobjects"></a>2.2.3. Objects</h4>
<div class="paragraph">
<p>In ALA, abstractions are usually a single class. Instances of such abstractions are objects. It is the objects that get wired togther by their ports. Classes are the design artefacts that know nothing about one another. Objects are the run-time artefacts that communicate with one another at run-time.</p>
</div>
</div>
<div class="sect3">
<h4 id="trueinterfaces"><a class="anchor" href="#trueinterfaces"></a>2.2.4. Interfaces</h4>
<div class="paragraph">
<p>Classes have a 'main interface', the constructors, and any public methods and properties. A class can also implement other interfaces. In ALA, a class&#8217;s 'main interface' (it&#8217;s constructors and public methods and properties) are only used to instantiate and configure the class from a higher layer. It is never used to actually use the class to do its work. This is effectively the ISP (interface segregation principle). The client who instantiates a class object is different from the classes whose objects will interact with it, so different interfaces are used.</p>
</div>
<div class="paragraph">
<p>Only the higher layer with knowledge of the system has the relevant knowledge of what should be instantiated, how it should be configured, and how the instantiated objects should be composed together to make a system.</p>
</div>
<div class="paragraph">
<p>The 'main interface' of a class is 'owned' by the class and is specific to the class. This may sound like stating the obvious, since it is there to allow instantiation and configuration of said class. The thing is that no other interface implemented or required by the class can be 'owned' by the class. No other interface can be specific to the class. The class may not provide an interface designed specifically for it, not may it require an interface designed specifically for it. In other words, all other interfaces must be abstract and in a lower layer.</p>
</div>
<div class="paragraph">
<p>The idea that classes may not own any interface except the 'main interface' is critically important. If a class were to own another interface that is used for the class to do its work, then that interface would inherently have in its design knowledge about the class. This is true whether the interface is a provided interface (for other classes to use) or a required interface (for other classes to implement). Required interfaces are common for example in 'clean architecture'. They are illegal in ALA.</p>
</div>
<div class="paragraph">
<p>The inherent knowledge about the class contained in 'owned' interfaces will cause coupling. A class using an interface provided by another class will have design knowledge of what that other class provides at the same abstraction level as itself. It will be written according to what is being provided. There will be a fixed arrangement between the two classes. Over time, this fixed arrangement will cause a blurring of their respective responsibilities.</p>
</div>
<div class="paragraph">
<p>A class implementing an interface that is required by another class will have a similar problem. It will have design knowledge of what that other class requires at the same abstraction level as itself. It will be written according to what is required. There will be a fixed arrangement between the two classes. Over time, this fixed arrangement will cause a blurring of their respective responsibilities.</p>
</div>
<div class="paragraph">
<p>Therefore, classes in ALA do not have association relationships. Instead they just have fields of the type of these more abstract interfaces or they implement these more abstract interfaces. We call both of these <em>ports</em>.</p>
</div>
<div class="paragraph">
<p>The abstract interfaces that we put in lower layers are obviously have to be be general. It can be hard to see how this could work, but it does. For example, interfaces often implement a set of four methods for CRUD operations (Create, Read, Update, Delete). The very existence of this acronym suggests an abstract interface.</p>
</div>
</div>
<div class="sect3">
<h4 id="truecomposition-with-objects"><a class="anchor" href="#truecomposition-with-objects"></a>2.2.5. Composition with objects</h4>
<div class="paragraph">
<p>An abstract interface in a lower layer makes it much easier to have multiple classes implement or require them. Objects of different classes can then be composed together in arbitrary ways, giving us the powerful principle of compositionality. (The meaning of a complex expression is determined by the meanings of the constituent expressions and the rules used to combine them.)</p>
</div>
<div class="paragraph">
<p>Abstract interfaces suggest general meanings for the ways we compose objects. They end up looking a lot like programming paradigms, which is why we call the layer ProgrammingParadigms.</p>
</div>
<div class="paragraph">
<p>Any given class will typically implement/accept more than one of these abstract interfaces. These are the called ports. When using dataflow they are I/O ports. We do not think of the objects that get wired to these ports as clients. The word client is best used for classes in a higher layer (that use the main interface). The classes of the objects to which an object is wired are just called peers.</p>
</div>
</div>
<div class="sect3">
<h4 id="truecomposition-with-functions"><a class="anchor" href="#truecomposition-with-functions"></a>2.2.6. Composition with functions</h4>
<div class="paragraph">
<p>ALA can be applied to functional programming too. Abstractions are then obviously functions, and the same ALA relationship restriction applies - a function may only call a significantly more abstract function. The functions then form layers.</p>
</div>
<div class="paragraph">
<p>Where one function may have called a peer function in conventional code, now a higher layer function that has the system specific knowledge is needed to call the first function and then call the second function, in effect composing with functions. Parameters and return values are effectively port. If the first function called the second function in the middle rather than at the end, the second function will now need to be passed into it. The function parameter is also a port.</p>
</div>
<div class="paragraph">
<p>A higher layer function may call a series of lower layer functions, passing data from one to the next. We don&#8217;t often need the data in the higher level function. All we are trying to do is compose functions. It clutters up the code something awful when we have to handle data without needing to use that data. So that&#8217;s why we prefer to compose with objects with ports.</p>
</div>
<div class="paragraph">
<p>Monads also allow composition of functions without this cluttering. But they only support a dataflow type of programming paradigm. We want to compose using multiple ports on our abstractions using multiple programming paradigms. Objects with ports are a more straightforward way to think about this. Monads are objects under the covers, and this is part of the reason they are hard to understand (although eventually you get used to it). By composing with objects directly, it is clearer what is going on.</p>
</div>
</div>
<div class="sect3">
<h4 id="truereadme-file"><a class="anchor" href="#truereadme-file"></a>2.2.7. Readme file</h4>
<div class="paragraph">
<p>There should be a readme file in the root folder that points to this website (or equivalent documentation) about ALA. In ALA, we are explicit about what knowledge is needed before a given piece of code can be understood (knowledge dependencies). To understand an ALA application, you need a basic understanding of ALA (from this chapter). So that&#8217;s why there should be a readme file pointing here.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="trueexecutable-expression-of-requirements"><a class="anchor" href="#trueexecutable-expression-of-requirements"></a>2.3. Executable expression of requirements</h3>
<div class="paragraph">
<p>This is the third perspective of ALA. It is essentially the perspective of a DSL (domain specific language).</p>
</div>
<div class="paragraph">
<p>Writing software is re-expressing requirements in a different language. If that language is general purpose, we end up using a lot of symbols to express those requirements - many more than we would use in English. This is because in English we would use, or even invent terms in the domain to help us to be expressive and succinct. I&#8217;m not talking about customers or orders. I&#8217;m talking about general concepts for the UI, of data storage, or of certain events implied in our user stories.</p>
</div>
<div class="paragraph">
<p>Furthermore, if we are re-expressing requirements in a language that is essentially imperative (executes step by step instructions in computer time) it&#8217;s going to be super awkward. Things like UI layout or asynchronous events don&#8217;t map directly to imperative style. It&#8217;s going to require a lot of cleverness to express them every signle time.</p>
</div>
<div class="paragraph">
<p>Furthermore, let&#8217;s say it takes 100 lines of English to state the requirements and 10000 lines of code to implement the requirements. Potentially all 10000 lines of code know about the requirements in some way. Each also knows about some computing detail like how to store data, how to do input/output, or how to schedule what its doing in real time. The details of requirements and the details of computing are mixed together. The expression of requirements is extremely verbose in such a design.</p>
</div>
<div class="paragraph">
<p>ALA separates out the expression of requirements from computing details. It does this by first identifying the types of relationships inherent in requirements. These are not imperative calls in computer time. They are things like dataflows, events, and UI layouts. We invent programming paradigms for these. Then we invent types of things implied in the requirements with these relations. Things like UI elements, data transformations, data stores, and transactions. Now we have a domain specifc language. We compose instances of the thing types together using instances of our relationship types. The resulting expression of requirements is direct and succinct.</p>
</div>
<div class="paragraph">
<p>In ALA the thing types are called <em>domain abstractions</em>. The relations are called <em>programming paradigms</em>. Each domain abstraction hides one generic piece of computing implementation. Each programming paradigm defines what the composition of two domain abstractions means. Programming paradigms hide an execution model for how the relationship will work in terms of underlying imperative execution.</p>
</div>
<div class="paragraph">
<p>It is the top layer (or top two layers for larger applications) that describe all the details in the requirements (and nothing but the details of requirements.) All details of actual computing work go are the implementations inside the domain abstractions and programming paradigms.</p>
</div>
<div class="paragraph">
<p>The amount of code that describes requirements is typically about 3-10% of the entire application. When requirements change, you only need to understand this 3-10%.</p>
</div>
<div class="paragraph">
<p>The percentage of code expressing requirements does depend on how many requirements there are. Because ALA emphasises the use of abstractions, and abstractions are reusable, an application with many requirements may have so much reuse that the percentage of code expressing requirements goes higher.</p>
</div>
<div class="paragraph">
<p>The expression of requirements in the top layer is executable. This could be compared with BDD (behavioural driven design) which is also expresses the requirements and is executable. But BDD only executes the tests. ALA goes one step further to make the expressed requirements the executable solution.</p>
</div>
<div class="paragraph">
<p>The executable description of requirements in the top layer is also the architecture or the design. (I do not make a distinction between architecture and design.) There is no separate artefact or documentation of the 'architecture', no model, no other "high level" design document. The one artefact expresses requirements, expresses the architectural design, and is the executable. So one source of truth for everything.</p>
</div>
<div class="sect3">
<h4 id="truepolyglot-programming-paradigms"><a class="anchor" href="#truepolyglot-programming-paradigms"></a>2.3.1. Polyglot programming paradigms</h4>
<div class="paragraph">
<p>In this perspective of ALA, we view it as a vehicle for multi-paradigm programming.</p>
</div>
<div class="paragraph">
<p>Many higher level programming models are based on a single programming paradigm. Examples are the dataflow model, event-driven, actor (message passing) model, or ladder logic.</p>
</div>
<div class="paragraph">
<p>A given paradigm makes it easy to solve some problems but not others. Having a single programming paradigm makes the programming model pure and simple. But it&#8217;s just plain awkward for certain aspects of typical problems.</p>
</div>
<div class="paragraph">
<p>So ALA takes the approach that not only will we be able to compose using multiple programming paradigms, we do it it with the same wiring operators. This allows them to be easily intermixed in the same user story or feature, or in the same application diagram. Furthermore, creating and implementing a new programming paradigm is straightforward.</p>
</div>
<div class="paragraph">
<p>In the end, we want to attain a certain level of expressiveness of composition. If we are too expressive we wont have enough versatility to vary our applications in the domain. If we don&#8217;t have enough expressiveness, we will have to compose too many low level elements to get anything done.</p>
</div>
<div class="paragraph">
<p>Some examples of programming paradigms that we use frequently are UI layouts, dataflow, schema relationships, state transitions.</p>
</div>
<div class="paragraph">
<p>Each programming paradigm usually results in a type of port for the domain abstractions. Instances of two abstractions can then be wired by their compatible ports. The programming paradigm provides the meaning of that composition, and provides the execution model for that meaning to be carried out.</p>
</div>
<div class="paragraph">
<p>There are other types of programming paradigms that don&#8217;t need to use ports as well. For example, say you want a programming paradigm for style. You would create a Style concept abstraction in the programming paradigms folder. Then every UI domain abstraction would get its style properties from this abstraction. Then the application layer configures the style abstraction for a specific application, and all UI instances would take on that style. You would only use this method rather than ports if every ports would be connected to a single instance of something. If things are connected to one instance, that indicates that the instance itself can be an abstraction, and simply be put down a layer for everyone to access.</p>
</div>
<div class="paragraph">
<p>Some will disagree with the last paragraph as it effectively makes the style object a global. That&#8217;s not great even if it is a good abstraction. Indeed if you want to say test a UI domain abstraction with styles, and do these tests in parallel, the global wont work. Or there may be leftover state in the global between different tests. Or we may want to override the style on one UI instance. If we don&#8217;t want to use global instance of style, then we go back to ports. We then create an instance of style and wire every instance of every UI domain abstraction to this instance. To make such wiring easier, I have  WireMany operator. This extension method will look for a compatible  port on every instance of every domain abstraction.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="truediagrams"><a class="anchor" href="#truediagrams"></a>2.4. Diagrams</h3>
<div class="paragraph">
<p>In this perspective, we view ALA as a vehicle for diagram oriented design.</p>
</div>
<div class="paragraph">
<p>We don&#8217;t have to use diagrams in ALA. It only comes about because requirements typically contain a whole network of relationships. For example, UI elements have spacial relationships with one another. They have relationships with data. Data has relationships with storage (state which is expected to persist across user stories). Stored data has it&#8217;s own inter-relationships. All have relationships with real-time events.</p>
</div>
<div class="paragraph">
<p>In conventional code, this network of relationships results in a network of dependencies across the modules of the code. These types of dependencies are used for run-time communications. Inverting these types of dependencies doesn&#8217;t help. It&#8217;s still a dependency that&#8217;s only there for run-time communications. We don&#8217;t like circular dependencies, but communications are often naturally circular. So we introduce still more indirections, obscurring the natural network even further.</p>
</div>
<div class="paragraph">
<p>The result is a big ball of mud. It consists of thousands of symbolic references. 'All files' searches are needed to find these references and unravel the network.</p>
</div>
<div class="paragraph">
<p>ALA elliiminates this network of dependencies and replaces them with ordinary lines of code that instantiate abstractions and wire them together. That code is placed inside the top application abstraction (or into a set of feature or user story abstractions). The code is cohesive because it repesents in one place the network of relationships that make up a feature user story.</p>
</div>
<div class="paragraph">
<p>In this wiring code, the network nature of the inter-relationships within a user story between instances of domain abstractions becomes obvious. It can become clear that the best way to express it is a diagram.  ALA therefore uses diagrams quite often. These diagrams are, more or less, like static UML object diagrams. So in ALA, we throw away the UML class diagrams (relationships between abstractions), and use UML object diagrams instead (relationships between instances).</p>
</div>
<div class="paragraph">
<p>In the trivial examples of composition that we already gave, we used text for the wiring code. This was because they had a linear or tree structure. These structures can naturally be represented in text, although trees represented in text form become hard to read if they go too deep (too much indenting). For arbitrary networks, using text requires 'symbolic connections' or labels to connect some of the instances. This is done by giving instances names (storing a reference in a local variable). Wiring connection then refer to the instance names. These symbolic wiring make the code harder to read as their number increases beyond a few connections.</p>
</div>
<div class="paragraph">
<p>An advantage of expressing the network in diagram form is that you don&#8217;t have to give names to instances. You can leave them all anonymous if you want to. Sometimes you will give them names anyway as documentation. For example, if you have two grids implied in your requirements, you will want to give them names so you know which is which in the diagram.</p>
</div>
<div class="paragraph">
<p>Sometimes programming with diagrams is called model driven software development. I prefer to not to use the word 'model'. In the real world, models leave out details. Software structure models tend to leave out details too. ALA diagrams do not leave out details. All details from the requirements are represented, for example in the form of configuration of the instances. That no details are left out is why the structural diagram is also the executable.</p>
</div>
<div class="paragraph">
<p>When a diagram is used for the internals of a whole application, it resides in the application layer folder.</p>
</div>
<div class="paragraph">
<p>When a diagram is used for the internals of a feature or user story, it reside in the respective layer folder.</p>
</div>
<div class="paragraph">
<p>The wiring code generated from the diagram also lives in the same folder. It can be manually or automatically generated. It can be as simple as a list of statements creating instances and configuring them, and a list of wiring statements between instances. The diagram should always be changed first, then the code. There should be a readme explaining how to change the code when the diagram is changed.</p>
</div>
<div class="paragraph">
<p>The generated code does not need to be readable except to the extent of finding where it doesn&#8217;t accurately reflect the diagram if needed.</p>
</div>
</div>
<div class="sect2">
<h3 id="truecomposition-vs-decomposition-methodologies"><a class="anchor" href="#truecomposition-vs-decomposition-methodologies"></a>2.5. Composition vs decomposition methodologies</h3>
<div class="paragraph">
<p>In this perspective, we look at software design methodology. Conventional wisdom is a decomposition approach. You decompose a system into modules or components. Those modules are further decomposed into submodules and so on. By contrast, ALA is a composition approach. It composes the system from instances of abstractions. Those abstractions are composed from instances of even more abstract abstractions. The difference is important as it results in a completely difefrent structure.</p>
</div>
<div class="paragraph">
<p>In the next chapter we will discuss in detail why ALA uses a 'composition' approach rather than a 'decomposition' approach. Here we describe the two different structures that result from these two approaches.</p>
</div>
<div class="paragraph">
<p>In the conventional approach, components tend to get more specific than the system because they are specific parts of it. It is a bit like jigsaw pieces to a jigsaw picture. The pieces are not reusable. The picture is not a separate entity - it is just the set of pieces, which have a rigid arrangement with each other. The picture cannot change without changing the pieces.</p>
</div>
<div class="paragraph">
<p>In the ALA approach, abstractions used to compose a system must be more abstract than the system. It is a bit like lego pieces to a specific lego creation. The pieces are reusable. The lego creation is a separate entity in itself - it is more than the set of pieces. The lego creation can change without changing the pieces.</p>
</div>
<div class="sect3">
<h4 id="trueencapsulation-hierarchy-vs-layers"><a class="anchor" href="#trueencapsulation-hierarchy-vs-layers"></a>2.5.1. Encapsulation hierarchy vs layers</h4>
<div class="paragraph">
<p>Because a decomposed system tends to create modules that are specific to the system, these modules tend to be not reusable. They may be replaceable with modules that have the same interfaces, but not actually reusable. We tend to encapsulate such modules inside the system. Similarly with submodules, we encapsulate them inside their modules. This creates an encapsulation hierarchy. It is sometimes likened to a map in which we can zoom in for greater detail.</p>
</div>
<div class="paragraph">
<p>This actually doesn&#8217;t work for hiding information at design time. Because  the modules are specific and not abstractions, you will always have to zoom in for the details of the inner modules in order to understand the system. Encapsulation makes as much sense as hiding the picture on every individual piece of a jigsaw puzzle unless you zoom into it, then trying to see the big picture.</p>
</div>
<div class="paragraph">
<p>The encapsulation may help to unclutter the IDE namespace at the system level, but it doesn&#8217;t reduce how much you have to go inside the encapsulations to understand the system.</p>
</div>
<div class="paragraph">
<p>If the modules and submodules are abstractions, and those abstractions are more abstract than the modules that use them, then we don&#8217;t have to zoom in. We can understand a system in terms of the abstractions it uses.</p>
</div>
<div class="paragraph">
<p>Abstractions are reusable. So we explicitly do not want to encapsulate them inside something that uses them. We need them to be public for reuse. Instead of encapsulating them, we use abstraction layers.</p>
</div>
</div>
<div class="sect3">
<h4 id="trueprimary-separation"><a class="anchor" href="#trueprimary-separation"></a>2.5.2. Primary separation</h4>
<div class="paragraph">
<p>Decomposition tends to break up a system first according to these types of criteria:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>locations of physical machines or processors (e.g. tiers, services)</p>
</li>
<li>
<p>computing problems (e.g. UI, business logic, data storage)</p>
</li>
<li>
<p>business structure (Conway&#8217;s law)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A system decomposed in this way will make features or user stories span the modules. This is bad. It forces us to create dependencies for communications within a feature or user story.</p>
</div>
<div class="paragraph">
<p>In ALA, features or user stories are obvious abstractions given to us by the requirements. As such we keep them together, even if they cross over these other boundaries. For example, if UI, business logic, and storage span three different machines, there is nothing stopping us coding or drawing a single diagram containing all the elements of the UI, business logic and storage for a user story. The elements will be instances of abstractions deployed on different machines, but that is a deployment detail. As long as the internal lines in the diagram represent asynchronous communications, the feature or user story will still work when deployed. Deployment time abstractions can insert the necessary middleware. No specific interfaces are needed between the elements on different machines because they are instances of abstractions that already have compatible asynchronous-ready ports. (We cover asynchronous ports in detail in chapter four.)</p>
</div>
<div class="paragraph">
<p>The way the resulting code is organised will be completely different from a convention decomposition. The relationships that exist between conventional modules will disappear. They become cohesive lines of code inside a new abstraction representing the system. In fact that&#8217;s all the system abstraction will need to do.</p>
</div>
<div class="sect4">
<h5 id="truecontrasting-the-two-structures"><a class="anchor" href="#truecontrasting-the-two-structures"></a>contrasting the two structures</h5>
<div class="imageblock text-center">
<div class="content">
<img src="images/Slide8.jpg" alt="Slide8.jpg">
</div>
<div class="title">Figure 10. Decomposition into elements and their relations</div>
</div>
<div class="paragraph">
<p>The figure shows five conventional modules (or components) and their relations (as interactions). Study almost any piece of software, and this is what you will find (even if it supposedly adheres to the so-called layering pattern).</p>
</div>
<div class="paragraph">
<p>The structure generally can be viewed as 'clumping'. Like galaxies, certain areas have higher cohesion, and so go inside boxes. Other areas are more loosely coupled, and so are represented by lines between the boxes. The difference between high cohesion and loose coupling is only quantitative.</p>
</div>
<div class="paragraph">
<p>Software health in this type of architecture is effectively management of the resulting coupling between the cohesive clumps. Allocate code to boxes in such a way as to minimize coupling. This coupling management has two conflicting forces. One is the need to have interactions to make the modules work as a system. The other is to minimize the interactions to keep the modules as loosely coupled as possible. As maintenance proceeds, the number of interactions inevitably increases, and the interfaces get wider. Cohesion will reduce, and coupling will increase over time.</p>
</div>
<div class="paragraph">
<p>Various architectural styles are aimed at managing this conflict. Most notably:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Layering pattern (break circular dependencies and replace them with indirections which are even worse.)</p>
</li>
<li>
<p>Try to avoid both high fan-in and high fan-out on a single module</p>
</li>
<li>
<p>Try to avoid dependencies on unstable interfaces</p>
</li>
<li>
<p>MVC type patterns</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Note that none of this 'dependency management' actually avoids design-time coupling. There will always be 'implicit coupling' in both directions between modules of a decomposed system, regardless of the dependencies. This is because the modules are the opposite of abstractions - specific parts designed to interact or collaborate to make a system. For example, a function of a decomposed system will tend to be written to do what its caller requires even if there is no explicit compile-time dependency on its caller. So circular coupling may be avoided at compile-time, but will still be present at design-time. That is why in the diagram above, couplings are drawn from the insides of each of the modules in both directions. This indicates that the code inside the modules has some inherent collaboration with the code inside other modules. To the compiler or a dependency graphing tool, the lines may appear to be layered, but this is not telling you the whole story of the design-time coupling.</p>
</div>
</div>
<div class="sect4">
<h5 id="truethe-compose-approach"><a class="anchor" href="#truethe-compose-approach"></a>The compose approach</h5>
<div class="paragraph">
<p>When you use abstractions instead of modules, there is qualitative difference in how the structure is built. There are no  interactions, collaboration, or coupling between abstractions:</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="images/Slide9.jpg" alt="Slide9.jpg">
</div>
<div class="title">Figure 11. Abstraction do not interact</div>
</div>
<div class="paragraph">
<p>The word 'modules' has been changed to the word 'abstractions'. All the dependencies are gone. And with them all their problems. You no longer have to worry about dependencies and all their management. The implicit coupling that we talked about earlier is also gone. The 'clumping' structure has become isolated boxes. Loose coupling has become zero coupling.</p>
</div>
<div class="paragraph">
<p>The obvious question now is how can the system work? Where do all the  interactions between elements that we had before go? The answer is they become normal code, completely contained inside one additional abstraction. This code composes instances of the abstractions to make a system:</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="images/Slide10.jpg" alt="Slide10.jpg">
</div>
<div class="title">Figure 12. Abstractions and composition of their instances</div>
</div>
<div class="paragraph">
<p>The code inside the new system abstraction does not involve dependencies <em>between</em> abstractions. It uses dependencies <em>on</em> abstractions. It&#8217;s code that instantiates abstractions and wires them together via their (even more abstract) ports. Since interactions between the instances are implemented without dependencies between the abstractions, circular wiring is fine. In fact we should embrace it, because that is how the system works.</p>
</div>
<div class="paragraph">
<p>This instantiation and wiring code is cohesive. It is <em>the</em> code that has knowledge of the specific system. None of the code inside the abstractions knows about the specific system, only this new code.</p>
</div>
<div class="paragraph">
<p>We put the abstractions, A, B, C, D and E into a layer. The system abstraction goes in the layer above.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Software engineering should <span class="red"><strong>not</strong></span> be about <span class="red"><strong>managing coupling</strong></span>.</p>
</div>
<div class="paragraph">
<p>It should be about <span class="green"><strong>inventing abstractions</strong></span>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="truecf-component-based-development"><a class="anchor" href="#truecf-component-based-development"></a>2.6. cf Component based development</h3>
<div class="paragraph">
<p>In this perspective, we compare ALA with components, component based software engineering (component based development), components and connectors and service oriented architecture.</p>
</div>
<div class="paragraph">
<p>When you read the intentions for components, they are meant to be reusable. Since reuse and abstraction go hand in hand, it should follow that components are abstractions. Furthermore, just as we do in ALA, they have ports to supposedly allow them to have run-time communications with one another without breaking them as abstractions.</p>
</div>
<div class="paragraph">
<p>That&#8217;s the intentions. In practice, all the component diagrams I have seen fall far short of this ideal. The components themselves appear to be specific pieces of a specific system - the jigsaw analogy. Although they have the wiring mechanics to allow reuse, they are too specific to the system they are designed for to be reusable abstractions. They maybe exceptions of course, but components lack a fundamental rule that constrains components to be more abstract than the systems they are used in.</p>
</div>
<div class="paragraph">
<p>So like a jigsaw, a system is a rigid decomposition. The only changes possible are to substitute a component for one with equivalent ports.</p>
</div>
<div class="paragraph">
<p>At the port level, this happens because the ports use interfaces that belong to one or other of the components. As we said in the section about interfaces earlier in this chapter, an abstraction cannot know about either a provided or a required interface of a peer abstraction.</p>
</div>
<div class="paragraph">
<p>Components allow hierarchical composition, but don&#8217;t make it clear what that means. Does it mean component instances or component types? Some implementations I have seen allow you to configure the visibility of a component type. So a component type can be inside another component type and be private. This type of hierarchy is illegal in ALA because used components must be more abstract and therefore must be defined outside where they are public for reuse. Of course using instances of a component inside another component is the whole point of how we build up system in either ALA or component driven development.</p>
</div>
<div class="paragraph">
<p>I do not know why you would define a component type inside another component type and then mark it as public. It doesn&#8217;t make sense. If the component type is more abstract and reusable than the one containing it, which presumably it is because it is being marked public, then it doesn&#8217;t relate to the component that contains it, and shouldn&#8217;t be inside it.</p>
</div>
<div class="paragraph">
<p>In summary, components should have been what ALA is. They just failed to really emphasis the importance of the first ALA constraint - the only unit of code is an abstraction, and completely missed the second ALA constraint - the only relationship allowed is a dependency on a more abstract abstraction. Without these constraints, the good intentions of components with ports fail to materialize.</p>
</div>
<div class="sect3">
<h4 id="truecomponents-and-connectors"><a class="anchor" href="#truecomponents-and-connectors"></a>2.6.1. Components and connectors</h4>
<div class="paragraph">
<p>One implementation model for components is so called <em>components and connectors</em>. The mechanics of components and connectors is that the lines drawn between components are connector objects. They contain a value, which is the 'data on the wire'. Thinking of the wire as being a variable with a value is quite a useful programming paradigm. It is also a relatively efficient execution model. The variable itself is a shared variable that isn&#8217;t global. Only the two instances of components that are wired together can ever see it. Senders need only set the value of the variable, and receivers need only read the variable.</p>
</div>
<div class="paragraph">
<p>When two compatible instances of components are composed or wired together, the implied connector object is created automatically and wired inbetween them.</p>
</div>
<div class="paragraph">
<p>The instances of domain abstractions would be active objects.</p>
</div>
<div class="paragraph">
<p>Let&#8217;c create such a programming paradigm for ALA applications:</p>
</div>
<div class="listingblock">
<div class="title">Connector.cs</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">namespace ProgrammingParadigms
{
    class Connector&lt;T&gt; : IOutput&lt;T&gt;, IInput&lt;T&gt; <i class="conum" data-value="1"></i><b>(1)</b>
    {
        T data { get; set; } = default(T);
        T IOutput&lt;T&gt;.data { get =&gt; data; set =&gt; data = value; }
        T IInput&lt;T&gt;.data { get =&gt; data; }
    }


    public interface IOutput&lt;T&gt; <i class="conum" data-value="2"></i><b>(2)</b>
    {
        T data { get; set; }
    }

    public interface IInput&lt;T&gt; <i class="conum" data-value="3"></i><b>(3)</b>
    {
        T data { get; }
    }


    public static class StaticMethods
    {
        public static void Wire&lt;T&gt;(ref IOutput&lt;T&gt; Aport, ref IInput&lt;T&gt; Bport) <i class="conum" data-value="4"></i><b>(4)</b>
        {
            Connector&lt;T&gt; connector = new Connector&lt;T&gt;();
            Aport = connector;
            Bport = connector;
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The connector type itself. Instances are to be wired between two instances of domain abstractions.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>One domain abstraction must have a field of the IOutput interface.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>One domain abstraction must have a field of the IInput interface.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>A method for wiring two instances of domain abstractions creates the connector for you, and then wires the two instances to it.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Let&#8217;s create two domain abstractions to demonstrate the use of this programming paradigm. First a domain abstraction with an output port using this programming paradigm.</p>
</div>
<div class="literalblock">
<div class="title">NaturaNumbersTenPerSecond.cs</div>
<div class="content">
<pre>using ProgrammingParadigms;

namespace DomainAbstractions
{
    /// &lt;summary&gt;
    /// ALA Domain Abstraction
    /// Demo class to send data via a connector
    /// &lt;/summary&gt;
    class NaturaNumbersTenPerSecond
    {
        public IOutput&lt;int&gt; output; <i class="conum" data-value="1"></i><b>(1)</b>


        public void Run() <i class="conum" data-value="3"></i><b>(3)</b>
        {
            RunAsyncCatch();
        }


        public async Task RunAsyncCatch()
        {
            // because we are the outermost async method, if we let exceptions go,
            // they will be lost
            try
            {
                await RunAsync();
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.ToString());
            }
        }


        public async Task RunAsync()
        {
            int data = 0;
            while (true)
            {
                data++;
                output.data = data; <i class="conum" data-value="2"></i><b>(2)</b>
                await Task.Delay(100);
            }
        }
    }
}</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The output port</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Outputting data to the output port</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>This domain abstraction is active, so we need a Run method to start it running.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>An another domain abstraction with an input port using this programming paradigm.</p>
</div>
<div class="literalblock">
<div class="title">ConsoleOutputEverySecond.cs</div>
<div class="content">
<pre>using ProgrammingParadigms;

namespace DomainAbstractions
{
    /// &lt;summary&gt;
    /// ALA Domain Abstraction
    /// Demo class to send data via a connector
    /// &lt;/summary&gt;
    class ConsoleOutputEverySecond
    {
        public IInput&lt;int&gt; input; <i class="conum" data-value="1"></i><b>(1)</b>


        public void Run()
        {
            RunAsyncCatch();
        }


        public async Task RunAsyncCatch()
        {
            // because we are the outermost async method, if we let exceptions go,
            // they will be lost
            try
            {
                await RunAsync();
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.ToString());
            }
        }


        public async Task RunAsync()
        {
            while (true)
            {
                Console.WriteLine(input.data); <i class="conum" data-value="2"></i><b>(2)</b>
                await Task.Delay(1000);
            }
        }
    }
}</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The input port</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Inputting data from the input port</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>And finally an application to wire together instances of these domain abstractions:</p>
</div>
<div class="paragraph">
<p>Application.cs</p>
</div>
<div class="literalblock">
<div class="content">
<pre>using DomainAbstractions;
using static ProgrammingParadigms.StaticMethods;

namespace Application
{
    class Application
    {
        /// &lt;summary&gt;
        /// Application to demonstrate two active components running at different rates
        /// communicating using a connector.
        /// &lt;/summary&gt;
        public static void Main()
        {
            NaturaNumbersTenPerSecond numbers = new NaturaNumbersTenPerSecond();
            ConsoleOutputEverySecond console = new ConsoleOutputEverySecond();
            Wire(ref numbers.output, ref console.input);

            numbers.Run();
            console.Run();
            Console.ReadKey();
        }
    }

}</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="truereal-world-analogies"><a class="anchor" href="#truereal-world-analogies"></a>2.7. Real world analogies</h3>
<div class="sect3">
<h4 id="trueatoms-and-molecules"><a class="anchor" href="#trueatoms-and-molecules"></a>2.7.1. Atoms and molecules</h4>
<div class="paragraph">
<p>Here are two atom abstractions:</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/oxygen.png" alt="Oxygen atom" width="200" title="Oxygen atom"></span>
<span class="image"><img src="images/hydrogen.png" alt="Hydrogen atom" width="200" title="Hydrogen atom"></span></p>
</div>
<div class="paragraph">
<p>Instances can be composed to make a molecule:</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/water_molecule.jpg" alt="Water molecule" width="300" title="Water molecule"></span></p>
</div>
<div class="paragraph">
<p>If water was implemented in the same way we typically write software, there would be no water molecule per se; the oxygen atom would be modified to instantiate hydrogen atoms and interact with them. Even if dependency injection is used to avoid the instantiating, it is still unlikely that a water abstraction would be invented to do that, and there would still be the problem of the oxygen atom interacting with hydrogen&#8217;s specific interface. The oxygen module still ends up with some implicit knowledge of hydrogen. And hydrogen probably ends up with some implicit knowledge of oxygen in providing what it needs.</p>
</div>
<div class="paragraph">
<p>This implicit knowledge is represented by the following diagram. The relationship is shown coming from the inner parts of the modules to represent implicit knowledge of each other.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/diagram-o-h.png" alt="diagram o h">
</div>
</div>
<div class="paragraph">
<p>While oxygen and hydrogen are modules, they are not abstractions because oxygen is implicitly tied to hydrogen and vice-versa. They can&#8217;t be used as building blocks for any other molecules.</p>
</div>
<div class="paragraph">
<p>To keep oxygen as abstract as it is in the real world, an interface must be conceived that is even more abstract than oxygen or hydrogen. In the molecule world this is called a polar bond. It is one of the programming paradigms of molecules. Its execution model at run-time is the sharing of an electron.</p>
</div>
<div class="paragraph">
<p>The corresponding software would look like this:</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="images/Slide15.jpg" alt="Slide15.jpg">
</div>
<div class="title">Figure 13. </div>
</div>
<div class="paragraph">
<p>The water molecule has a "uses instances of" relationship with the two atoms, and the atoms have a "uses instance of" relationship with the even more abstract polar bond abstraction. Polar bond is an example of an 'abstract interface'.</p>
</div>
</div>
<div class="sect3">
<h4 id="truelego"><a class="anchor" href="#truelego"></a>2.7.2. Lego</h4>
<div class="paragraph">
<p>The second real world analogy is Lego. Shown in the image below is the same three layers we had above for molecules, atoms and bonds.</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="images/Slide16.jpg" alt="Slide16.jpg">
</div>
<div class="title">Figure 14. </div>
</div>
<div class="paragraph">
<p>The domain abstractions are the various Lego pieces, instances of which can be assembled together to make specific creations. Lego pieces themselves have instances of an abstract interface, which is the stud and tube. This is a programming paradigm. There is a second abstract interface, the axle and hole. These programming paradigms have an 'execution model' at run-time. The execution of the stud and tube programming paradigm is to hold structural integrity. The execution of the axle and hole programming paradigm is rotation.</p>
</div>
<div class="sect4">
<h5 id="trueconventional-code-analogy"><a class="anchor" href="#trueconventional-code-analogy"></a>Conventional code analogy</h5>
<div class="paragraph">
<p>If Lego is a good analogy for ALA, then what would be a good analogy for conventional code?</p>
</div>
<div class="paragraph">
<p>It&#8217;s an upside down jigsaw puzzle.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/jigsaw.jpg" alt="jigsaw.png" width="75%">
</div>
<div class="title">Figure 15. Conventional code is built like a jigsaw puzzle</div>
</div>
<div class="paragraph">
<p>The pieces are modules, and the interlocking shapes are the interfaces. The picture is the application or system.</p>
</div>
<div class="paragraph">
<p>Like the interlocking shapes, interfaces tend to be specific to pairs of modules. They may nominally belong to one piece or the other, but the complimentary one bends to that interface, and vice versa. This causes the modules to be coupled at design time. They have one rigid structure for how they fit together, although substitute pieces that have the same interfaces but a different picture may be switched.</p>
</div>
<div class="paragraph">
<p>The jigsaw puzzle is upside down because there is no view of the complete picture. You are allowed to pick up one piece at a time and look at the part of the picture that&#8217;s on the other side. This is the equivalent of opening a module and reading the code. By doing this repeatedly for many adjacent pieces, you can start to get an idea of what some of the bigger picture looks like. But, you have to keep this picture in your head, because there is no explicit view of it.</p>
</div>
<div class="paragraph">
<p>A jigsaw has one layer. The interfaces and the modules are rigidly interconnected in that layer. The picture only exists as the rigid structure, not an artefact of its own.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="trueelectronic-schematic"><a class="anchor" href="#trueelectronic-schematic"></a>2.7.3. Electronic schematic</h4>
<div class="paragraph">
<p>The third real world analogy comes from electronics. The abstractions are electronic parts, instances of which can be composed as a schematic diagram:</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="images/Slide17.jpg" alt="Slide17.jpg">
</div>
<div class="title">Figure 16. </div>
</div>
<div class="paragraph">
<p>In this domain, we have at least two abstract interfaces as programming paradigms, one for digital logic signals and one for analog signals. Their execution model at run-time is continuous-time voltage levels.</p>
</div>
</div>
<div class="sect3">
<h4 id="truea-clock"><a class="anchor" href="#truea-clock"></a>2.7.4. A clock</h4>
<div class="paragraph">
<p>Our forth and final real world analogy is a clock. In this diagram, we show the process of composition of abstractions to make a new abstraction. The process is a circle because instances of the new abstraction can themselves be used to make still more specific abstractions. Each time around the circle adds one layer to the abstraction layering.</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="images/Slide18.jpg" alt="Slide18.jpg">
</div>
<div class="title">Figure 17. </div>
</div>
<div class="paragraph">
<p>Let&#8217;s go round the circle once. We start with abstract parts such as cog wheels and hands. Instances of these have abstract interfaces as programming paradigms. Their execution models allow them to interact at run-time, such as spinning on axles and meshing teeth. The next step is to instantiate some of these abstractions and configure them. For example, configure the size and number of teeth of the cog wheels. Next comes the composition step, where they are assembled. Finally we have a new abstraction, the clock. Instances of clocks can in turn be used to compose other things such as scheduling things during your day. Because you have now created the abstraction <em>clock</em> you don&#8217;t have to think about cog wheels when thinking about how to meet someone at a certain time.</p>
</div>
<div class="paragraph">
<p>There are many other instances of this pattern in the real world, and in nature. In fact everything appears to be actually composed in this way. At least that&#8217;s the way we understand and make sense of the world - in terms of abstractions, which are in composition layers.</p>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="trueexample-project-calculator"><a class="anchor" href="#trueexample-project-calculator"></a>2.8. Example project - Calculator</h3>
<div class="paragraph">
<p>This project was originally done in a hurry for an ALA workshop. Apart from being a cool example of the use of ALA, the calculator itself is cool. This calculator is in Github, as a work in progress here: <a href="https://github.com/johnspray74/ReactiveCalculator">https://github.com/johnspray74/ReactiveCalculator</a></p>
</div>
<div class="paragraph">
<p>The original development for the workshop was done in about a day, so here we tell the story of that development.</p>
</div>
<div class="paragraph">
<p>When I was first asked to do the workshop, I needed to think of a suitable pedagogical sized project. It was suggested to do a calculator. Ok, I thought, if we have the domain abstractions already in place before the workshop, we should be able to write a calculator application (top layer) during the workshop.</p>
</div>
<div class="paragraph">
<p>When we think of a calculator application, we usually imagine a user interface that mimics a handheld calculator. It has a one line display and a keypad on the screen. We certainly could have built that calculator (primarily using a state machine programming paradigm). But that problem has already been solved by Miro Samek. Besides, I hate those simulated handheld calculators. I think they a stupid way to do calculations on a computer. Such a calculator would be cumbersome.</p>
</div>
<div class="paragraph">
<p>As an aside, I once loved HP calculators. The first programmable anything I ever owned was an HP65 calculator. I have owned many top end models at one time or another. But as their displays got larger, I became more and more disappointed with how they used that display real-estate. They just used it as a stack.</p>
</div>
<div class="paragraph">
<p>The calculator I wanted would show the expression you had entered so you can check it. It could show it in algebraic or even textbook form, even though you had entered it as RPN. You could re-edit the expression. You could label your expression result and then you could use the result in another expression. When you changed something, all results would be updated like in Excel. This is what the HP prime should have been.</p>
</div>
<div class="paragraph">
<p>So I drew this sketch of what I wanted a calculator to be:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/CalculatorRequirements.png" alt="Calculator3.png" width="900">
</div>
<div class="title">Figure 18. Calculator requirements</div>
</div>
<div class="paragraph">
<p>Here is a screenshot of the working calculator as it was two half-days later:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/CalculatorScreenshot.png" alt="CalculatorScreenshot.png" width="900">
</div>
<div class="title">Figure 19. Calculator screenshot</div>
</div>
<div class="paragraph">
<p>The first step in the design of the calculator was to express the requirements (UI plus behaviours), inventing any needed abstractions to do so. Here is the actual first sketch I drew:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/Calculator2Rows-HandDrawing.png" alt="Calculator2Rows-HandDrawing.png" width="900">
</div>
<div class="title">Figure 20. Calculator (2 Rows only shown)</div>
</div>
<div class="paragraph">
<p>As we shall see, this diagram is practically executable code. The calculator is practically done. We don&#8217;t know if the invented domain abstractions will work yet, but let&#8217;s go through how this calculator works anyway.</p>
</div>
<div class="sect3">
<h4 id="truehow-the-calculator-works"><a class="anchor" href="#truehow-the-calculator-works"></a>2.8.1. How the calculator works</h4>
<div class="paragraph">
<p>First notice how the entire calculator is there. Every detail for this  particular calculator is represented in the diagram. All those details are cohesively decribe the calculator. This is an important aspect of ALA designs. All the UI and all the dataflows to make a working calculator are in this one diagram. What is not here is the details we left to the domain abstractions. None of these abstractions is specific to a calculator. They can be used for all sorts of things. Even the Formula abstraction would be useful in any application where a calculation needs to be changed at run-time. For example an insurance application may need configurable calculations.</p>
</div>
<div class="paragraph">
<p>The left side shows two instances of the abstraction, Horizontal. These arrange their children horizontally in the UI. To the left of those (not shown) is an instance of Vertical, which arranges the two Horizontals vertically. And to the left of that, also not shown, is an instance of MainWindow.</p>
</div>
<div class="paragraph">
<p>Each Horizontal has 3 instances of TextBox and one Text. The TextBoxs allow you to enter a string. The abstraction, Text, can only display a string. I see at this point, I hadn&#8217;t put in the TextBox for the description.</p>
</div>
<div class="paragraph">
<p>We can ignore the use of labels for a moment and just enter a formula containing constants into the first row TextBox. Let&#8217;s say we type in "2+1". The string "2+1" goes along the dataflow wire to the StringFormat instance on its port 0. The StringFormat is configured with the format string "({1}&#8658;{0})". StringFormat uses this format string in the same way as an interpolated string in C#. The {0} is substituted with the string coming in on port 0. The {1} is substituted with the string coming in on port 1. Since we have no string on port 1, the output from the StringFormat will be "()&#8658;2+1". This is simply a lambda expression with no parameters. This string is fed into the instance of Formula. Formula is an abstraction that knows how to evaluate a lambda expression. Actually it will accept just a formula string (such as "2+1") as well. We can ignore the other input of Formula for the moment. Formula will evaluate "()&#8658;2+1" and produce the number 3 on its output. This output is a dataflow of type double. This number is fed to an instance of NumberToString, and from there it goes to the instance of Text that knows how to display a string.</p>
</div>
<div class="paragraph">
<p>Now let&#8217;s follow the use of labels in the calculator. Let&#8217;s put the labels "a" and "b" into the TextBoxs for labels on the two rows. "a" and "b" are fed to the Concat instance. Concat&#8217;s input port can have any number of string dataflows wired into it. In this diagram it has only two. What Concat does is concatenate all its inputs adding a separator. In this case the separator is configured to be a comma. The output of the Concat is "a,b". The concatenated list of labels is fed into port 1 of both StringFormat instances.</p>
</div>
<div class="paragraph">
<p>Now let&#8217;s put the formula "a*3" into the 2nd row of the calculator. The output of the StringFormat for that row will be "(a,b)&#8658;a*3". That lambda expression will be fed to the Formula instance, which will evaluate it, using the value on its first input port for the value of 'a'. The output will appear on the corresponding Text in the 2nd row.</p>
</div>
<div class="paragraph">
<p>So that&#8217;s all there is to understanding how the calculator works. At this point it takes a leap of faith that the abstractions can all be made to work, and that the two programming paradigms used, the UI layout and the dataflow, can be made to work. Not withstanding that, all the information required in the design of the calculator is captured.</p>
</div>
<div class="paragraph">
<p>At this point I drew little drawings of all the invented abstractions. Actually I reused TextBox, Text, Vertical, Horizontal and FormatString from a previous project. And I had already made the UI and dataflow programming paradigm interfaces in previous projects, so I reused them as well.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/CalculatorDomainAbstractionsHandDrawings.png" alt="CalculatorDomainAbstractionsHandDrawings.png" width="300">
</div>
<div class="title">Figure 21. Calculator Domain Abstractions</div>
</div>
<div class="paragraph">
<p>I see I forgot to draw Concat. I had to write that one. Here is its template as it was in my Xmind templates diagram.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/CalculatorStringConcatTemplate.png" alt="CalculatorStringConcatTemplate.png" width="400">
</div>
<div class="title">Figure 22. StringConcat template</div>
</div>
<div class="paragraph">
<p>The two ports are both drawn on the right hand side unfortunately - a limitation of using Xmind as the drawing tool. Drawing the templates makes the abstractions clearer for their implementation.</p>
</div>
</div>
<div class="sect3">
<h4 id="trueimplementing-the-domain-abstractions"><a class="anchor" href="#trueimplementing-the-domain-abstractions"></a>2.8.2. Implementing the domain abstractions</h4>
<div class="paragraph">
<p>Abstractions are generally trivial to implement because they are zero coupled with anything. They are like tiny stand-alone programs. Here is the full code for StringConcat.</p>
</div>
<div class="listingblock">
<div class="title">SringConcat.cs</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">using ProgrammingParadigms;
using System;
using System.Collections.Generic;
using System.Linq;

namespace DomainAbstractions
{
    /// &lt;summary&gt;
    /// Outputs the input strings concatenated together
    /// Whenever an input strings changes, a new output is pushed.
    /// ---------------------------------------------------------------------------------------------------------
    /// Ports:
    /// 1. List&lt;IDataFlowB&lt;string&gt;&gt; inputs: inputs (indefinite number of string inputs)
    /// 2. IDataFlow&lt;string&gt; output: output
    /// &lt;/summary&gt;



    public class StringConcat
    {
        // Properties ---------------------------------------------------------------
        public string InstanceName { get; set; } = "Default";
        public string Separator { private get; set; } = "";

        // Ports ---------------------------------------------------------------
        private List&lt;IDataFlowB&lt;string&gt;&gt; inputs;
        private IDataFlow&lt;string&gt; output;


        /// &lt;summary&gt;
        /// Outputs a boolean value of true when all of its inputs are true. Null inputs are treated as false.
        /// &lt;/summary&gt;
        public StringConcat() { }

        // This function is called immediately after each time the inputs port is wired to something
        private void inputsPostWiringInitialize()
        {
            inputs.Last().DataChanged += () =&gt;
            {
                var result = "";
                bool first = true;
                foreach (IDataFlowB&lt;string&gt; input in inputs)
                {
                    if (!first) result += Separator;
                    first = false;
                    result += input.Data;
                }
                output.Data = result;
            };
        }

    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The code in Concat is straightforward if you know C#, except for a few conventions which are to do with the use of ALA (which I was already proficient with):</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>We put a property "InstanceName" in every domain abstraction. It&#8217;s not required, but the reason is because abstractions get reused. So you are likely to end up with multiple instances of an abstraction all over your application. If you name the instances, it makes debugging a lot easier because you can see it in the debugger and know which instance you are in.</p>
</li>
<li>
<p>All the IO for the abstraction is in a section called "Ports". Usually an abstraction would have some ports that are private fields of the type of an interface, and some that are an implemented interface. It just so happens that StringConcat has no implemented interface ports.</p>
</li>
<li>
<p>The two ports are private, and yet they get wired by the application code to other objects. This may seem a little bit magic. The reason they are private is to indicate they are not for use by anything else. The application will use a method called WireTo() to achieve the wiring. WireTo is an extension method on all objects. It uses reflection to find and assign to these "port" fields.</p>
</li>
<li>
<p>Notice that the "inputs" port uses IDataFlowB (not IDataflow). The B on IDataflowB indicates a tricky workaround for a limitation in the C# language. What we would have liked to do is implement IDatFlow. But we would have needed to implement IDataFlow multiple times. You can&#8217;t do that in C# (although there is no reason why not in theory, and hopefully all languages will have this feature to support the concept of ports one day).</p>
</li>
<li>
<p>Notice that the method, inputsPostWiringInitialize, is private and apparently unused. When the WireTo operation wires a port "xyz" it looks for a private method called xyzPostWiringInitialze and invokes it immediately. This gives us the opportunity to set up handlers on any events that may be in the interface. In this case, the IDataFlowB interface has a DataChanged event (that tells us when there is new data on the inputs).</p>
</li>
<li>
<p>It doesn&#8217;t make sense to use a StringConcat without wiring its output to something. So the line "output.Data = result" will throw an exception if the application has not wired it. Often times, abstractions have ports that are optional to wire, in which case we would use "outputs?.Data = result"</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>For reference, here is the IDataFlow interface, which lives in the ProgrammingParadigms folder, and is used by most of the domain abstractions including the StringConcat abstraction:</p>
</div>
<div class="listingblock">
<div class="title">IDataFlow.cs</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">namespace ProgrammingParadigms
{
    public interface IDataFlow&lt;T&gt;
    {
        T Data { get; set; }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see, this interface is simple, but its importance in giving us a dataflow programming paradigm is huge. It allows objects to be wired together so that data can flow from object to object without the abstractions knowing anything about each other. Note that IDataflow uses a 'push' execution model. This means that the source always initiates the transfer of data on its output (by using 'set'). The IDataFlowB interface is a little more complicated, so we wont go into how it works just now. But it achieves exactly the same purpose of the dataflow programming paradigm, just in a different way that allows more than one input port of the same type. .</p>
</div>
<div class="paragraph">
<p>The other domain abstraction I needed to write for the first time was Formula. Here is the template as used in Xmind:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/CalculatorFormulaTemplate.png" alt="CalculatorFormulaTemplate.png" width="500">
</div>
<div class="title">Figure 23. Formula template</div>
</div>
<div class="paragraph">
<p>Once again, one of the input ports is shown on the right when we would prefer it to be on left.</p>
</div>
<div class="paragraph">
<p>Formula can be configured with an optional C# lambda expression when it is instantiated by the application, for example:</p>
</div>
<div class="listingblock">
<div class="title">Application.cs</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">new Formula() {Lambda = (x,y) =&gt; x+y; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>If used in this way, the formula is fixed at design-time. But its real power comes from the fact that it can take a formula as a string at run-time. Formula has an input dataflow port called "formula".</p>
</div>
<div class="paragraph">
<p>The Formula abstraction has to parse the formula string and then evaluate it. I used Roslyn to do this in a few lines of code. These lines of code took me a few hours to figure out however:</p>
</div>
<div class="listingblock">
<div class="title">Formula.cs</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">using Microsoft.CodeAnalysis.CSharp.Scripting;
using Microsoft.CodeAnalysis.Scripting;
using static System.Math;

namespace DomainAbstractions
{
    using LambdaType = Func&lt;double, double, double, double, double, double, double&gt;;

    public class Formula
    {
        public LambdaType Lambda { private get; set; }


        // Other code omitted from here


        private async void Compile(string formula)
        {
            var options = ScriptOptions.Default;
            options = options.AddImports("System.Math");
            try
            {
                Lambda = await CSharpScript.EvaluateAsync&lt;LambdaType&gt;(formula, options);
            }
            catch (CompilationErrorException e)
            {
                Lambda = null;
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see, currently the Formula abstraction can only handle formulas that use a maximum of six parameters. The calculator application can use any number - it&#8217;s just that any one formula is limited to using only six.</p>
</div>
<div class="paragraph">
<p>The rest of the code in the Formula abstraction is mostly dealing with this requirement of exactly six parameters used by LambdaType. But that&#8217;s all internal to the abstraction. An instance of the Formula abstraction can handle any number of operands from zero to many. The Formula abstraction is also tolerant of the string on the formula input port being either just a formula such as "2*(3+1)" (implying it&#8217;s not using any operand inputs), or a proper lambda expression such as "(x,y,z)&#8658;x*(y+z).</p>
</div>
<div class="paragraph">
<p>Now that we have our needed domain abstractions, let&#8217;s return to the application layer, and see if we can get this calculator running.</p>
</div>
</div>
<div class="sect3">
<h4 id="truehand-wiring-the-application-code-from-the-diagram"><a class="anchor" href="#truehand-wiring-the-application-code-from-the-diagram"></a>2.8.3. Hand wiring the application code from the diagram</h4>
<div class="paragraph">
<p>First here is the startup code for a wired ALA application. It is very simple:</p>
</div>
<div class="listingblock">
<div class="title">Application.cs</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">namespace Application
{
    public class Application
    {
        private MainWindow mainWindow;

        [STAThread]
        public static void Main()
        {
            Application app = new Application();
            app.mainWindow.Run();
        }

        private Application()
        {
            // mainWindow = WireHelloWorld();
            mainWindow = Calculator2RowHandWired();
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here is an ALA Hello World application</p>
</div>
<div class="listingblock">
<div class="title">Application.cs</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">private MainWindow WireHelloWorld()
{
    return new MainWindow().WireTo(new Text("Hello World"));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ok, now we are ready to hand wire the hand drawn calculator diagram shown above:</p>
</div>
<div class="listingblock">
<div class="title">Application.cs</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">private MainWindow Calculator2RowHandWired()
{
    // To understand this code, you need the wiring diagram of the two row calculator

    // First instantiate instances of abstractions we need to give names to. The rest can be anonymous.
    StringConcat stringConcat = new StringConcat() { Separator = "," };
    DataFlowConnector&lt;string&gt; stringConcatConnector = new DataFlowConnector&lt;string&gt;(); // Connectors are needed when there is fan-out or fan-in in the diagram
    stringConcat.WireTo(stringConcatConnector, "output");
    Formula[] formulas = { new Formula(), new Formula() }; // instantiate both the formulas up-front because we need to cross wire them


    MainWindow mainWindow = new MainWindow("Calculator")
        .WireTo(new Vertical()
            .WireTo(WireRow(stringConcat, stringConcatConnector, formulas[0], formulas))
            .WireTo(WireRow(stringConcat, stringConcatConnector, formulas[1], formulas))
            );
    return mainWindow;
}


private Horizontal WireRow(StringConcat stringConcat, DataFlowConnector&lt;string&gt; stringConcatConnector, Formula formula, Formula[] formulas)
{
    // To understand this code, you need the wiring diagram of the two row calculator

    // first instantiate objects we need to give names to.  The rest can be anonymous.
    Text result = new Text();

    // Wire up a calculator row
    Horizontal row = new Horizontal()
        .WireTo(new TextBox()
            .WireTo(new DataFlowConnector&lt;string&gt;()
                .WireFrom(stringConcat, "inputs")
            )
        )
        .WireTo(new TextBox()
            .WireTo(new StringFormat&lt;string&gt;("({1})=&gt;{0}")
                .WireTo(stringConcatConnector, "inputs")
                .WireTo(formula
                    .WireTo(new DataFlowConnector&lt;double&gt;()
                        .WireFrom(formulas[0], "operands")
                        .WireFrom(formulas[1], "operands")
                        .WireTo(new NumberToString()
                            .WireTo(result)
                        )
                    )
                )
            )
        )
        .WireTo(result)
        .WireTo(new TextBox());
    return row;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Commentary on this wiring code</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The code is written in "fluent style". This is possible because the WireTo extension method returns its 'this' parameter, allowing you to use .WireTo() multiple times on an instance.</p>
</li>
<li>
<p>The parts of the diagram that have a tree structure can be wired by using more .WireTos immediately inside the brackets of another WireTo. This is what causes the indented code.</p>
</li>
<li>
<p>The previous two points allow much of the wiring to be done without having to think up names for the instances. The instances are anonymous just as they were on the diagram.</p>
</li>
<li>
<p>Where the diagram has cross wires that formed a cycle, we need to give instances names so that we can complete all the wiring to them.</p>
</li>
<li>
<p>Sometimes the WireTo method is given the port name of the first object. These are used when WireTo may get the wrong port if it were left to use the port types alone. (If an abstraction has multiple ports of the same type, WireTo doesn&#8217;t know which port to use.)</p>
</li>
<li>
<p>Most abstractions have ports that can only be wired to one place, and ports that can only be wired from one place. (The UI abstractions are exceptions, for example, Horizontal can be wired to multiple children.) The hand drawn wiring diagram has several places where the wiring either 'fans out' from a port or 'fans in' to a port. Unfortunately C# does not support the concept of ports, so we improvise to make them work in normal C# code. The way this improvisation works for fan-in and fan-out is to use a connector.</p>
<div class="ulist">
<ul>
<li>
<p>For fan-out you wire the output port to a new Connector. Then you can wire the connector to multiple places.</p>
</li>
<li>
<p>For fan-in, the abstraction, instead of implementing the port, uses a list field of a type like IDataFlowB. The 'B" on the end means the flow of data is reversed from IDataFlow. Now to wire such an inputs port to an output port also requires a connector (a second use for connectors). When wiring an IDataFlowB, you wire from the input to the connector (the opposite way to the direction of dataflow unfortunately).</p>
</li>
</ul>
</div>
</li>
<li>
<p>As a convenience, you can use WireFrom. It reverses the two operands being wired compared to WireTo.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Handwritten wiring code like the above can be managed for small applications. It is easy to get it wrong though. The code is not readable from the point of view of understanding the application. That&#8217;s what the diagram is for. So every time you make a change to the requirements, you need to do it on the diagram first, then update the hand-generated code. You are still better off doing this than not using ALA. If not using ALA, the relationships of the cohesive, explicit ALA diagram still exist, but they become obscurred and distributed inside your modules.</p>
</div>
<div class="paragraph">
<p>But we don&#8217;t have to hand generate code. At the time of writing a hand written graphical IDE is under development.</p>
</div>
<div class="paragraph">
<p>Here is the calculator row part of the diagram, which was successfully used to auto-generate code:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/CalculatorRow-GALADE.png" alt="CalculatorRow-GALADE.png" width="800">
</div>
<div class="title">Figure 24. CalculatorRow abstraction internal wiring</div>
</div>
<div class="paragraph">
<p>Before we had that tool, we used Xmind to do diagrams from which we could generated code. This is the approach described in the next section.</p>
</div>
</div>
<div class="sect3">
<h4 id="trueautomatic-code-generation-from-the-diagram"><a class="anchor" href="#trueautomatic-code-generation-from-the-diagram"></a>2.8.4. Automatic code generation from the diagram</h4>
<div class="paragraph">
<p>Here is the diagram of the 2-row calculator as it was originally entered into Xmind. You can click on the image to get a bigger version.</p>
</div>
<div class="imageblock">
<div class="content">
<a class="image" href="images/Calculator2Rows.png"><img src="images/Calculator2Rows.png" alt="Calculator2Rows.png" width="1000"></a>
</div>
<div class="title">Figure 25. Calculator drawn in Xmind (two rows version)</div>
</div>
<div class="paragraph">
<p>Xmind is not the perfect tool to do this, but it has one huge advantage - it lays itself out. This is so important that it&#8217;s why we use it (until our new tool is ready). We will put up with the disadvantages, and the necessary conventions until then. Those conventions are documented in the wiki section of the project in Github here: <a href="https://github.com/johnspray74/ReactiveCalculator/wiki">https://github.com/johnspray74/ReactiveCalculator/wiki</a></p>
</div>
<div class="paragraph">
<p>Entering the hand-drawn version of the diagram is a simple matter of copying and pasting the Xmind templates for the abstractions to the right place in the diagram. This connects most of the needed wiring from port to port. Xmind supports tree structured diagrams, so any cross tree wiring was done by using the red lines, which are quick to put in with a shortcut key.</p>
</div>
<div class="paragraph">
<p>The Xmind version of the diagram is pretty much identical to the hand drawn version. The colored boxes are instances of abstractions. All the other nodes attached around those colored boxes are the ports. The &lt; and &gt; signs in the ports are significant, and tell the automatic code generator which way to wire the instances. The asterisks are also significant, and tell the code generator that many wires can be wired to the one port.</p>
</div>
<div class="paragraph">
<p>The diagram done, it&#8217;s time to generate the code. A tool called XmindParser does this. It can be downloaded from the Github project main page. Here is the tool in use to generate a calculator from the diagram.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/CalculatorXmindParserTool.png" alt="CalculatorXmindParserTool.png" width="800">
</div>
<div class="title">Figure 26. XmindParser tool in use</div>
</div>
<div class="paragraph">
<p>The tool can put the generated code into your Application.cs file if you give it special markers like the one below.</p>
</div>
<div class="listingblock">
<div class="title">Application.cs</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">private void Calculator2Rows()
{
    // BEGIN AUTO-GENERATED INSTANTIATIONS FOR Calculator2Rows.xmind
    // END AUTO-GENERATED INSTANTIATIONS FOR Calculator2Rows.xmind

    // BEGIN AUTO-GENERATED WIRING FOR Calculator2Rows.xmind
    // END AUTO-GENERATED WIRING FOR Calculator2Rows.xmind
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The markers contain the name of the Xmind diagram they get code from. This allows several diagrams to be used for one application.</p>
</div>
<div class="paragraph">
<p>I usually put the markers inside a function so that all the instantiated objects are private to the function.</p>
</div>
<div class="paragraph">
<p>Here is the code again with three lines of generated code shown in each section.</p>
</div>
<div class="listingblock">
<div class="title">Application.cs</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">private void Calculator2Rows()
{
    // BEGIN AUTO-GENERATED INSTANTIATIONS FOR Calculator2Rows.xmind
    Formula Formula1 = new Formula() { InstanceName = "Formula1" };
    Formula Formula2 = new Formula() { InstanceName = "Formula2" };
    Horizontal id_24914ab245484fe1b70af8020ca2e831 = new Horizontal() { InstanceName = "Default" };
    // END AUTO-GENERATED INSTANTIATIONS FOR Calculator2Rows.xmind

    // BEGIN AUTO-GENERATED WIRING FOR Calculator2Rows.xmind
    mainWindow.WireTo(id_b02d2caea938499b997b9bfcb80fb0e9, "iuiStructure");
    id_b02d2caea938499b997b9bfcb80fb0e9.WireTo(id_24914ab245484fe1b70af8020ca2e831, "children");
    Formula1.WireTo(dfc1, "result");
    // END AUTO-GENERATED WIRING FOR Calculator2Rows.xmind

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Completing the diagram had taken another morning of work. But the calculator was now working and I was ready for the workshop.</p>
</div>
<div class="paragraph">
<p>I made a diagram with six rows, but it was getting pretty large, and the duplication was pretty clumsy.</p>
</div>
</div>
<div class="sect3">
<h4 id="truecalculator-with-10-rows"><a class="anchor" href="#truecalculator-with-10-rows"></a>2.8.5. Calculator with 10 rows</h4>
<div class="paragraph">
<p>The 6-row calculator is powerful compared to any normal calculator, but still wouldn&#8217;t do jobs like the one shown here which has 11 rows:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/CalculatorNRowsScreenshot.png" alt="CalculatorNRowsScreenshot.png" width="800">
</div>
<div class="title">Figure 27. Later version of the calculator to support an unlimited number of rows</div>
</div>
<div class="paragraph">
<p>So it was time to do some maintenance, and solve that problem of the repetition in the diagram at the same time. During this maintenance, none of the existing abstractions changed. Their ports stayed the same. Their internals were improved a little in some cases but nothing significant. Formula was modified internally so that it could handle more than six operand inputs, although any one formula can still only use six of them.</p>
</div>
<div class="paragraph">
<p>There were two major changes though. One was to put the repeated wiring for a calculator row inside its own abstraction. This abstraction is called "CalculatorRow". This abstraction is less abstract than the Domain abstractions it uses, but more abstract than the application, which will use it multiple times. Other version of the calculator alos reused it. So it goes into its own layer between the two. This new layer is called "Requirements Abstractions". We don&#8217;t make new layers lightly, but we had had the experience in a larger project that the diagram got too large. We needed to factor out some of it as 'Feature level abstractions'. These abstractions needed a new layer between the Application layer and the Domain abstractions layer. So I was reasonably happy to make use of this new layer in the calculator to reduce a now quite large diagram.</p>
</div>
<div class="paragraph">
<p>Here is the Xmind template for the CalculatorRow abstraction showing its ports:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/CalculatorRowTemplate.png" alt="CalculatorRowTemplate.png" width="800">
</div>
<div class="title">Figure 28. CalculatorRow abstraction</div>
</div>
<div class="paragraph">
<p>The implementation of CalculatorRow was done with a diagram using the new Graphical ALA tool which was shown earlier.</p>
</div>
<div class="paragraph">
<p>When you implement an abstraction by an internal diagram, there needs to be some extra code to wire from the ports (shown in the template above) to the internal wiring. I found this code quite tricky the first time and it took me a while. But there is a pattern to it. The new tool will be able to automatically generate this code as well, but for now I did it by hand.</p>
</div>
<div class="paragraph">
<p>I tested the completed CalculatorRow abstraction by making an application that uses it twice:</p>
</div>
<div class="imageblock">
<div class="content">
<a class="image" href="images/Calculator2ARows.png"><img src="images/Calculator2ARows.png" alt="Calculator2ARows.png" width="1000"></a>
</div>
<div class="title">Figure 29. Calculator drawn in Xmind using the new CalculatorRow requirements abstraction</div>
</div>
<div class="paragraph">
<p>Because this test calculator has only two rows we can directly compare it with the 2-row calculator above and see how the two rows are now represented by two instances of this new CalculatorRow abstraction. However we are still not there to building a calculator with 10 rows. If we were to instantiate CalculatorRow 10 times, it would need 100 wirings in Xmind to connect all ten results to every CalculatorRow&#8217;s operands input. Having thought the 36 wirings of the 6 row calculator was nuts, there was no way I was going to do 100 of them by hand.</p>
</div>
<div class="paragraph">
<p>So the next step was to invent a domain abstraction called 'Multiple'.</p>
</div>
<div class="paragraph">
<p>What 'Multiple' does is you instantiate it in your application and configure it with the number you want. In this case N:10. Multiple has a port called factory which uses a new interface called IFactory. Then what you do is add a small Factory class inside any abstraction that you want multiple instances of. In this case we want multiple instances of CalculatorRow, so I added a small class to that abstraction called CalculatorRowFactory. CalculatorRowFactory implements IFactory (which resides in the Programming Paradigms layer). Multiple can now create many instances of the abstraction that is wired to it. But these instances now have to be wired into the rest of the wiring in the application diagram as needed. To accomplish that, multiple is configured with two methods. These methods, which are part of the application, know how to wire the new instances into the rest of the wiring.</p>
</div>
<div class="paragraph">
<p>Here is the Xmind template for Multiple:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/CalculatorMultipleTemplate.png" alt="CalculatorMultipleTemplate.png" width="500">
</div>
<div class="title">Figure 30. CalculatorRow requirements abstraction</div>
</div>
<div class="paragraph">
<p>Using the new Multiple abstraction, we can now build a 10-row calculator. Here is the new diagram:</p>
</div>
<div class="imageblock">
<div class="content">
<a class="image" href="images/Calculator10Rows.png"><img src="images/Calculator10Rows.png" alt="Calculator10Rows.png" width="1000"></a>
</div>
<div class="title">Figure 31. Calculator drawn in Xmind using the new Multiple domain abstraction to create as many rows as we like</div>
</div>
<div class="paragraph">
<p>You can see inside the instance of Multiple that it is configured to make 10 of whatever is attached to its factory port. The CalculatorRow abstraction is shown next to the CalculatorRowFactory so you can see what it makes. You can see inside Multiple the two methods that Multiple calls when it makes a new instance. These methods are used to wire the CalculatorRow into the rest of the application wiring.</p>
</div>
<div class="paragraph">
<p>Getting to this point had taken another two Saturday mornings of work. It was mainly spent on thinking out the patterns for how the internal wiring inside CalculatorRow should get wired to CalculatorRows own border ports. Also in the initial attempt I had allowed temporal coupling to creep in between abstractions. It mattered whether the application wiring was done first. And if you let coupling creep in bugs will happen. The temporal coupling was resolved by making CalculatorRow not care whether or not the external wiring is done when it is instantiated.</p>
</div>
</div>
<div class="sect3">
<h4 id="truecalculator-with-n-rows"><a class="anchor" href="#truecalculator-with-n-rows"></a>2.8.6. Calculator with N rows</h4>
<div class="paragraph">
<p>Wouldn&#8217;t it be cool if the calculator started with say 4 rows, and had a button for adding additional rows? You will notice that the Multiple abstraction template above has a port called addRow. It takes an IEvent. If it receives an event on that port at run-time, it will create another row and call the lambda wiring functions to get that row wired in.</p>
</div>
<div class="paragraph">
<p>Here is the calculator with the button added to the UI. This is the calculator from which the screen shot shown above was taken.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/CalculatorNRows.png" alt="CalculatorNRows.png" width="800">
</div>
<div class="title">Figure 32. Later version of the calculator to support an unlimited number of rows</div>
</div>
<div class="paragraph">
<p>I wanted the Button to be at the bottom, so I added another instance of Vertical to act as the wiring point for new row to be attached to the UI. The output of the Button is another programming paradigm interface called an IEvent.</p>
</div>
<div class="paragraph">
<p>Here is the source code of IEvent:</p>
</div>
<div class="listingblock">
<div class="title">IEvent.cs</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">namespace ProgrammingParadigms
{
    public interface IEvent
    {
        void Execute();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Again, considering that this interface enables a whole programming paradigm, it is extremely simple and abstract, consisting of only a synchronous function call. It allows any objects that can produce events to be wired to any object that can receive an event. In the CalculatorNRows example, it allows a Button to be Wired to a Multiple. When the Button is pressed, Multiple creates a new row.</p>
</div>
<div class="paragraph">
<p>There is one major Programming Paradigm that we have not explained yet. It is the one that allows UI instances to be wired together. The meaning of wiring two UI objects together is that one contains the other. Here is the IUI interface that implements this programming paradigm.</p>
</div>
<div class="listingblock">
<div class="title">IUI.cs</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">using System.Windows;

namespace ProgrammingParadigms
{
    public interface IUI
    {
        UIElement GetWPFElement();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The interface simply allows a containing UI instance to get the WPF (Windows Presentation Foundation) element from the contained UI instance it is wired to.</p>
</div>
<div class="paragraph">
<p>Making Multiple able to add rows to the calculator at runtime took yet another Saturday morning. But it was worth it to solve the challenge of learning how to change the wiring at run-time. The wiring diagram now statically describes how it dynamically changes itself.</p>
</div>
<div class="paragraph">
<p>That concludes the story of the development of the calculator using ALA. The full source code, and all the diagrams for every version along the way are in the Github project at
<a href="https://github.com/johnspray74/ReactiveCalculator">https://github.com/johnspray74/ReactiveCalculator</a></p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="truechapter-three-why-the-structure-works"><a class="anchor" href="#truechapter-three-why-the-structure-works"></a>3. Chapter three - Why the structure works</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In the previous chapter we described what the structure, the anatomy, of ALA looks like as if we were dissecting a dead body. We see where things are but we don&#8217;t yet understand why they are there. In this chapter we explain why that structure works. Why does this way of organising code result in software that meets those non-functional requirements we listed in Chapter one?</p>
</div>
<div class="sect2">
<h3 id="truea-thought-experiment"><a class="anchor" href="#truea-thought-experiment"></a>3.1. A thought experiment</h3>
<div class="paragraph">
<p>Imagine you are reading the following function, abc123, and trying to understand it:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>float abc123(float[])
{
    ...
    b = xyz789(a)
    ...
}</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>float xyz789(float)
{
    ....
    // complicated code
    ....
}</pre>
</div>
</div>
<div class="paragraph">
<p>You don&#8217;t know what xyz789 is. It may as well be called fubar (fubar stands for messed up beyond all recognition), so you follow the indirection, an inconvenience at the least because you are really just wanting to understand abc123. You have to mentally stack where you were in abc123, including everything you understand about it so far.</p>
</div>
<div class="paragraph">
<p>You begin reading the code at xyz789. It only has about 20 lines but it is complicated. You need to use the code in abc123 to try to unravel what need xyz789 might be proiding to it. A comment mentions that it uses a CORDIC algorithm and gives a reference. But before following that indirection as well, you note that both abc123 and xyz789 have the following properties:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>modules</p>
</li>
<li>
<p>apparently loosly coupled</p>
</li>
<li>
<p>have a simple interface</p>
</li>
<li>
<p>encapsulated</p>
</li>
<li>
<p>use no external variables</p>
</li>
<li>
<p>have no side effects</p>
</li>
<li>
<p>hide information</p>
</li>
<li>
<p>probably separate two concerns</p>
</li>
<li>
<p>is small</p>
</li>
<li>
<p>follows coding guidelines</p>
</li>
<li>
<p>have comments</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Despite having all these great properties that we are all taught, still we are forced to read both functions to understand the code in either of them. They are effectively fully coupled - understanding any of the code involves understanding all of the code.</p>
</div>
<div class="paragraph">
<p>Now we make a small change:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>float StandardDeviation(float[])
{
    ...
    b = Sqrt(a)
    ...
}</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>float Sqrt(float)
{
    // complicated code
}</pre>
</div>
</div>
<div class="paragraph">
<p>Suddenly understandability is absolutely transformed. All we did was make the two functions abstrations.</p>
</div>
<div class="paragraph">
<p>All those other attributes that we listed above seemingly made no difference. The quality attribute that really mattered was abstraction. The others are still good to have, but they are insufficient. The abstraction property is the only one that our brains are designed for. The quality of abstraction is subjective. Software engineers must invent good quality abstractions. No compiler or tool can yet check that quality, although, as Robert Martin points out, the number of reuses of an abstraction can be used as a indicator.</p>
</div>
<div class="paragraph">
<p>The code inside each of the two functions goes from fully coupled to zero coupled.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>In the downward direction, coupling goes to zero because the standard deviation function need only know the concept of the squareroot abstraction, not the code inside the squareroot abstraction.</p>
</li>
<li>
<p>In the upward direction, coupling goes to zero because squareroot is more abstract and therefore can&#8217;t know anything about the more specific Standard deviation abstraction that happens to use it.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>There are other benefits too:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Abstraction and stability go hand in hand. The Sqrt abstraction is as stable as the concept of squareroot. That&#8217;s a concept that&#8217;s been stable for thosands of years. All dependencies in an ALA program go in the direction of the more stable.</p>
</li>
<li>
<p>Abstraction and reuse go hand in hand (as pointed out by Krueger). The more abstract an abstraction is the more reusable. Code reuse in ALA programs increases markedly.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The complicated code inside SQRT no longer matters. It is completely isolated by the abstraction. If your brain already knows the SQRT concept (I had to choose one that everyone knows), there is no need to follow the indirection when reading the code inside StandardDeviation. The reader just continues reading the next line of code after the Sqrt invocation as if Sqrt is just like any other line of code in their base language. That&#8217;s what abstraction is.</p>
</div>
<div class="paragraph">
<p>With this new understanding, we will now define the word dependency to be compile-time relationships, and coupling to be the design-time or understanding-time relationships. One is what the compiler sees, the other is what our brain sees.</p>
</div>
<div class="paragraph">
<p>Using these definitions, you can have coupling without dependencies (sometimes called implicit coupling). The reverse is also true - it is possible to have dependencies without coupling. ALA makes use of this by simply making a constraint all dependencies must be on abstractions. When you do that, every artefact (abstraction) in the program is zero-coupled with every other.</p>
</div>
<div class="paragraph">
<p>Doing this isn&#8217;t always easy because unfortunately there are many established architectural methods, patterns and styles that break this constraint. On the other hand, applying this constrain emerges some patterns that we will immediately recognise. DSLs and dependency injection are two examples. We will also emerge some less well known ones that are none-the-less not novel. There already exists an "abstract interactions" pattern, for example.</p>
</div>
<div class="paragraph">
<p>There are two situations that commonly cause coupling in conventional code:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>In the above example, if xyz789 is just a source or destination for messages, then abc123 cannot be an abstraction because it cannot be reused without dragging xyz789 with it. abc123, as an abstraction, doesn&#8217;t care where the data comes from or goes to. To fix this, xyz789 must be passed into abc123 by something else above both of them. This can be passing in a function, passing in an object (dependency injection), or other mechanism such as the WireTo operator that we will use a lot in our ALA example projects.</p>
<div class="paragraph">
<p>A benefit over and above the zero coupling is that the dataflow relationship between abc123 and xyz789 used to be hidden inside abc123. In ALA that relationship has to be an explicit line of code (inside another abstraction above) that wires together two instances. There, it will be cohesive with other similar relationships that work together in a collaborative way to make the application.</p>
</div>
<div class="paragraph">
<p>Often these collected together wirings form a graph, making diagrams rather than code an even better way to describe the application.</p>
</div>
</li>
<li>
<p>If xyz789 provides a part of the implementation of abc123 such that it is specific to abc123, then xyz789 is more specific than abc123. Sometimes such a function or class is called a helper or submodule. This is because abc123 could be reused many times, whereas xyz789 could only ever be used once (only by abc123). xyz789 needs to be more abstract than abc123 or it will be coupled to it.</p>
<div class="paragraph">
<p>This is contrary to what we are taught. We are taught to "divide and conquer" or to separate out the responsibilities in abc123. If we do this arbitrarily, we will end up with specific pieces (such as UI and business logic) which are highly coupled with each other, and with the specific application. We need to work hard to separate only by finding abstractions - potentially reusable artefacts. Then we configure instances of those abstractions for each specific use by passing the application specific details into them.</p>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>In summary, ALA&#8217;s starting premise is a constraint. The constraint is that you can only use one type of dependency - a dependency on an abstraction that is more abstract. This results in zero coupling throughout the abstractions of the entire program.</p>
</div>
<div class="paragraph">
<p>The rest of this chapter expands on the points we mentioned briefly in this first section.</p>
</div>
</div>
<div class="sect2">
<h3 id="trueabstraction-as-design-time-encapsulation"><a class="anchor" href="#trueabstraction-as-design-time-encapsulation"></a>3.2. Abstraction as design-time encapsulation</h3>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p><span class="green"><strong>Abstractions</strong></span> are the human brain&#8217;s version of <span class="green"><strong>encapsulation</strong></span>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The maintainability quality attribute is often thought of in terms of ripple effects of change. I don&#8217;t think that is quite the right way to look at it. I have often had to make changes across a number of modules in poorly written code. The changes themselves just don&#8217;t take that long. The problem I see is the time you have to spend understanding enough of the system to know where to make a change, even if it is one line of code. To make that small change with confidence that it wont break anything can take a long ime. The problem is coupling. Even if the change is one line of code (which it often is), you may have had to understand a lot of code to figure that out. You have to understand all the code that is potentially coupled to that one line of code, which is essentially the complexity.</p>
</div>
<div class="paragraph">
<p>Unlike modules or encapsulation, abstractions contain and hide complexity at design-time. They give boundaries to how far you have to read code to understand it.</p>
</div>
<div class="sect3">
<h4 id="trueabstractions-and-instances"><a class="anchor" href="#trueabstractions-and-instances"></a>3.2.1. Abstractions and Instances</h4>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p><span class="green"><strong>Software architecture</strong></span> should contain <span class="green"><strong>two concepts</strong></span> for its <span class="green"><strong>elements</strong></span>  equivalent to <span class="green"><strong>abstractions</strong></span> and <span class="green"><strong>instances</strong></span>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>ALA makes abstraction and instances fundamental.</p>
</div>
<div class="paragraph">
<p>Abstractions are separate, zero coupled, design-time elements. Abstractions, therefore, cannot exchange data themselves. The concept of instances must be added. An instances is nothing more than the use of an abstraction by referring to its name.</p>
</div>
<div class="paragraph">
<p>Object oriented programming has these two concepts as classes and objects. Functional programming has the two concepts in terms of the function definition and the function invocation. But many discussions on software architecture seem to combine them into one term, such as modules, components or layers. They may implicitly contain the separate concepts, as components may, but not having them explicit will inevitably lead to confusion.</p>
</div>
<div class="paragraph">
<p>The problem is that when we become vague about the difference, we will create dependencies between the abstractions, such as to get or put data, that should just be using two instances in a line of code somewhere. Adding dependencies between abstractions destroy them as abstractions. Composing two Instances of abstractions does not. If we don&#8217;t have two separate and clear terms for abstractions and instances, we will end up with no abstractions.</p>
</div>
<div class="paragraph">
<p>Nearly all architectural styles have this problem. For example, in layering, we put 'modules' into layers and then create unnecessary dependencies to move data between them. No, put abstractions into one layer. Then compose instances of them inside a new abstraction in the layer above.</p>
</div>
<div class="paragraph">
<p>Another common example of the problem is the UML, which already has the separate concepts of objects and classes. But we tend to ignore objects and create associations between classes instead. The most important idea that OOP brought us was the idea of classes and objects. It has been ruined by the UML class diagram. Instead of associations between classes, instantiate objects and wire them together. Do that completely inside another class in the layer above.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>The quality of an abstraction&#8217;s <em>concept</em> or <em>idea</em> is important. It is the existence of the concept that allows the brain to learn it and not have to know how it&#8217;s implemented each time it comes across it. It is the stability of the idea of the abstraction that blocks coupling. ALA requires effort to conceive good abstractions, especially for the first application in a new domain.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="truezero-coupling-and-higher-cohesion"><a class="anchor" href="#truezero-coupling-and-higher-cohesion"></a>3.3. Zero coupling and higher cohesion</h3>
<div class="paragraph">
<p>ALA has zero coupling between the code inside (or the code that implements) all abstractions. This is the case both horizontally between peers in the same layer, and vertically up or down the layers.</p>
</div>
<div class="paragraph">
<p>In software design we are only interested in design-time coupling. This means that to understand one piece of code, how much do we need to understand other pieces of code? This is the coupling that matters. We will use the word coupling to refer to design-time coupling.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>Wikipedia defines coupling as "the degree of interdependence between software modules". It doesn&#8217;t really distinguish between design-time, compile-time or run-time coupling, and the given formula for coupling seems to reflect compile-time. We prefer to think of coupling as a design-time property. The use of abstractions instead of modules changes the way we should think about coupling.</p>
</div>
<div class="paragraph">
<p>Consider the principle of compositionality. As stated in Wikipedia, "In semantics, mathematical logic and related disciplines, the principle of compositionality is the principle that the meaning of a complex expression is determined by the meanings of its constituent expressions and the rules used to combine them."</p>
</div>
<div class="paragraph">
<p>In ALA we use abstractions as the 'constituent expressions', and we have the objective that all code conforms to the principle of compositionality. We then define coupling as anything that compromises this principle.</p>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p><span class="green"><strong>To understand any one part of the code should involve understanding only that one part of the code, and the abstractions it uses.</strong></span></p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Unfortunately there is a meme in the software engineering industry that there must be some coupling between 'modules'. The argument goes that if the system is to do anything it must have some coupling between its parts in order to do anything. We therefore hear of "loose coupling" as being the ideal. Using the definition of coupling given above, this is completely incorrect. Because of this meme, in conventional code  we are settling for design-time coupling to achieve connections between different parts of a system. This is not necessary. Part of the problem is that the same word is being used for both design-time coupling and <em>connections</em> or <em>wiring</em>.</p>
</div>
<div class="paragraph">
<p>In our A &amp; B example above, the code inside B knows nothing of A. The code inside A, while it knows about the concept of the abstraction B, knows nothing about the code that is inside B (or implements B). So we already know how to do zero-coupling. ALA is basically a constraint to always have zero coupling.</p>
</div>
<div class="paragraph">
<p>For example, in conventional code, if function Switch calls function Light, the code inside Switch is coupled with Light. If the light&#8217;s abstraction level is about the same as that of the Switch, then the abstraction of Switch is destroyed. When you use it you have to know the internal code brings in a Light. To understand the <em>system</em> (a Switch connected to a light), you have to go inside the Switch:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/switch-light-bad.png" alt="switch light bad">
</div>
</div>
<div class="paragraph">
<p>If instead, an abstraction, System, has code inside it like Light(Switch()), then Switch remains a good abstraction whose internal code is now only concerned with how a switch works. The code inside all three abstractions is now zero coupled. Understanding the system no longer requires looking inside Switch.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/diagram-collaboration-A-B-C.png" alt="diagram collaboration A B C">
</div>
</div>
<div class="paragraph">
<p><br></p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/diagram-collaboration-B-C-invis.png" alt="diagram collaboration B C invis">
</div>
</div>
<div class="paragraph">
<p>A similar argument applies if Switch and Light are classes. In conventional code they will commonly have an association relationship. Even if Light is injected into Switch by a higher entity called System, Switch still knows the specific interface of a light (LightOn(), LightOff()). This interface is not abstract enough to prevent Switch knowing about Light, and Switch knowing about the System. If you instead have a class System that has code like new Switch().WireTo(new Light()) using a generic interface then all three abstractions are zero coupled.</p>
</div>
<div class="paragraph">
<p>ALA <em>never</em> uses coupling for connections or wiring between parts of a system. A larger system typically consists of many  connections. These connection are typically cohesive, and belong in one place. In conventional code they tend to be distributed and buried inside the modules. A smell is that you are doing 'all files' searches to unravel them</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>"<span class="red"><strong>Collaboration</strong></span> becomes <span class="green"><strong>cohesion</strong></span>".</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In ALA, collaboration between modules becomes cohesion. A call from one module to another becomes two cohesive calls in adjacent lines of code. A method call on a peer&#8217;s classes interface is first transformed to two abstract interface ports. Then a line of creates the two parts and wires them. This line is cohesive with other such wirings needed for that requirement.</p>
</div>
<div class="paragraph">
<p>Cohesion also increases in a different way. An abstraction is closely aligned with the single responsibility principle. We can think of abstration as a single concept principle. Using abstractions increases the cohesion of the code that implements the abstraction.</p>
</div>
<div class="paragraph">
<p>Zero coupling and high cohesion limits ripplle effects of change, whether in higher layers or lower ones. A ripple generally stops at an abstraction concept because of the inherent stability of the concept. What does happen though is that the abstraction can be improved. They are hard to get right in the up-front design. Often you can generalize an abstraction further by adding a configuration that has a default behaviour, so it doesn&#8217;t affect other uses of the abstraction (convention over configuration).</p>
</div>
<div class="paragraph">
<p>In our experience, the most common type of change that still affects multiple abstractions are changes to conventions. Conventions in the ways abstractions are commented, and their code laid out are effectively abstractions in themselves that live in the bottom layer. So when they change, it makes sense that all abstractions that depend on them change. These types of changes may require a lot of editing, but don&#8217;t require simultaneous understanding of multiple modules, which is where the real problem with coupling lies.</p>
</div>
</div>
<div class="sect2">
<h3 id="truegood-versus-bad-dependencies"><a class="anchor" href="#truegood-versus-bad-dependencies"></a>3.4. Good versus bad dependencies</h3>
<div class="paragraph">
<p>We can distinguish two types of dependencies. One is run-time dependencies. These are dependencies in the code that are there because one module will need another module to be present at run-time for the system to work. The other is design-time dependencies. These are dependencies on the knowledge you must have to even understand a given piece of code. I will often refer to this type as a "knowledge dependency" or "use of an abstraction". It is also sometimes called "semantic coupling".</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p><span class="red"><strong>Run-time dependencies are bad</strong></span>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p><span class="green"><strong>Design-time knowledge dependencies on abstractions are good</strong></span>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A simple example of a run-time dependency is a module that calculates the average rainfall then calls a display module to display the result. The Display module needs to be present at run-time. But to understand the code that calculates the average rainfall requires no knowledge about displays, nor even where the result will be sent. The dependency is only there to make the system work at run-time.</p>
</div>
<div class="paragraph">
<p>A simple example of a design-time knowledge dependency is some code that calculates the rainfall using an averaging filter. It uses an abstraction that takes a data stream as input and outputs a running average. To understand the rainfall code needs knowledge of averaging filter. This is a design-time, or knowledge dependency. Any application needing to reduce data to an average could use the same abstraction.</p>
</div>
<div class="paragraph">
<p>We find both types of dependencies in conventional code. A typical modular program is full of bad run-time dependencies. But whether a knowledge dependency or a run-time dependency, they all just look like a function call or a 'new' keyword, or a method call on a peer class&#8217;s interface. We are not taught how to distinguish between them. They are all just called dependencies. We lump them together when we talk about dependency management, loose coupling, layering, fan-in, fan-out, circular dependencies or dependency inversion. Dependency graphing tools cannot distinguish between them because dependencies depend on understanding some abstraction.</p>
</div>
<div class="paragraph">
<p>These two different types of dependencies are not just good and bad. They are really good and really bad. So it&#8217;s doubly important that we learn to tell the difference. What&#8217;s more it&#8217;s entirely possible to build a system using only good dependencies.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p><span class="green"><strong>In ALA we eliminate ALL bad dependencies</strong></span>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A knowledge dependency is good because it&#8217;s only dependent on an abstract concept. Good abstractions are easy to learn. The more dependencies you have on such an abstraction, the more abstract it is, the more reuse you are getting, and the easier it is to learn.</p>
</div>
<div class="paragraph">
<p>Bad dependencies destroy abstractions. They cause explicit and implicit coupling. They obscure the structure of the application by distributing that structure throughout its modules. When we remove all bad dependencies we express what they did in normal cohesive code inside a more specific abstraction above, that composes instances of the abstractions .</p>
</div>
<div class="paragraph">
<p>Consider the diagram below. It the modular way to write a reanfall meter. An ADC reading is averaged, converted, accumulated, and displayed. One of modules has bad dependencies which it uses to make function calls to pull the data in and push it out.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/dependency-diagram.png" alt="dependency diagram">
</div>
</div>
<div class="paragraph">
<p>There are four bad run-time dependencies.</p>
</div>
<div class="paragraph">
<p>Now consider this diagram.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/dependency-diagram-1.png" alt="dependency diagram 1">
</div>
</div>
<div class="paragraph">
<p>There are five good knowledge dependencies (the top layer uses five abstractions in the second layer), but no bad run-time dependencies because the abstractions have no relations with one another. Connections between the instances are completely inside another abstraction as cohesive code that knows about a rain meter.</p>
</div>
<div class="paragraph">
<p>The code in the application abstraction could look something like this if using functions (although you would likely use some temporary variables in practice):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">    Disp(Accu(Conv(Avg(ADC()))));</code></pre>
</div>
</div>
<div class="paragraph">
<p>It might look something like this if using classes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">    new ADC().WireIn(new Avg()).WireIn(new Conv()).WireIn(new Accu()).WireIn(new Disp());</code></pre>
</div>
</div>
<div class="paragraph">
<p>How this code is done is not what&#8217;s important. How syntactically succinct this code is is not important. What&#8217;s important is where it is. We want the code that cohesively and fully expresses a rain meter to be in one place.</p>
</div>
<div class="paragraph">
<p>The lower-case letters used in the top layer of the diagram represent instances of the respective abstractions. (In UML they would be underlined.) You never draw arrows for knowledge dependencies - you only ever refer to abstractions by name. (Just as you would never draw an arrow to a box representing the squareroot function - you would just use Sqrt by its name.)</p>
</div>
<div class="paragraph">
<p>In common programming languages, the run-time dependencies in the first diagram and the knowledge dependencies in the second diagram could both be syntactically written in the same form, either new A() or just a function call, A(). The only difference is in where those new keywords or function calls are, and in the case of classes, using an abstract interface instead of each class having its own specific interface. This difference means the difference between good dependencies and bad dependencies. It has a huge effect on the quality of the architecture as it gets larger.</p>
</div>
<div class="paragraph">
<p>The application abstraction can move the data between the instances of ADC, Avg, etc itself, as we did in the first code example, however strictly speaking that pollutes it with details of how to move data that actually belongs in the programming paradigms layer. We much prefer the application code just does the composing - just specifies who connects to whom, but is not involved with how it works. That&#8217;s why in most of the examples, we compose with classes that have ports rather than functions. In the second code example, the dataflow programming paradigm would be implemented with an execution model that know how to actually move data. The application only knows that it is composing a flow of data.</p>
</div>
<div class="paragraph">
<p>The interface used to connect the instances is called Dataflow. It&#8217;s important that this interface is abstract. It is two layers down. It is not an interface specific to any one of the domain abstractions, ADC, Avg, etc.. This is the abstract interactions pattern. Many other domain abstractions can either implement it or accept it, or both.</p>
</div>
<div class="sect3">
<h4 id="truecomparison-of-good-versus-bad-dependencies"><a class="anchor" href="#truecomparison-of-good-versus-bad-dependencies"></a>3.4.1. Comparison of good versus bad dependencies.</h4>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. Comparison of two approaches</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Run-time dependencies version</th>
<th class="tableblock halign-left valign-top">Knowledge dependencies version</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Knowledge about the specific application is spread through all modules.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Knowledge about the specific application is only in one place. The abstractions know nothing of each other or the specific application.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">The class or function names A, B, D and E will relate to what they do (which is fine). For example, they may be the specific hardware chips used in the case of drivers. The calling module must know these names, creating a fixed arrangement between the modules. The modules are only loosely coupled.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No abstractions refer to the names of peer abstractions. There is no fixed arrangement between abstractions. The abstractions are zero coupled. The code that knows that a particular hardware chip is used in this application is where it belongs, in the application abstraction.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Since there is a fixed arrangement, responsibilities can be blurred. For example, it may be unclear whether to add something to B or C.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">With no relations between abstractions, responsibilities are clear. Something to be added clearly belongs in one or other of the abstractions, or in a new abstraction that may be wired in between the two.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">The fixed dependency from C to B will encourage implicit coupling. B can make assumptions about details inside B resulting in collaborative coupling.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">C cannot make any assumptions about some details of B. It cannot have collaborative coupling with B</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Although there is no dependency, for example from B to C, the fixed arrangement is likely, over time, to make B implicitly collaborate with C (do what C requires), resulting in collaborative coupling.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No implicit coupling can develop over time because there is no fixed relationship between them. B cannot collaborate with C (do what C specifically requires).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">The arrangement between A, B, C, D and E is not obvious in the code. It is buried inside of B, C and D. All must be read to find the application&#8217;s dataflow structure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The arrangement between instances of A, B, C, D and E is explicitly coded in one place. The dataflow between them is cohesive information that belongs in one place.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Only A and E can potentially be abstractions.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">All of A, B, C, D and E are abstractions.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Arbitrarily, only the two ends of the dataflow chain can be reused independently .</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">All of A, B, C, D and E are independently reusable.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Difficult to insert another module between, say, B and C.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Easy to insert a new instance of some operator between B and C, etc.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">If the observer pattern is used (in the mistaken belief that it reduces the coupling), it only mirrors the same problems. For example B would now have a dependency on C when it registers. But because it adds indirection, the observer pattern makes the program even harder to understand.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">If the observer pattern is used (as the means to implement the wiring between the instances), the receivers do not do the registering, the application does (not strictly the observer pattern). The abstractions themselves don&#8217;t get more difficult to understand because, being abstractions, they only have knowledge as far as their interfaces anyway. The application does not get harder to understand either, because the arrangement of the instances is still explicit and in one place.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">If dependency injection is used with automatic wiring, the arrangement is still somewhat fixed, but is now even more obscure. All classes can still be collaborating with one another. A smell that this is happening is that over time the interfaces, IA, IB, ID and IE change as the requirements of the system change.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">If dependency injection is used, the application does the wiring explicitly. It is the only place that should know who will talk to whom at run-time for this specific application. There are no specific interfaces between pairs of modules to change over time, because they all just use a stable abstract interface.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Each module has its own interface. But they are all doing essentially the same thing, getting data.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Uses a single more abstract interface called Dataflow.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">The arrangement between the modules cannot easily be changed, both because the wiring code is buried inside the modules and because the interfaces are essentially specific to pairs of modules.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The composition can easily be changed. Instances of the abstractions can be re-wired in any combination. New abstraction instances can be inserted.</p></td>
</tr>
</tbody>
<tfoot>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">There is no diagram of the arrangement between A, B, C, D, E, or if there is, it is likely a high level overview, lacking in detail, and a second source of truth that gets out of date.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">There is a diagram that shows the arrangement of the instances of A, B, C, D and E. It is the one source of truth. It includes all details about the specific application. It is executable.</p></td>
</tr>
</tfoot>
</table>
<div class="paragraph">
<p>During code creation, run-time dependencies are easily introduced, and never seem too terrible at the time as they get the immediate job done. But when they accumulate to hundreds or even thousands of them, as they do in most typical applications, that&#8217;s when the system, as described on the left side of the table, just appears as a monolithic big ball of mud.</p>
</div>
</div>
<div class="sect3">
<h4 id="truefree-lunch"><a class="anchor" href="#truefree-lunch"></a>3.4.2. Free lunch?</h4>
<div class="paragraph">
<p>When you are comparing the left and right sides of the table above, you may be wondering, where did the free lunch come from? Where did the runtime dependencies go? Is this some kind of magic? Or how can the program work without them? Or haven&#8217;t I just moved them somewhere else? No there are no tricks. The answer is that we have been taught to do programming in a very bad way. The knowledge that ADC will talk to Avg, etc at run-time is there, but it is now contained within an abstraction, not a dependency between modules. If you really want to find a disadvantage, then it is the need for the abstractions. It only works as well as the quality of the abstractions. Effectively we have replaced the need for dependency management with the need to create good abstractions. Creating good abstractions is a skill that does take time to get used to.</p>
</div>
<div class="paragraph">
<p>Just to recap the only dependencies we have used are good design-time or knowledge dependencies:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The application should and must 'know' at design-time what domain abstractions it needs to compose to make a rain meter application.</p>
</li>
<li>
<p>The domain abstractions should and must know at design-time what programming paradigm it needs - the abstract interfaces to use for their input and output ports.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="truestable-dependencies-principle"><a class="anchor" href="#truestable-dependencies-principle"></a>3.4.3. Stable dependencies principle</h4>
<div class="paragraph">
<p>A dependency on an abstractions is a dependency on the concept or idea of that abstraction. A concept or idea is generally stable. So dependencies are toward the more stable.</p>
</div>
<div class="paragraph">
<p>Even if the implementation details inside an abstraction are complicated or change, the abstraction concept itself be stable. The application example above is really just depending on the idea of an ADC or the idea of a Display. If the details inside change it doesn&#8217;t matter. For example, if the ADC silicon is changed, the ADC abstraction implementation can also change. But the application is still just using an ADC as it&#8217;s means to get input.</p>
</div>
<div class="paragraph">
<p>ALA therefore naturally conforms with the Stable Dependencies Principle (depend in the direction of stability). The SAP is mostly used in relation to packages, but ALA does not use hierarchical encapsulations. Here we are applying it at the level of the abstractions themselves.</p>
</div>
</div>
<div class="sect3">
<h4 id="truedependency-fan-in-and-fan-out"><a class="anchor" href="#truedependency-fan-in-and-fan-out"></a>3.4.4. Dependency fan-in and fan-out</h4>
<div class="paragraph">
<p>One of the guidelines sometimes used for dependencies in conventional code is that a class that has high fan-in should not have high fan-out (also called afferent and efferent coupling). Another is that modules higher in the layers should have low fan-in and those lower in the hierarchy have low fan-out.</p>
</div>
<div class="paragraph">
<p>The argument goes that a class with high fan-in should have high stability but one with high fan-out would have low stability (presumably because dependencies are thought to be things that cause changes to propagate).</p>
</div>
<div class="paragraph">
<p>In ALA, dependencies are on abstractions. Furthermore the abstractions are increasingly abstract as you go down the layers, and therefore increasingly stable. Therefore the conventional fan-in and fan-out recommendations are reversed. In ALA, it is perfectly fine, in fact really good to have both high fan-in and high fan-out. It simply means that the abstractions are useful and are getting reused.</p>
</div>
<div class="paragraph">
<p>If we are talking about dependencies in a conventional modular system that are used for communication between modules in the system, of course ALA says we want zero fan-in and zero fan-out, because such dependencies are illegal anyway.</p>
</div>
<div class="paragraph">
<p>In chapter four we will also talk about fan-in and fan-out. Note that the fan-in and fan-out discussed in chapter four is different. In this chapter fan-in and fan-out is talking about dependencies on abstractions between layers. In chapter four we are talking about fan-in and fan-out in the wiring.</p>
</div>
</div>
<div class="sect3">
<h4 id="truecircular-dependencies"><a class="anchor" href="#truecircular-dependencies"></a>3.4.5. Circular dependencies</h4>
<div class="paragraph">
<p>Of course in ALA, with only knowledge dependencies present in the system, and the dependencies needing to go toward more abstract abstractions, you obviously cannot have circular knowledge dependencies. Nor would that even make sense. (Recursion appears to require circular knowledge dependencies but actually doesn&#8217;t. We will visit that in the last chapter.)</p>
</div>
<div class="paragraph">
<p>Since there are no run-time dependencies, the issue of circular dependencies with them does not arise at all. What might have been circular dependencies in conventional code becomes circular wiring of instances of abstractions inside a user story abstraction in the application layer. Such circular wiring is quite valid, and very common. The potential issues with the execution models are discussed in chapter four.</p>
</div>
<div class="paragraph">
<p>In conventional software design, run-time communication channels between modules are frequently implemented with dependencies. Then we realize these dependencies are a problem and so we add a rule that we don&#8217;t like circular dependencies. This is an attempt to mitigate the problem by forcing the modules to have a sort of arbitrary layered structure. That structure does not actually exist in the nature of peer modules themselves. (Many modules will actually have a similar level of abstraction, for example views, business logic and data.) The forced arbitrary layering structure becomes its own nuisance.</p>
</div>
<div class="paragraph">
<p>So then what happens is circular dependencies are most often avoided by using pushing in one direction and pulling in the other. (Pushing means a function or method call with a parameter, pulling means a function or method call returning a value). This is sometimes actually convenient, and other times a real nuisance. Whether we push or pull should be able to depend on performance or other considerations (which end wants to initiate the communications, which depends on when the source changes, or when we want to receive new a the data, or how often the source changes, or on latency, etc), not on an arbitrary layering of modules.</p>
</div>
<div class="paragraph">
<p>So, when we do want to push or pull in the reverse direction of the allowed dependency, we end up creating an indirection, such as a callback, virtual function call, or observer pattern (publish-subscribe). This indirection further obscures the already  obscure communication flows through the system.</p>
</div>
<div class="paragraph">
<p>ALA simply eliminates all this nonsense. In ALA, communication flows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>are explicit</p>
</li>
<li>
<p>can be in both directions</p>
</li>
<li>
<p>each set of cohesive flows are contained in one place</p>
</li>
<li>
<p>allowed to be push, pull, or asynchronous on a port by port basis</p>
</li>
<li>
<p>don&#8217;t use dependencies at all</p>
</li>
<li>
<p>use indirection in the correct way, which is that when you are reading code inside an abstraction, you don&#8217;t know, and shouldn&#8217;t know, where your inputs and outputs are wired to.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>That concludes our discussion on why the ALA structure works from the point of view of good and bad dependencies.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="trueknowledge-dependencies-are-on-all-layers-below"><a class="anchor" href="#trueknowledge-dependencies-are-on-all-layers-below"></a>3.5. Knowledge dependencies are on all layers below</h3>
<div class="paragraph">
<p>Sometimes layers are used incorrectly as partitions or really just modules. We would be better off to just tip all such layering models on their side.  Because of this mistake, there is a meme that we should only have dependencies on the immediate layer below. For ALA layers this is incorrect.</p>
</div>
<div class="paragraph">
<p>When we write our programs using only knowledge dependencies, the knowledge needed to understand a piece of code can come from all the layers below.</p>
</div>
<div class="paragraph">
<p>For example, to understand this application layer code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">    new ADC().WireIn(new Avg()).WireIn(new Conv()).WireIn(new Accu()).WireIn(new Disp());</code></pre>
</div>
</div>
<div class="paragraph">
<p>You need to know all of these things from lower layers:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Understand what the  domain abstractions, ADC, Avg, Disp, etc do.</p>
</li>
<li>
<p>Understand the dataflow programming paradigm. When you compose these particular domain abstractions, you are composing a flow of data from left to right.</p>
</li>
<li>
<p>Understand that the WireTo operator, which comes from the Libraries layer, is what you use to do composition.</p>
</li>
<li>
<p>Understand your general purpose programming language, which sits below the Libraries layer.</p>
</li>
<li>
<p>Understand ALA which is an abstraction that sits below the programming language layer.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>All of these knowledge dependencies should be explicit. This means that the application folder should contain a readme file explaining all these knowledge dependencies, and link to information about them.</p>
</div>
<div class="paragraph">
<p>It&#8217;s nt necessarily the case that all lower layer knowledge is needed to understand something. The application is itself an abstraction. There can be many instances of it being used by different users. These users don&#8217;t need to understand all the abstractions in all the layers, only the application abstraction by itself.</p>
</div>
</div>
<div class="sect2">
<h3 id="trueexecutable-expression-of-requirements-2"><a class="anchor" href="#trueexecutable-expression-of-requirements-2"></a>3.6. Executable expression of requirements</h3>
<div class="paragraph">
<p>We have previously discussed this aspect of ALA in terms of structure. It is the top layer. And we have used this aspect as the starting point in the method to develop the example projects. But why does the succinct description of requirements in that top layer work?</p>
</div>
<div class="paragraph">
<p>In conventional software development, we typically break a user story (or feature or functional requirement) up into different implementation responsibilities. For example, layers like GUI, business logic and database, or a pattern such as MVC (Model, View, Controller). But a user story or feature actually starts out as cohesive knowledge n the requirements. And its not a huge amount of cohesive knowledge, so it doesn&#8217;t need breaking up. Cohesive knowledge, knowledge that is by its nature highly coupled within itself should be kept together. All we need to do to keep it together is find a way to describe it so that it is executable. Don&#8217;t try to do any implementation, just get it described in a concise and complete form. If you can do that, the chances are you will be able to find a way to make it execute.</p>
</div>
<div class="paragraph">
<p>In ALA we want to find a way to express the user story with about the same level of expressiveness as when the user story was explained in English by the product owner. The language he used would have contained domain specific terms to enable him to explain it concisely. The same thing ought to be possible in the code. Anything that does not come directly from the requirements and starts to look like implementation detail is separated out. It comes out into abstractions. These abstractions typically contain knowledge of how user stories in general are implemented - how things can be displayed, how things can be saved, how data can be processed.</p>
</div>
<div class="paragraph">
<p>It turns out that abstractions that know how to implement useful things for expressing user stories are not only reusable for different user stories, but can be reusable for other applications. In other words, they are domain level abstractions. A typical user story might be composed of several of them, some to implement the user story&#8217;s UI, some to implement the user story&#8217;s business, and some to implement the user story&#8217;s saving of data. A user story instantiates the abstractions, configures them with the specific knowledge from the requirement, and then wires them together.</p>
</div>
<div class="paragraph">
<p>Most maintenance is probably changing, adding or fixing user stories or features. When those features are described entirely in one place instead of distributed through a lot of modules, you have a direct understanding of how the user story is represented by code, and therefore of how to change it or fix it.</p>
</div>
<div class="paragraph">
<p>Of course application code makes heavy use, in fact is entirely composed of, instances of domain abstractions. When fixing a bug, it quickly becomes clear if the application code itself doesn&#8217;t represent the requirements as intended, or one of the abstractions is not doing its job properly. Again the maintenance is easy.</p>
</div>
<div class="sect3">
<h4 id="truerequirements-are-whats-left-when-you-factor-out-all-implementation-details"><a class="anchor" href="#truerequirements-are-whats-left-when-you-factor-out-all-implementation-details"></a>3.6.1. Requirements are what&#8217;s left when you factor out all implementation details</h4>
<div class="paragraph">
<p>This is another way of thinking that comes to the same solution. As we know from the previous section, ALA requires you to break up your entire application only by factoring out abstractions. So what does the application that&#8217;s left in the top layer look like when this is done? Well if anything abstract has been removed, what remains must be details specific only to this application. Essentially these details equate with the requirements.</p>
</div>
<div class="paragraph">
<p>The application code becomes a formal re-expression of the requirements. There will be some information there that wasn&#8217;t explicitly stated in the requirements, but they were requirements all the same. For example, it may not have been stated in the requirements that a number displayed on the UI should not change its value too frequently - it should be slow enough for a human to read successive values. A consequence of that requirement is that it should not contain noise that has a frequency higher than the display update rate. So the application will end up with an instance of a re-sampler abstraction and an instance of a filter abstraction wired into its dataflow before the display. The application will specify the re-sampling rate, and the filter bandwidth.</p>
</div>
</div>
<div class="sect3">
<h4 id="truedsl-domain-specific-languages"><a class="anchor" href="#truedsl-domain-specific-languages"></a>3.6.2. DSL - Domain Specific Languages</h4>
<div class="paragraph">
<p><a id="DSL1"></a></p>
</div>
<div class="paragraph">
<p>ALA&#8217;s succinct expression of requirements discussed above is obviously a form of DSL (Domain Specific Language). Under the broader definition of a DSL, The domain abstractions and programming paradigms layers are a DSL. But ALA is not just a DSL. ALA is fundamentally about organising all code into small abstractions that are in layers that are increasing abstract. This constrains the organisation of code much more than simply implementing a DSL.</p>
</div>
<div class="paragraph">
<p>ALA does not pursue the idea of an external DSL (a new syntax), nor even the syntactic elegance of DSLs. It doesn&#8217;t try to move application development away from the developer to a requirements team as some DSLs can do. For example, you don&#8217;t get a new language such as XAML to express UI structure. In fact, expressing the UI structure in ALA moves away from XML back to code. If moving away from code, ALA uses diagrams because they are more flexible and much more readable than XML.</p>
</div>
<div class="paragraph">
<p>Seen as a DSL, in ALA you wire together plain old objects or functions while conforming to a grammar. The grammar comes from the 3rd layer programming paradigms and from which classes use which programming paradigm for ports. This grammar defines the rules for their composition.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="truediagrams-vs-text"><a class="anchor" href="#truediagrams-vs-text"></a>3.7. Diagrams vs text</h3>
<div class="paragraph">
<p>The fundamental rules of ALA don&#8217;t prescribe the use of diagrams. But diagrams often emerge.
So why do we often use a diagram instead of text in the application (top) layer of an ALA application?</p>
</div>
<div class="paragraph">
<p>It&#8217;s because in any non-trivial program, there is structure inherent in the requirements that forms a graph. If you have UI that graph is a tree - still representable with indented text. But the UI must have connections. (These particular connections are often called bindings.) They need connections with data. They need connections with event handlers. These connections must be done symbolically if using text. The connections go further. There are connections to business logic and to some form of persistent data model, and from there to real databases or files. There are arbitrary connections for navigating around different pats of the UI. If text, most of these connections must be done symbolically. On the way, they may need to connect arbitrarily with things that process, reduce, or combine. There may be states involved, with arbitrary transitions needed between those states. There may be activities that have to happen in a prescribed time sequence, which by itself is representable as a linear instructions in text. But there are often loops or alternative routes through the sequence, which is representable as indented text. But then there is always some connection between the activities and some data or the outside world. If text, these connections must generally be done symbolically.</p>
</div>
<div class="paragraph">
<p>All these connections are inherent in the requirements. Like or not, they form a graph. And this graph structure is somewhere in your code.</p>
</div>
<div class="paragraph">
<p>As we said, in text from, this graph needs to use at least some symbolic connections. That is, we can represent some of the graph with indenting and judicious use of anonymous functions or classes, but in general we will need to represent many of the connections by using names of variables, functions or objects.</p>
</div>
<div class="paragraph">
<p>This is bad enough. In fact this is already really, really bad compared with how the electronics guys do things.</p>
</div>
<div class="paragraph">
<p>But it gets much worse. In most conventional code, we take all these symbolic connections and distribute them evenly through the files/modules/classes/functions. Now the graph is totally obfuscated. The graph is highly cohesive. Why do we make it harder for ourselves by breaking it up?</p>
</div>
<div class="paragraph">
<p>But it gets much worse. Graphs have circles in them. There is nothing wrong with that, it&#8217;s inherent in the connections in the requirements. But circles are at odds with dependency rules. So now what we do is break the cyclic dependencies using principles like dependency inversion or observer pattern. The connections don&#8217;t go away. We just further obfuscated them. These connections are now done at run-time by code written somewhere else. This is the so called indirection problem.</p>
</div>
<div class="paragraph">
<p>What a mess we have got into!</p>
</div>
<div class="paragraph">
<p>ALA tells us how to fix this entire mess. It&#8217;s really quite simple. ALA breaks up your application by factoring out abstractions. When you have done that to the maximum extent, what&#8217;s left behind is nothing but the specifics of the requirements, including that (highly coherent) graph.</p>
</div>
<div class="paragraph">
<p>Now you can choose to go ahead and represent that graph in text in one place, using many symbolic connections, and you would already be way, way better off than how we write conventional code. But even better is to do what the electronics guys do, and just build the tools to handle the graphs as diagrams properly.</p>
</div>
<div class="sect3">
<h4 id="truediagrams-and-text-are-not-equivalent"><a class="anchor" href="#truediagrams-and-text-are-not-equivalent"></a>3.7.1. Diagrams and text are not equivalent</h4>
<div class="paragraph">
<p>Diagrams and text are sometimes thought of as equivalent - and it&#8217;s a matter of personal preference which you use. I do not agree with this. From the point of view of how our brain&#8217;s work best, they are different, and each is powerful at its own job.</p>
</div>
<div class="paragraph">
<p>Consider an electronics engineer who uses a schematic diagram. Ask him to design a circuit using text and he will think you a simpleton. Electronics naturally has a network structure that is best viewed and reasoned about as a diagram. If you turn a diagram into a textual list of nodes and connections, the brain can no longer work with it directly. It is constantly interrupted to search for symbolic references when it should be free to just reason about the design.</p>
</div>
<div class="paragraph">
<p>Most software naturally has an arbitrary network structure. Think about whenever you are working with legacy code - how often to you need to do "all files searches" or "find all references". And even those are foiled by indirections. Try designing or reasoning about a state machine without using a diagram.</p>
</div>
<div class="paragraph">
<p>Text can readily be used to compose elements in a linear chain or sequence. It is excellent for telling stories. White space is the normal connector between the elements. Sometimes periods or other symbols are used instead. Text can also handle shallow tree structures, simply by using indenting. Compilers may use brackets, usually () or {}. Interestingly, the brackets work for the compiler, but not for the brain. The brain doesn&#8217;t see them, it just sees the indenting. So I personally don&#8217;t agree that Python&#8217;s significant indenting is a mistake as many do.</p>
</div>
<div class="paragraph">
<p>When the tree gets deep, the indenting is too deep for our brains to follow. So text is only suitable for linear structures and shallow trees. Structured programming and XAML are examples of tree structured code represented successfully in text.</p>
</div>
<div class="paragraph">
<p>Text becomes troublesome when there are arbitrary connections across the structure forming a mesh. It must be done with matching names, labels or identifiers. Most imperative programs are actually not a tree structure because of the variables. They must be done with labels. Local variables in a small scope are not too much of a problem. It only requires an editor that highlights all of them. For large scopes we end up spending too much time finding and trying to remember the connections, resorting to many all-files searches. It is a cumbersome way to try to reason about what is usually a simple structure when viewed as a diagram.</p>
</div>
<div class="paragraph">
<p>(When we talk about labels, we are talking about labels that are used for connecting two or more points. These labels are not abstractions. References to the names of abstractions are absolutely fine, and we don&#8217;t draw lines for them even if we are using a diagram. We just use a box with the abstraction name inside it.)</p>
</div>
<div class="paragraph">
<p>When we need to compose instances of abstractions in an arbitrary network structure, our brains work much better using a diagram. The brain can readily see and follow the lines between the instances of the abstractions. Unlike with text labels, the lines are anonymous, as they should be. Lines don&#8217;t need encapsulation. To understand all uses of a variable in text, we need an encapsulation scope. To understand all places connected by a line, the brain just sees all the lines instead. Generally lines connect only two points or ports, but sometimes may connect three or four. More than that, and it starts to smell as if a new abstraction may be waiting to be discovered. The spacial positioning of elements is also something the brain readily remembers. So, diagrams can qualitatively do things that text simply cannot.</p>
</div>
<div class="paragraph">
<p>ALA does not require a diagram per se. It only requires abstraction layering, and it&#8217;s quite possible for a user story to just consist of a linear sequence of abstracted operations. For example, a sequence of movements by a robot or a "Pipes and Filters" sequence of operations on data. However, ALA is polyglot with respect to programming paradigms because user stories will generally combine multiple programming paradigms: UI, event-flows, dataflows, state machines, data schemas, etc. These aspects of a user story tend to be naturally interrelated (inherent in the requirements), which is what causes the resulting relationships among its instances of abstractions to be a network. Diagrams, then, embrace the bringing together of all these different interrelationships of a user story in one place and view.</p>
</div>
</div>
<div class="sect3">
<h4 id="trueno-xml-as-code"><a class="anchor" href="#trueno-xml-as-code"></a>3.7.2. No XML as code</h4>
<div class="paragraph">
<p>If dependency injection is used to implement the wiring, I prefer not to use XML to specify the application. Firstly XML is not very readable. Secondly it only handles tree structures well, not networks, and it becomes more unreadable if the tree is deep. If you must use text for specifying wiring, use normal code. You are still better off with this code in one place than having it distributed inside your modules. But if a network structure is inherent in the requirements, there is really no substitute for the readability of diagrams.</p>
</div>
</div>
<div class="sect3">
<h4 id="truediagramming-tools"><a class="anchor" href="#truediagramming-tools"></a>3.7.3. Diagramming tools</h4>
<div class="paragraph">
<p>The ALA design process (which is describing your requirements and inventing the needed abstractions as you go) is an intense diagram generating activity, especially the first time in a new domain. It requires all your focus. I have found that hand drawing the diagram on paper is not good. The diagram quickly gets into a messy state which requires redrawing, and that interrupts your flow. I have found that a diagramming tool that constantly needs you to control the layout, such as Visio, is also not good.</p>
</div>
<div class="paragraph">
<p>So until there is a better tool, I have been using Xmind because as a mind-mapping tool, it is designed to not get in your way as you are creating. It lays itself out as a tree structure, and then allows cross connections on the tree to be added using a key short-cut at the source and a mouse click at the destination node. It has its limitations, however I use some simple conventions to get around these. For example, I use '&lt;' and '&gt;' to represent input and output ports.</p>
</div>
<div class="paragraph">
<p>Furthermore, the tree structure allows easy hand translation of the diagram into indented, fluent style code.</p>
</div>
<div class="paragraph">
<p>More recently we use a simple tool that takes Xmind files and generates the code automatically.</p>
</div>
<div class="paragraph">
<p>And even more recently, we have in progress a purpose built graphical IDE for ALA.</p>
</div>
<div class="paragraph">
<p>See the end of this chapter for an example project using Xmind.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Thoughts on the essentials of a diagramming tool.

It would have the low driving overhead of a mind mapping tool. As with a mind-mapping tool, you control the logical layout, and the tool does the actual spacial positioning. It would primarily use keypresses, but allow mouse clicks where it makes sense, for example, to specify the destination of a 'cross connection'. The tool would route the cross conenction for you.

A tree topology can be done with simple key presses. The tree would capture the primary relationships between instances, on their main ports.

You can make mutiple trees for different user stories that are disconnected logically, but for the purpose of automatic layout, are connected to the main tree (just an invisible line).

Abstractions are defined in a separate panel as stand-alone boxes with ports. Once a new abstraction is  defined, it can be instantiated in the diagram by its abstraction name with auto completion. Boxes represent these instances of abstractions with the ports still lablled around their boundary.

The abstractions are fully inegrated with the classes in the code. This is in both directions. So for any existing classes, the IDE shows them with their port, and fully supports the entry of constructor arguments and properties.

In the other direction, if you create a new abstraction in the tool. You can specify its ports and their types and names. You can specify the constructor arguments and properties and their default values. It will create/modify a template for that class.cs.

The tool's purpose is to aid creativity in the ALA process of representing a user story, inventing new abstractions as you go. Of course the tool would also automatically generate the wiring code.</pre>
</div>
</div>
<div class="paragraph">
<p>In my experience, a low overhead drawing tool is essential during the iteration zero design phase and during subsequent maintenance.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="truecomposition-not-decomposition"><a class="anchor" href="#truecomposition-not-decomposition"></a>3.8. Composition, not decomposition</h3>
<div class="paragraph">
<p>The conventional technique for tackling system complexity is "divide and conquer".</p>
</div>
<div class="paragraph">
<p>Consider this phrase, which has been used as the definition of software architecture:</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>"<span class="red"><strong>decomposition</strong></span> of a system into <span class="red"><strong>elements</strong></span> and <span class="red"><strong><em>their</em></strong></span> <span class="red"><strong>relations</strong></span>".</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Notice the word 'their', which I have italicised to emphasis that the relations are inferred to be between the decomposed elements. It suggests that the decomosed elements know something about each other, that they collaborate to create the whole.</p>
</div>
<div class="paragraph">
<p>In ALA we think about building the system in a completely different way. Here is how to reword the meme for ALA:</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>"<span class="green"><strong>composition</strong></span> of a system using <span class="green"><strong>instances</strong></span> of <span class="green"><strong>abstractions</strong></span>".</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This seemingly subtle shift in thinking leads to a qualitative difference in the resulting structure.</p>
</div>
<div class="paragraph">
<p>First let&#8217;s understand what we mean by composition through a few examples:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>When we compose musical notes, we create a tune. The structure is linear. The execution is sequential like activity flow below.</p>
</li>
<li>
<p>When we write code in a general purpose programming language, we are composing  statements. Statements are low level (fine grained) elements and only support a single programming paradigm, which we could describe as 'imperative', but by composing enough instances of them we can create a program. The structure is a linear or a tree.</p>
</li>
<li>
<p>In functional programming, we are composing with functions, so the elements are higher level things that you create. But the programming paradigm is still imperative (unless you use monads). The structure is either linear or a tree.</p>
</li>
<li>
<p>When programming with monads, we are composing with what they call 'amplified data types'. These are usually low-level elements. But the programming paradigm has changed from imperative to dataflow. The structure is usually linear. (You don&#8217;t need to understand or use Monads to use ALA. however,
<a href="#Monads">See my method to understand Monads in Chapter Six</a></p>
</li>
<li>
<p>When programming using the UML class diagram, we are composing classes. The programming paradigm is associations. The syntax is graphical. The structure is a network.</p>
</li>
<li>
<p>When programming using the UML activity diagram, we are composing activities to be done in a set order. The structure is a network, because you can branch, recombine and loop back arbitrarily. Activity diagrams are not imperative (like the old style flow diagrams). The CPU is not necessarily dedicated to each activity being done. Activities may take an arbitrarily long time without the system blocking.</p>
</li>
<li>
<p>When programming with XAML, we are composing UI elements. The programming paradigm is UI layout (what goes inside what and in what order). The structure is a tree.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Let&#8217;s list the different properties present in these types of composition:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Low-level or high-level - Sometimes we are composing fine-grained general elements and we need a lot of them. Sometimes we are composing 'higher level' more specific elements, and we need a few of them.</p>
<div class="paragraph">
<p>Note that sometimes people think of these higher level elements as more abstract. They are actually less abstract. For example, a class that handles complex numbers is less abstract than the fundamental float type. Complex numbers are a more specific case because its only useful when you need complex numbers in your solution. But when you do need complex numbers, then they are obviously more expressive than using pairs of floats everywhere. This means that you need to compose less abstractions to build your solution.</p>
</div>
</li>
<li>
<p>The meaning of a composition relationship is mostly fixed in each case. It can be one of imperative, dataflow, UI layout etc.</p>
</li>
<li>
<p>Linear/Tree/Network: The structure built by the composition relationships can be linear, a tree structure or a general graph or network.</p>
</li>
<li>
<p>Syntax: The syntax for the composition of two joined elements can be using spaces, dots or lines on a diagram. We can use various types of bracketing or indenting for the text form of tree structures.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In ALA, we are setting up to do composition of user stories. We want the composition to have the following properties:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Composing course grained expressive elements by letting them be specialized to your domain.</p>
</li>
<li>
<p>Allow use of many programming paradigms (meaning of composition)</p>
</li>
<li>
<p>Allows linear, tree or network structures.</p>
</li>
<li>
<p>Allow new programming paradigms with new meaning if that&#8217;s the best way to express typical requirements.</p>
</li>
<li>
<p>Uses the same syntax for all composition relationships.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>ALA can therefore be thought of as a 'generalised compose from abstractions' methodology.</p>
</div>
</div>
<div class="sect2">
<h3 id="trueno-data-coupling"><a class="anchor" href="#trueno-data-coupling"></a>3.9. No Data coupling</h3>
<div class="paragraph">
<p>In conventional programming, data coupling is considered unavoidable.</p>
</div>
<div class="paragraph">
<p>The word coupling here is used for both the fact that one module communicates data with another and the fact that the modules must agree on the meaning of that data.</p>
</div>
<div class="paragraph">
<p>The actual communication of data at run-time is not a problem. The sharing of the knowledge on how to interpret that data is. In ALA we only refer to the later as coupling (remember coupling occurs at design-time). ALA eliminates this coupling.</p>
</div>
<div class="paragraph">
<p>There is a misconception meme that two modules have to share the knowledge of the meaning of data if they communicate at run-time. Even if you have a basic understanding of ALA, you may be still trapped by this misconception. This will cause you to write modules in the conventional way and they will have coupling.</p>
</div>
<div class="paragraph">
<p>To overcome this misconception, we will use a specific example. Let&#8217;s say there is a temperature sensor on a Mars rover. The temperature is to be displayed at a ground station on Earth.</p>
</div>
<div class="paragraph">
<p>In conventional programming, to implement this user story, one module resides in the Mars rover and one module resides in the ground station. These two modules must agree on the meaning of data. For example, it is an integer number of tenths of degrees C (Celsius).</p>
</div>
<div class="paragraph">
<p>Obviously a lot of other system parts are involved in transporting the data from the sensor module to the display module. These are referred to as middleware. It is common to <em>containerise</em> the data so that none of the middleware needs to know what the data is. But the two end points must have shared knowledge.</p>
</div>
<div class="paragraph">
<p>How does ALA avoid this shared knowledge. The anwser is that in ALA, you use a single module (application layer abstraction) to implement the user story.</p>
</div>
<div class="paragraph">
<p>This single abstraction contains all the knowledge of this user story. What this single abstraction does is instantiate an abstract display, instantiate an abstract ADC converter, and logically wire them together. Since we want to display the temperature in tenths of degrees, we will also wire in an instance of a convert abstraction and configure it to convert raw ADC readings to tenths of degrees.</p>
</div>
<div class="paragraph">
<p>Then, also inside the user story abstraction, we annotate the three instances with their physical locations. An abstraction that knows about the concept of <em>physical view</em> has already been configured to know about the two physical locations for this application. The physical view engine takes care of deploying the instances of abstractions for the user story to the correct locations, and it takes care of actually connecting both ends through the middleware.</p>
</div>
<div class="paragraph">
<p>That&#8217;s how you do it in ALA. There is no data coupling involved.</p>
</div>
<div class="paragraph">
<p>This technique fails when the module at one end already exists in a 3rd party system with an API. The 3rd party is not using ALA. Now there must be coupling. The coupling manifests as a design-time communication from one party to the other, probably in the form of a specification.</p>
</div>
<div class="paragraph">
<p>In this situation it is still possible to mitigate the effects of coupling somewhat. Let&#8217;s say the display end has been written by the 3rd party, but is written in such a way that it accepts <em>self describing data</em> according to a standard. Without changing the display end, the user story can be implemented from scratch by sending to the display the self describing data. The display then knows how how to receive the label and display format (which can be sent once) as well as the numeric data. The display knows how to create a space for displaying the data. This is how browsers work.</p>
</div>
<div class="paragraph">
<p>If the situation is the other way around, if a 3rd party is providing the installed sensors and the API for it, then we can&#8217;t avoid the coupling. We must know about the API at design-time. It is common for example, for a 3rd party to provide a sensor and publish the data on an MQTT server. Say we are then writing an application to use this data, not only display it, but interpret the data as well. We have no choice but to be coupled with knowledge provided by the 3rd party about the MQTT topic that we need to subscribe to.</p>
</div>
<div class="paragraph">
<p>But, if the 3rd party is selling you sensors that you install yourself and selling you the MQTT communication infrastructure, then you could be provided with a more abstract 'configuration API' from the 3rd party. You would then write a domain abstraction that knows about that configuration API. Then, whenever you want to do a new user story, you can use an instance of that 'device configuration' abstraction. You can fully configure the MQTT topic itself, and its data format, then subscribe to it and process it. Everything specific to the user story is now cohesively contained inside a single abstraction once again.</p>
</div>
</div>
<div class="sect2">
<h3 id="truecomposability-and-compositionality"><a class="anchor" href="#truecomposability-and-compositionality"></a>3.10. Composability and Compositionality</h3>
<div class="paragraph">
<p>We have used the word <em>compose</em> a lot so far in describing ALA. Now we look at the property of  <em>composability</em> which enables us to compose. Composability means the ability to create an infinite variety of applications by combining instances of a finite number of domain abstractions.</p>
</div>
<div class="paragraph">
<p>This is a very important property of ALA. Composability uses the Principle of Compositionality which states: In mathematics, semantics, and philosophy of language, the principle of compositionality is the principle that the meaning of a complex expression is determined by the meanings of its constituent expressions and the rules used to combine them.</p>
</div>
<div class="paragraph">
<p>Jules Hedges says of this property "I claim that compositionality is extremely delicate, and that it is so powerful that it is worth going to extreme lengths to achieve it."</p>
</div>
<div class="paragraph">
<p>In software engineering, it is described by a pattern called "Abstract Interactions" or "Configurable Modularity" by Raoul de Campo and Nate Edwards - the ability to reuse independent components by changing their interconnections but not their internals. It is said that this characterises all successful reuse systems.</p>
</div>
<div class="paragraph">
<p>ALA has these properties by using domain abstractions with ports, which are instances of programming paradigms. The domain abstractions are the constituent expressions, and the programming paradigms are the rules used to combine them.</p>
</div>
<div class="paragraph">
<p>As mentioned earlier, there are other software systems that have composability, usually using the dataflow paradigm, such as RX (Reactive Extensions), or more generally monads. Most composability systems are restricted to a single paradigm. For ALA to have the correct level of expressiveness of all requirements multiple different programming paradigms are needed.</p>
</div>
<div class="paragraph">
<p>We can make an analogy with Lego bricks. Some Lego parts have the familiar little stud and tube connectors. Some will support axles and holes connections, either tight or loose. These different ways of connecting Lego parts are analogous to different programming paradigms. Each has a different behaviour at run-time.</p>
</div>
</div>
<div class="sect2">
<h3 id="truesome-real-dependency-graphs"><a class="anchor" href="#truesome-real-dependency-graphs"></a>3.11. Some real dependency graphs</h3>
<div class="paragraph">
<p>Our example project for this chapter is a real legacy application (that was maintained for approximately 10 years) that we decided to re-write using ALA. Normally, for reasons I won&#8217;t go into here, I would never re-write an application. Maintenance had become difficult with this legacy code, and we wanted to run a research experiment to see if a rewrite using ALA could be successful. It would also give us a good basis for comparative metrics of the two code bases.</p>
</div>
<div class="paragraph">
<p>The original application has around 30 KLOC. Rather than look at any of the details of the application itself, we present here dependency graphs generated by Ndepend for the old legacy application and new ALA application.</p>
</div>
<div class="sect3">
<h4 id="truelegacy-application-dependency-graphs"><a class="anchor" href="#truelegacy-application-dependency-graphs"></a>3.11.1. Legacy application dependency graphs</h4>
<div class="paragraph">
<p>One of the core tenets of ALA (as discussed in Section 3.2) is "Composition using layers" instead of "Decomposition using encapsulation". Unfortunately Ndepend is designed with the assumption that the application should be built using the latter approach. It likes to present a decomposition structure, starting with assemblies (packages) at the outermost level, then namespaces, and then classes. I&#8217;m not sure why it considers namespaces a viable encapsulation mechanism because they don&#8217;t provide encapsulation. Anyway, here is the namespace dependency graph for the main assembly of the legacy version of the application, as it comes out of ndepend.</p>
</div>
<div class="imageblock">
<div class="content">
<a class="image" href="images/old-datalink/namespaces.png"><img src="images/old-datalink/namespaces.png" alt="namespaces.png"></a>
</div>
<div class="title">Figure 33. Legacy application - namespaces</div>
</div>
<div class="paragraph">
<p>This graph is quite large, so if you like you can right click on it, and open it in a new tab in your browser. The red arrows are dependencies in both directions.</p>
</div>
<div class="paragraph">
<p>Each box represents a namespace. The thickness of the arrows is proportional to the number fo dependencies. The size of the boxes is proportional to the number of lines of code in the namespace.</p>
</div>
<div class="paragraph">
<p>If we drill down into the largest namespace, UIForms, we see the class relationships between classes inside that namespace:</p>
</div>
<div class="imageblock">
<div class="content">
<a class="image" href="images/old-datalink/classes-in-uiforms-namespace.png"><img src="images/old-datalink/classes-in-uiforms-namespace.png" alt="classes-in-uiforms-namespace.png"></a>
</div>
<div class="title">Figure 34. Legacy application - classes in uiforms namespace</div>
</div>
<div class="paragraph">
<p>Here you can see that ndepend is trying to make out the layers. The layers are vertical columns, going from left to right. I have left them vertical even through ALA abstraction layers are usually drawn horizontal because they come out more readable on the page. Again there are many dependencies in both directions drawn in red.</p>
</div>
<div class="paragraph">
<p>Here are the classes inside the DataStructure namespace:</p>
</div>
<div class="imageblock">
<div class="content">
<a class="image" href="images/old-datalink/classes-in-datastructure-namespace.png"><img src="images/old-datalink/classes-in-datastructure-namespace.png" alt="classes-in-datastructure-namespace.png"></a>
</div>
<div class="title">Figure 35. Legacy application - classes in datastructure namespace</div>
</div>
<div class="paragraph">
<p>Again, Ndepend is trying to make out the layers from left to right.</p>
</div>
<div class="paragraph">
<p>There is one class called Device which actually looks like it might be a good abstraction.</p>
</div>
<div class="paragraph">
<p>As mentioned, namespaces provide no useful decomposition structure. They do not make abstractions in themselves, nor do they implement a facade pattern or an aggregate root type of pattern with even logical encapsulation. Any classes inside each namespace can have unconstrained relationships with any classes in any other namespace.</p>
</div>
<div class="paragraph">
<p>So Ndepend is giving us a false picture here, because it is omitting all dependencies that go in or out of the namespaces. To really get an idea of what the big ball of mud looks like, I configured Ndepend to use a query that gives me all the classes in all the namespaces. Here finally is what this application truly looks like:</p>
</div>
<div class="imageblock">
<div class="content">
<a class="image" href="images/old-datalink/classes-in-all-namespaces.png"><img src="images/old-datalink/classes-in-all-namespaces.png" alt="classes-in-all-namespaces.png"></a>
</div>
<div class="title">Figure 36. Legacy application - all classes in all namespaces</div>
</div>
<div class="paragraph">
<p>This graph is very large. Right click on it, and open it in a new tab in your browser, so you can zoom in to see the dependencies in the background. It is truly frightening. Ndepend had no chance to find the dependency layers. There may be vaque onion type layers going outwards from the middle. It makes readily visible why continued maintenance on this application is so difficult. You have to read a lot of code to find even a tiny part of this hidden structure.</p>
</div>
<div class="paragraph">
<p>The developer who maintains the application tells me this is a fair projection of the complexity that he has to deal with.</p>
</div>
<div class="paragraph">
<p>To be fair, some of the dependencies in this diagram are 'good' dependencies (as described in Section 3.1 on good and bad dependencies). For example, the box near south-east called ScpProtocolManager has a lot of dependencies coming into it, which means it is possibly used a lot and therefore is a potential good abstraction. Ndepend does not know about the concept of good and bad dependencies, but if it did I would have it just display the bad ones.</p>
</div>
</div>
<div class="sect3">
<h4 id="truenew-ala-application-dependency-graphs"><a class="anchor" href="#truenew-ala-application-dependency-graphs"></a>3.11.2. New ALA application dependency graphs</h4>
<div class="paragraph">
<p>Here is the equivalent Ndepend generated class dependency graph for the new ALA version of the application.</p>
</div>
<div class="imageblock">
<div class="content">
<a class="image" href="images/new-datalink/classes-in-all-namespaces.png"><img src="images/new-datalink/classes-in-all-namespaces.png" alt="classes-in-all-namespaces.png"></a>
</div>
<div class="title">Figure 37. New ALA application - classes in all namespaces</div>
</div>
<div class="paragraph">
<p>Ndepend has tried to find the three ALA layers which are vertical and go from left to right. Only the Application sits in the top layer. The DomainAbstractions layer contains the next two columns of classes and a few from the next column. And the ProgrammingParadigms layer contains the rest on the right. Actually there were a couple of bad dependencies present when this graph was generated which have since been fixed. (There should be no dependency between Panel and OptionBox, nor between Wizard and WizardItem.) With these removed, the graph would form into the three abstraction layers.</p>
</div>
<div class="paragraph">
<p>The newly rewritten application is a work in progress at this point. However, as features are added, this is all the dependencies you will ever see. The Application already uses most of the domain abstractions we will ever need, and the domain abstractions already use the programming paradigm interfaces they need. There are a few DomainAbstractions to be added, but this is essentially what the  class dependency graph will look like.</p>
</div>
<div class="paragraph">
<p>This graph has the classes from all namespaces. But just for interest, here is ndpend&#8217;s namespace dependency graph.</p>
</div>
<div class="imageblock">
<div class="content">
<a class="image" href="images/new-datalink/namespaces.png"><img src="images/new-datalink/namespaces.png" alt="namespaces.png"></a>
</div>
<div class="title">Figure 38. New ALA application - namespaces</div>
</div>
<div class="paragraph">
<p>Remember in ALA, we do not use decomposition, so namespaces do not represent decomposition of the system. They represent layers. You can clearly see the three layers. The wiring namespace also goes in the programmingparadigms layer.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s drill inside the domain abstraction namespace to see the interdependencies within that layer. We expect to see no dependencies:</p>
</div>
<div class="imageblock">
<div class="content">
<a class="image" href="images/new-datalink/classes-in-domainabstractions-namespace.png"><img src="images/new-datalink/classes-in-domainabstractions-namespace.png" alt="classes-in-domainabstractions-namespace.png"></a>
</div>
<div class="title">Figure 39. New ALA application - classes in DomainAbstractions namespace</div>
</div>
<div class="paragraph">
<p>Ok here we see the two previously mentioned bad dependencies, and two other dependencies. They are on delegates or enums in the same source file, and so don&#8217;t count as bad dependencies.</p>
</div>
<div class="paragraph">
<p>And finally, let&#8217;s drill into the ProgrammingParadigms namespace</p>
</div>
<div class="imageblock">
<div class="content">
<a class="image" href="images/new-datalink/classes-in-programmingparadigms-namespace.png"><img src="images/new-datalink/classes-in-programmingparadigms-namespace.png" alt="classes-in-programmingparadigms-namespace.png"></a>
</div>
<div class="title">Figure 40. New ALA application - Classes in Programming Paradigms namespace</div>
</div>
<div class="paragraph">
<p>Again we see a few dependencies on delegates in the same source file which are ok. There is a couple of connector classes that depend on interfaces in this same layer. I consider them part of the interface from the programming paradigm point of view. They are in the same source file as a cohesive unit.</p>
</div>
<div class="paragraph">
<p>As of this writing, the new ALA version of the application is still a research project, but so far everything has gone smoothly with two weeks spent doing the description of the requirements as a diagram, and three months so far spent writing the domain abstractions. So far there are no issues getting it to actually execute. It is expected that we will actually commercialize the project soon and replace the old application.</p>
</div>
</div>
<div class="sect3">
<h4 id="truethe-applications-diagram"><a class="anchor" href="#truethe-applications-diagram"></a>3.11.3. The application&#8217;s diagram</h4>
<div class="paragraph">
<p>As we said in this chapter, diagrams can be an important aspect of ALA when the user story naturally contains a network of relationships among its instances of abstractions. In this application this is the case. There are UI relationships between elements of the UI. There are dataflow relationships between UI elements, data processing elements, and data sources. There are event-flows from UI to wizards and between wizards and the SaveFileBrowser. and there are minor dataflows such as a the filepath from the file browser to the csvFileReaderWriter.</p>
</div>
<div class="paragraph">
<p>Here is a sample section from the application diagram that shows all the relationships that implement the user story:</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="images/DatalinkApplication.xmind.png" alt="DatalinkApplication.xmind.png">
</div>
<div class="title">Figure 41. Xmind being used to design an application</div>
</div>
<div class="paragraph">
<p>This diagram was drawn using Xmind. It shows a single user story.  There is a UI with a menu item or a tool bar to start the user story. It then displays a browse dialogue to specify the location of the file. When the filepath has been selected, it gets data off a device on a COM port, using a protocol, and writes it to a CSV file. The data is also routed to be shown on a grid on the UI.</p>
</div>
<div class="paragraph">
<p>The user story diagram makes use of four different programming paradigms (which become four different interface types). Firstly there is the UI structure consisting of the window with its menubar, grid etc arranged inside it. Secondly, there is an event connection for when the menu is clicked which opens the browse dialog. Thirdly a dataflow connection carries the output of the browse dialog, a string containing the selected filepath, to the CSVFileReaderWriter. Another dataflow connection carries characters between the COM port and the SCPProtocol and another carries SCPcommands from the SessionDataSCP. The forth programming paradigm is a table dataflow that carries dynamic columns and rows of data from the SessionDataSCP object to the grid object in the UI and to the CSVFileReaderWriter.</p>
</div>
<div class="paragraph">
<p>Having drawn the diagram to represent the user story, we need to make the diagram execute. When we started this particular project we had no tool for automatically generating the code from the diagram, but during the project, one of the interns wrote a tool to do this. It parsed the Json output from Xmind and generated C# wiring code equivalent to what we will show below.</p>
</div>
<div class="paragraph">
<p>However, at first we were hand generating code, and it is instructive to know what this hand generated code looks like, just so we know how the diagram actually executes.</p>
</div>
<div class="paragraph">
<p>When we were hand generating the code, it was important that the code was readable from the point of view of seeing how it corresponds exactly with the diagram. (It wasn&#8217;t important that the code was readable from the point of view of seeing how the user story works - that was the job of the diagram.)  We had various conventions to support the one to one matching of diagram and code. One of these conventions was to indent the code to exactly mirror the tree structures in the diagram. Another was that whenever a new instance of an abstraction instantiated, all its ports would be wired immediately, and they would be wired in the order they were declared in the abstraction. This implies a depth first wiring strategy, analogous to walking the diagram tree depth first. Any ports with cross connections (the red lines in the diagram) would also be wired to their destinations at the time the abstraction were instantiated. If the destination instance did not already exist it would be pre-instantiated.</p>
</div>
<div class="paragraph">
<p>Using these conventions, it is a simple matter to hand generate the code below from the diagram.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>using System;
using System.Windows.Media;
using DomainAbstractions;
using Wiring;


namespace Application
{
    class Application
    {
        private MainWindow mainWindow = new MainWindow("App Name") { Icon = "XYZCompanyIcon"};

        [STAThread]
        public static void Main()
        {
            new Application().Initialize().mainWindow.Run();
        }

        private Application Initialize()
        {
            return this;
        }

        private Application()
        {
            var getInfoWizard = new Wizard("Get information off device") { SecondTitle = "What information do you want to get off the device?" };
            Grid DataGrid;
            var sessionDataSCP = new SessionDataSCP();
            var csvFileReaderWriter = new CSVFileReaderWriter();

            mainWindow
            // UI
                .WireTo(new Vertical()
                    .WireTo(new Menubar()
                        // XR3000
                        .WireTo(new Menu("File")
                            .WireTo(new MenuItem("Get information off device") { Icon = "GetDeviceIcon.png", ToolTip = "Get session data or LifeData or favourites from the device\nto save to a file or send to the cloud" }
                                .WireTo(getInfoWizard)
                            )
                            .WireTo(new MenuItem("Put information onto device") { Icon = "PutDeviceIcon.png" })
                            .WireTo(new MenuItem("Exit") { Icon = "ExitIcon.png" })
                        )
                        .WireTo(new Menu("Tools"))
                        .WireTo(new Menu("Help"))
                    )
                    .WireTo(new Toolbar()
                        // XR3000
                        .WireTo(new Tool("GetDeviceIcon.png") { ToolTip = "Get information off device" }
                            .WireTo(getInfoWizard)
                        )
                        .WireTo(new Tool("PutDeviceIcon.png") { ToolTip = "Put information onto device" })
                        .WireTo(new Tool("DeleteDeviceIcon.png") { ToolTip = "Delete information off device" })
                    )
                    .WireTo(new Horizontal()
                        .WireTo(new Grid() { InstanceName = "Sessions" })
                        .WireTo((DataGrid = new Grid() { InstanceName = "DataGrid" })
                            .WireFrom(sessionDataSCP)
                        )
                    )
                    .WireTo(new Statusbar()
                        .WireTo(new Text() { Color = Brushes.Green }
                            .WireFrom(new LiteralString("Connected to device"))
                        )
                    )
                );


            getInfoWizard
                .WireTo(new WizardItem("Get selected session files") { Icon = "IconSession.png", Checked = true }
                    .WireTo(new Wizard("Select destination") { SecondTitle = "What do you want to do with the session files?", ShowBackButton = true }
                        .WireTo(new WizardItem("Save selected sessions as files on the PC") { Icon = "SessionDocumentIcon.png", Checked = true }
                            .WireTo(new SaveFileBrowser("Select location to save data") { Icon = "SaveIcon.png", InitialPath = "%ProgramData%\XYZCompany"}
                                .WireTo(csvFileReaderWriter)
                            )
                        )
                        .WireTo(new WizardItem("Send records to NAIT") { Icon = "NAIT.png" })
                        .WireTo(new WizardItem("Send sessions to NLIS") { Icon = "NLIS.png" })
                    )
                    .WireTo(getInfoWizard)
                )
                .WireTo(new WizardItem("Get Lifedata"));

            var comPorts =
                new ComPortAdapter()
                    .WireTo(new SCPProtocol()
                        .WireTo(new SessionDataSCP()
                            .WireTo(DataGrid)
                            .WireTo(csvFileReaderWriter)
                        )

                    );

        }
    }
}</pre>
</div>
</div>
<div class="paragraph">
<p>We used a 'diagram first' rule to keep the diagram and code in sync. Change the diagram first, then change the wiring code.</p>
</div>
<div class="paragraph">
<p>As of this writing, a graphical IDE is being developed for these types of ALA applications.</p>
</div>
<div class="paragraph">
<p>da</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="truechapter-four-programming-paradigms-and-their-execution-models"><a class="anchor" href="#truechapter-four-programming-paradigms-and-their-execution-models"></a>4. Chapter four - Programming paradigms and their execution models.</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="trueintroduction-to-programming-paradigms"><a class="anchor" href="#trueintroduction-to-programming-paradigms"></a>4.1. Introduction to programming paradigms</h3>
<div class="paragraph">
<p>ALA fundamentally begins with the premise of using abstractions to achieve zero coupling at design-time. Zero coupling is preserved if relations between abstractions are always in the direction of greater abstraction. Thus abstraction layers emerge, with each layer significantly more abstract than the one above. It is interesting to observe how these layers seem to emerge typical usage patterns, which in turn give rise to their names: Application layer, User stories layer, Domain abstractions layer, Programming Paradigms layer, and so on.</p>
</div>
<div class="imageblock right">
<div class="content">
<img src="images/JacquardLoom.jpg" alt="JacquardLoom.jpg" width="400">
</div>
<div class="title">Figure 42. Jacquard loom as a programming paradigm for combining weave pattern rows</div>
</div>
<div class="paragraph">
<p>The layer below the domain abstractions is really interesting in this respect. When we compose or wire two or more instances of domain abstractions together, we need that to have a meaning. Here are some common examples:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Imperative ((sequential activities in computer time)</p>
</li>
<li>
<p>event driven</p>
</li>
<li>
<p>dataflow</p>
</li>
<li>
<p>UI layout</p>
</li>
<li>
<p>activity flow (sequential activities in real time)</p>
</li>
<li>
<p>state machine transition</p>
</li>
<li>
<p>state machine substate</p>
</li>
<li>
<p>data schema</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These are all quite abstract concepts. They have great potential for reuse. We call them programming paradigms because each is a different way of thinking about programming. Each gives different meaning to composition. We call the layer they go in <em>programming paradigms</em>.</p>
</div>
<div class="paragraph">
<p>It is an essential part of ALA that we can use multiple programming paradigms in the same user story. In ALA, user stories (or features) are cohesive abstractions. To completely describe a user story, common programming paradigms needed may be UI layout,  dataflow, activity and data schema. This use of multiple programming paradigm is referred to as polyglot programming paradigms.</p>
</div>
<div class="paragraph">
<p>The programming paradigms layer may also contain other abstractions useful for building domain abstractions, but are not used as relationships between instances of abstractions. Examples are the concepts of 'Persistence' or 'Styles'. In this chapter we will be concentrating on programming paradigms used to compose instances of domain abstractions, and showing the ways they actually execute, which is called their execution model.</p>
</div>
<div class="paragraph">
<p>Here is Peter Van Roy&#8217;s taxonomy of programming paradigms which gives us an idea of what the term "programming paradigm" means in general. Peter Von Roy is an advocate for multiple programming paradigms in a computer language, which is why the language Oz appears all over the diagram. In ALA we invent and implement our own programming paradigms, without relying on them being built into the underlying programming language.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/TaxonomyProgrammingParadigms.png" alt="TaxonomyProgrammingParadigms.png">
</div>
<div class="title">Figure 43. Taxonomy Programming Paradigms - cited from Van Roy</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>In ALA "programming paradigms" are used to compose instances of domain abstractions. The programming paradigm provides "the meaning of composition".</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Programming paradigms are by no means limited to the ones discussed in this chapter. Custom ones can be invented as needed (when they allow better expression of the requirements). We do this with the example at the end of this chapter for scoring games such as Bowling or Tennis. We use a 'ConsistsOf' programming paradigm which allows us to express that a match consists of sets, a set consists of games, and so on.</p>
</div>
</div>
<div class="sect2">
<h3 id="trueintroduction-to-execution-models"><a class="anchor" href="#trueintroduction-to-execution-models"></a>4.2. Introduction to execution models</h3>
<div class="paragraph">
<p>Programming paradigms and execution models are closely related but not precisely the same thing. Programming paradigms are the meaning of composition. Execution models are how we make that meaning actually work. Essentially, the execution model is how the underlying imperative programming paradigm of the CPU is going implement the new programming paradigm.</p>
</div>
<div class="paragraph">
<p>Some programming paradigms can have simple execution models. They can be implemented with an interface with one method. The simplest example of this is the synchronous event programming paradigm:</p>
</div>
<div class="listingblock">
<div class="title">IEvent.cs</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">namespace ProgrammingParadigms
{
    interface IEvent
    {
        void Send();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Such an interface looks like it adds nothing, but it transforms  programming to a paradigm of composing instances of abstractions in an infinite variety of possible ways.</p>
</div>
<div class="paragraph">
<p>Ports use instances of these interfaces. Essentially the interface allows any output port using this paradigm to be wired to any input port using this paradigm.</p>
</div>
<div class="paragraph">
<p>Other programming paradigms may require an engine or framework. Possible ways these execution models could work is discussed under each programming paradigm in this chapter.</p>
</div>
</div>
<div class="sect2">
<h3 id="truecoding-execution-models"><a class="anchor" href="#truecoding-execution-models"></a>4.3. Coding execution models</h3>
<div class="paragraph">
<p>Here we just show simple code examples for two execution models for the event driven programming paradigm to get a grounding at the code level.</p>
</div>
<div class="sect3">
<h4 id="truesynchronous-events"><a class="anchor" href="#truesynchronous-events"></a>4.3.1. Synchronous events</h4>
<div class="paragraph">
<p>The interface for synchronous events was given just above.</p>
</div>
<div class="paragraph">
<p>The difference between this and your everyday common imperative function call or method call is only the indirection. The sender doesn&#8217;t know who it&#8217;s calling. (In conventional code, indirection creates problems, but in ALA these problems do not exist, so all communications use this type of indirection. This is discussed further later.)</p>
</div>
<div class="paragraph">
<p>First let&#8217;s create two dummy domain abstractions with ports using the synchronous event driven programming paradigm. The two domain abstractions will use and implement this interface respectively:</p>
</div>
<div class="listingblock">
<div class="title">A.cs</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">using System;
using ProgrammingParadigms;

namespace DomainAbstractions
{
    class A
    {
        private IEvent output; <i class="conum" data-value="1"></i><b>(1)</b>

        public void start()
        {
            Console.WriteLine("1");
            output?.Send();
            Console.WriteLine("3");
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The output port is a private field of type interface</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">B.cs</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">using System;
using ProgrammingParadigms;

namespace DomainAbstractions
{
    class B : IEvent <i class="conum" data-value="2"></i><b>(2)</b>
    {
        // input port
        void IEvent.Send()
        {
            Console.WriteLine("2");
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The input port is an implemented interface</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Now we can write an application that wires an instance of A to an instance of B.</p>
</div>
<div class="listingblock">
<div class="title">Application.cs</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">using System;
using DomainAbstractions;
using ProgrammingParadigms;
using Foundation;

namespace Application
{
    class Application
    {
        static void Main(string[] args)
        {
            var program = new A().WireTo(new B()); <i class="conum" data-value="1"></i><b>(1)</b>
            program.start();
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The meat of the application wires an instance of class A to an instance of class B.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The output of the program is "123".</p>
</div>
<div class="paragraph">
<p>The Main function instantiates one instance of each of our domain abstractions, and wires them together. (If you have not seen the WireTo abstraction before, it is an extension method that uses reflection to search in class A for a private variable with a type that is an interface. It then sets it pointing to the instance of B if B implements the interface. WireTo is not central to the current discussion, the IEvent interface is.  WireTo is discussed in more detail in the example projects of chapters two and three.)</p>
</div>
<div class="paragraph">
<p>Notice just how abstract IEvent is. It&#8217;s highly reusable. It&#8217;s not specific to any domain abstraction or the application. It just knows how to transmit/receive an event. Because it is so abstract, it is stable. The more domain abstractions that depend on it the better, as that will allow them to be wired together in arbitrary ways, which gives us composability.</p>
</div>
<div class="paragraph">
<p>The IEvent interface can be compared with the observer pattern (publish/subscribe) which also claims to achieve decoupling. However the observer pattern only reverses the dependency of a normal method call. Instead of the sender knowing about the receiver, the receiver knows about the sender (when it registers for the event). If the sender and receivers are peers in the same layer, the observer pattern does not solve the problem. The IEvent interface decouples in both directions. The job of 'subscribing' is moved to the application layer, because only the application should have the knowledge of what should be wired with what.</p>
</div>
</div>
<div class="sect3">
<h4 id="trueasynchronous-events-the-event-loop"><a class="anchor" href="#trueasynchronous-events-the-event-loop"></a>4.3.2. Asynchronous events (the event loop)</h4>
<div class="paragraph">
<p>In the above example, we used the word <em>event</em>, but implemented it in a specific way (a synchronous method call). The terms <em>event</em> and <em>event driven</em> may have overloaded meanings. To some it may mean asynchronous or it may mean observer pattern (an event is a public thing you can subscribe to), or it may mean both.</p>
</div>
<div class="paragraph">
<p>In ALA the term means neither of these. As a programming paradigm it simply means that we think of programming as reacting to what happens instead of prescribing what will happen next - a reactive rather than prescriptive programming style. They can be either synchronous or asynchronous. They are never public - the layer above always wires them up from point to point explicitly. Events can be wired to fan-in or fan-out.</p>
</div>
<div class="paragraph">
<p>We discuss the meaning of synchronous and asynchronous in more depth later, but here we just want to see how asynchronous can be implemented at the code level. Synchronous and asynchronous are two different execution models for the same programming paradigm.</p>
</div>
<div class="paragraph">
<p>To implement the asynchronous execution model, conventional code may use an event loop that works something like this: the originator of the event calls a Send method on an EventLoop object. It passes a reference to a function or method of another object that it wants to send the event to. The Send method in EventLoop creates an object that represents the event and puts it into a queue. The Send method then returns. The main loop resides in this EventLoop object. It loops taking events from the queue one at a time and calls the referenced function or method. This is sometimes called the reactor pattern, but its actually a simplified version of reactor so we will call it simply an <em>event loop</em>.</p>
</div>
<div class="paragraph">
<p>For ALA, the only difference is that the sender can not specify the receiver function and object.</p>
</div>
<div class="paragraph">
<p>Here is the application layer code:</p>
</div>
<div class="listingblock">
<div class="title">Application.cs</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">using System;
using DomainAbstractions;
using ProgrammingParadigms;
using Foundation;

namespace Application
{
    class Application
    {
        static void Main(string[] args)
        {
            // instantiate an asynchronous execution model
            var eventLoop = new EventLoop();

            // Wire using the asynchronous execution model
            var program = new A().WireTo(new B(), eventLoop); <i class="conum" data-value="1"></i><b>(1)</b>
            program.Start();

            eventLoop.Start();
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The meat of the application wires an instance of class A to an instance of class B.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The difference with our previous synchronous application is that we first spin up an asynchronous execution engine object called eventLoop. The WireTo is used in the same way except that we pass in the execution model.</p>
</div>
<div class="paragraph">
<p>Here are the A and B dummy domain abstractions again. They are identical to the ones we used for the synchronous version above.</p>
</div>
<div class="listingblock">
<div class="title">A.cs</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">using System;
using ProgrammingParadigms;

namespace DomainAbstractions
{
    class A
    {
        private IEvent output;

        public void Start()
        {
            Console.WriteLine("1");
            output?.Send();
            Console.WriteLine("3");
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">B.cs</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">using System;
using ProgrammingParadigms;

namespace DomainAbstractions
{
    class B : IEvent
    {
        // input port
        void IEvent.Send()
        {
            Console.WriteLine("2");
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When this program runs, it will print "132" instead of the "123" that the synchronous version did. At the domain abstraction level, we need to not care whether it is "123", or "132". If we do care, then we need to use a different programming paradigm.</p>
</div>
<div class="paragraph">
<p>Now let&#8217;s have a look at the programming paradigm abstraction to see how it works.</p>
</div>
<div class="listingblock">
<div class="title">AsynchronousEvent.cs</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">using System.Collections.Generic;
using Foundation;

namespace ProgrammingParadigms
{
    public interface IEvent <i class="conum" data-value="1"></i><b>(1)</b>
    {
        void Send();
    }


    static class EventLoopExtensionMethod <i class="conum" data-value="2"></i><b>(2)</b>
    {
        public static T WireTo&lt;T&gt;(this T A, object B, EventLoop engine, string APortName = null)
        {
            engine.WireTo(A, B, APortName);
            return A;
        }
    }




    class EventLoop
    {

        private List&lt;IEvent&gt; queue = new List&lt;IEvent&gt;(); <i class="conum" data-value="3"></i><b>(3)</b>

        public void WireTo(object A, object B, string APortName) <i class="conum" data-value="4"></i><b>(4)</b>
        {
            A.WireTo(new Intermediary(this, (IEvent)B), APortName);
        }

        public void Start()
        {

            while (!Console.KeyAvailable)
            {
                if (queue.Count &gt; 0)
                {
                    IEvent receiver = queue[0];
                    queue.RemoveAt(0);
                    receiver?.Send();
                }
            }
        }


        private class Intermediary : IEvent
        {
            private IEvent receiver;
            private EventLoop outerClass; // needed to access our outer class instance

            public Intermediary(EventLoop outerClass, IEvent receiver)
            {
                this.receiver = receiver;
                this.outerClass = outerClass;
            }

            void IEvent.Send() <i class="conum" data-value="5"></i><b>(5)</b>
            {
                outerClass.queue.Add(receiver);
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The abstraction begins with the interface itself, which is unchanged from the synchronous version.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Overload of the WireTo extension method. We want an extension method so that we can wire things up using the same fluent syntax as the standard WireTo. This WireTo overload differs from the usual WireTo by the extra parameter for passing in the AysnchronousEventLoop instance. The method simply defers to the WireTo method in the EventLoop class.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This mechanism of overloading the WireTo method can be used by any programming paradigm.</p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The EventLoop class keeps a list of events waiting for execution.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Unlike for the synchronous case, the sender&#8217;s port is not wired directly to the receiver&#8217;s port. An intermediary object is wired in-between. The class for the intermediary object is inside the EventLoop class as we don&#8217;t want it to be a public part of the EventLoop abstraction.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The WireTo method instantiates an intermediary object, stores the receiver object cast as the interface into it (which is effectively wiring the intermediary to the receiver), and then calls the standard WireTo in the Foundation layer to wire the sender to the intermediary object.</p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>When the sender calls Send on its output port, the intermediary object intercepts the synchronous call. The intermediary object queues the call in the EventLoop class and immediately returns. It actually queues the reference to the interface of the receiver.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The EventLoop class has a loop that takes the references to receiver objects out of the queue one at a time, and calls the IEvent&#8217;s Send method in the receiver.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In this example we have put the main loop inside the execution model for simplicity. We would not normally do this because we may have several different programming paradigms each with their own main loops. So we could have the main loop in the Foundation layer, and the different execution models would register a Poll method on it. Alternatively we could make the loop function an async function that awaits on an awaitable queue implementation.</p>
</div>
<div class="paragraph">
<p>As usual in ALA, we do not try to decouple anything inside the AsynchronousEvent.c abstraction. Everything in it cohesively works together.</p>
</div>
<div class="paragraph">
<p>The propose of the examples is to show that we can create our own programming paradigms and that their implementation can be simple.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="trueexecution-model-properties"><a class="anchor" href="#trueexecution-model-properties"></a>4.4. Execution model properties</h3>
<div class="paragraph">
<p>Now that we have the idea of what we mean by programming paradigms and execution models at the code level, we next need to discuss some general properties of execution models, such as direct vs indirect, synchronous vs asynchronous, push vs pull, etc. we will refer to these properties when discussing specific execution models later.</p>
</div>
<div class="paragraph">
<p>In conventional imperative code, the execution model is inherently synchronous in the use of the function or method call. In ALA we have free  choices for execution models. Also in conventional code, one of the forces is managing dependencies. This can influence the execution model. For example we might pull for a dependency reason even though we would rather push for a performance reason. In ALA, wiring does not involve dependencies, so we are free to focus on other design choices with respect to execution models.</p>
</div>
<div class="paragraph">
<p>In this section we will try to clarify what these design choices are for programming paradigms that mean communication. We will note the forces on these design choices.</p>
</div>
<div class="sect3">
<h4 id="truesideways-vs-down-vs-up-communications"><a class="anchor" href="#truesideways-vs-down-vs-up-communications"></a>4.4.1. Sideways vs down vs up communications</h4>
<div class="paragraph">
<p>In conventional code, communications generally follow dependencies directly. If we try to think in terms of layers, with dependencies always going down the layers, these communications always go either up or down. So we may not be used to thinking of sideways communications. Or if we do allow sideways dependencies within a layer, we may not be used to thinking about sideways communications and up/down communications as different things.</p>
</div>
<div class="paragraph">
<p>In ALA, we need to think of them differently. Let&#8217;s refer to sideways communications as <em>wired-communications</em>, and up/down communications as <em>abstraction-use-communications</em>.</p>
</div>
<div class="paragraph">
<p>A common example of abstraction-use communication is when you configure an instance of an abstraction by passing parameters to the constructor, or by calling setters. Another example is calling a squareroot function in your math library. A common example of upward communication using abstraction-use-communication is executing a lambda expression that has previously been passed in to an instance of an abstraction during its configuration. Upward calls are always indirect in some way, such as the mentioned lambda expression, passing in an anonymous or named function, observer pattern (publish subscribe), callback, or strategy pattern. We don&#8217;t use virtual functions in ALA for up calling because we don&#8217;t need or want to use inheritance.</p>
</div>
<div class="paragraph">
<p>A common example of <em>wired-communications</em> is when an instance of an abstracton sends something out on a port. It arrives at the input port of another instance of an abstraction to which it was wired by the layer above.</p>
</div>
<div class="paragraph">
<p>In all the following discussions of programming paradigms, we will be talking about <em>wired-communications</em> unless noted otherwise. Note that we use the word <em>communications</em> to cover for both events and dataflow types of programming paradigms. Another common term is <em>message</em>.</p>
</div>
</div>
<div class="sect3">
<h4 id="trueindirect-function-calling"><a class="anchor" href="#trueindirect-function-calling"></a>4.4.2. Indirect function calling</h4>
<div class="paragraph">
<p>Sideways communications in ALA is <em>always</em> indirect. The sender never names the receiver or the function or method in that receiver. Conversely, receivers never register themselves to a sender, or to a public event. Global event names are never used. Communications always follows the wiring put in place by the layer above.</p>
</div>
<div class="paragraph">
<p>In conventional code, there is a downside associated with indirection, which is tha it becomes harder to follow the flow of execution through the modules for a given user story. That downside does not exist for ALA. In fact it is the opposite - it is easier to trace the flow of calls through the system. This is because user stories are expressed in one place cohesively. You see all the explicit wiring of a user story abstraction in one place instead of tracing it through multiple modules. Only if an abstraction it uses does something unexpected do you need to drop down inside the abstraction, and enter a different self-contained self-cohesive set of code.</p>
</div>
<div class="paragraph">
<p>When reading code inside an abstraction, it is in the very nature of abstractions that they know nothing of the outside world. They do not need or want to know where events come from or go to externally. Indirection is used so that flow can lift out of the internals of an abstraction to the more specific wiring code in a layer above.</p>
</div>
<div class="paragraph">
<p>Even synchronous function calls are always indirect. At run-time, the inside of one abstraction synchronously calls a method inside another abstraction under the direction of the wiring in the layer above. But at design-tie, it has no knowledge of what that other abstraction or method is. Whether the run-time execution model is synchronous or asynchronous, push or pull, with fan-out or fan-in, the wiring model between instances of abstractions with ports is always indirect.</p>
</div>
<div class="paragraph">
<p>Even if the communications is asynchronous, the caller does not send the event to a particular destination, nor does it give the event a global name so that receivers can register to it. Both patterns would involve a bad dependency. Instead it still only goes as far as its own output port.</p>
</div>
<div class="paragraph">
<p>Conventional code will often use an interface or the observer pattern (publish-subscribe) (or C# events) to invert a dependency. If the two modules were peers in the same layer, inverting the dependency by adding an indirection only makes the program even more difficult to follow. ALA does not need to use the dependency inversion principle or the observer pattern for peer to peer communications because there is no dependency. In other words ALA completely sidesteps the dependency inversion principle and the observer pattern for all communications between peers.</p>
</div>
<div class="paragraph">
<p>ALA generally uses dependency injection directed by explicit wiring.</p>
</div>
<div class="paragraph">
<p>Having said that ALA does not use the observer pattern (or any other form of the receiver subscribing to senders in the same layer), the observer pattern is sometimes used within a programming paradigm interface. Consider a programming paradigm where communications is needed in both directions. In the same direction as the wiring, it is usually implemented as a simple method call. The way interfaces work in our programming languages, the A end uses the interface and the B end implements it. The asymmetry is a shame. If we want a method call in the other direction, we use the observer pattern inside the interface. The publisher, the B end, implements the observer pattern. The subscriber, the A end, subscribes to it. The difference from the standard observer pattern is that the subscriber does not know the publisher. It is only subscribing to it indirectly via the interface.</p>
</div>
<div class="paragraph">
<p>If a dependency were going up from one abstraction layer to a higher one, then of course we invert the dependency. But a dependency from a more abstract abstraction to a more specific one doesn&#8217;t make sense in the first place and so this situation never occurs. The dependency inversion principle is already built into the ALA constraints, so you never need to invert dependencies later.</p>
</div>
</div>
<div class="sect3">
<h4 id="truepush-vs-pull"><a class="anchor" href="#truepush-vs-pull"></a>4.4.3. Push vs pull</h4>
<div class="paragraph">
<p>If we are using standard synchronous function calls or method calls as the execution model, we have a choice between push and pull. In other words, does the sender of an event or data initiate the call, or does the receiver?</p>
</div>
<div class="paragraph">
<p>Push</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">Send(data);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Pull</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">data = Receive();</code></pre>
</div>
</div>
<div class="paragraph">
<p>In conventional code, the decision as to whether to use push or pull is often dictated by the need to control the direction of dependencies. To change a pull to a push without reversing the dependency would require indirection or the observer pattern. Similarly, to change a push to a pull without reversing the dependency would require an indirection. So usually we use the one that allows us to use a simple function call with the dependency in the desired direction.</p>
</div>
<div class="paragraph">
<p>With ALA, most run-time communications take place within a layer, and there are no dependendencies between the abstractions involved. Instances of abstractions are wired using interfaces that represent programming paradigms:</p>
</div>
<div class="listingblock">
<div class="title">IDataflow.cs</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">namespace ProgrammingParadigms
{
    interface IDataflow&lt;T&gt;
    {
        void Push(T data);
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">IDataflow.cs</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">namespace ProgrammingParadigms
{
    interface IDataflowPull&lt;T&gt;
    {
        T Pull();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Because there are no dependency constraints, we are free to choose between push and pull. Usually it would be for performance reasons. If the source data changes infrequently we would use push. If source data changes frequently, and the receiver only needs the value infrequently, we could choose to use pull.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>An example of pull is getting data from a database. Pulling is the only choice that makes sense because any particular data is needed so infrequently. And pushing is the only sensible choice for putting data into a database. For this reason, in conventional code, the dependency is almost always towards the database. This is not the desired direction. Clean architecture reverses this dependency. But we don't want the reverse dependency either. So clean architecture will use a set of adapters that have dependencies both on the business logic interfaces and the database. ALA uses no dependencies on the business logic. In effect it will use a single adapter with dependencies on both a programming paradigm interface and the database.</pre>
</div>
</div>
<div class="paragraph">
<p>It would be nice if you could choose between push and pull at wiring time. In other words, we design domain abstraction ports to handle both push or pull, and you choose push or pull when wiring instances in the application. For example a signal filter could support both push and pull. If not we might need two version of the filter.  Unfortunately it increases the amount of code inside the abstractions. So we usually write abstraction ports to use either push or pull.</p>
</div>
<div class="paragraph">
<p>To allow optimal composability of abstractions, I use push ports by default so that most ports can be wired directly. Push also works quite naturally for events. It means that the initiator of an event pushes it as soon as it happens. The opposite is possible: receivers poll the source when they are interested to know if an event has occurred.</p>
</div>
<div class="paragraph">
<p>For dataflows, push means that the data 'flows' whenever it changes. This works better performance-wise if the data does not change too frequently. It works well when all data must be processed. It is ok when all the data does not need to be processed, and only the latest data is important. Push is usually more efficient than periodically polling for data.</p>
</div>
<div class="paragraph">
<p>A final factor in the preference to use push by default is that push ports can be wired for either synchronous or asynchronous execution models without changing the domain abstractions (discussed above in the section on synchronous vs asynchronous). To allow this for pull ports requires the pull end to be written for an asynchronous execution model, which can be awkward. This aspect is discussed more fully in the section on the request/response programming paradigm later.</p>
</div>
<div class="paragraph">
<p>For all the above reasons we use push ports by default, and pull ports when we have to. It is analogous to using RX (reactive extensions).</p>
</div>
<div class="paragraph">
<p>Remember we are talking about 1-way communcations. In a later section we discuss programming paradigms that use 2-way communications.</p>
</div>
<div class="sect4">
<h5 id="truewiring-incompatible-push-pull-ports"><a class="anchor" href="#truewiring-incompatible-push-pull-ports"></a>Wiring incompatible push &amp; pull ports</h5>
<div class="paragraph">
<p>It is possible to wire together instances of domain abstractions that have incompatible ports with respect to push and pull, provided the communications becomes asynchronous. A send port that uses push can be wired to a receive port that uses pull. And a send port that uses pull can be wired to a receive port that uses push. This can even be done automatically, so that the user story doing the wiring does not need to worry about it.</p>
</div>
<div class="paragraph">
<p>For the case of a push send port being wired to a pull receive port, the wiring system detects this situation and wires in an intermediary object which is an instance of a simple buffer abstraction. If the paradigm is simple events, the abstraction stores a flag for whether or not the event has been sent. When the receiver pulls the event, it clears the flag.</p>
</div>
<div class="paragraph">
<p>For the case of a pull send port being wired to a push receive port, the wiring system detects this situation and wires in an intermediary object which is an instance of a simple polling abstraction. This instance is configured with a default polling rate. It polls the sender periodically to see if the event has occurred, and then calls the receiver if it has. For dataflow, it calls the sender periodically, and then calls the receiver at least once and thereafter whenever the  data changes.</p>
</div>
<div class="paragraph">
<p>A situation where a sender may want to have a pull port is a driver that gets data from the outside world. The driver doesn&#8217;t want the responsibility of controlling when the external read takes place. So it will use a pull port so it reads at a time determined by the user story. The user story will either configure the polling rate of the intermediary or configure an active object somewhere that will pull the data when needed.</p>
</div>
<div class="paragraph">
<p>Another situation to use pull is where the sender is completely passive or lazy. For example, it doesn&#8217;t want to execute a computationally expensive routine until the output is needed.</p>
</div>
<div class="paragraph">
<p>Another situation where a pull port makes sense is an abstraction with many inputs. We want the abstraction to react when a specific port receives data or an event. If we don&#8217;t want to buffer the data coming in on other inputs internally in the abstraction, we can just make them pull ports. If they need to be wired to push ports, then intermediary buffer objects would be wired in.</p>
</div>
<div class="paragraph">
<p>When a sender with a push port is wired to a receiver with a pull port using a buffer intermediary object, a situation can arise where the sender produces data faster than the receiver consumes it. In some cases this wont matter. In other cases the user story has the knowledge of how to resolve the situation. It can wire in an averager or filter abstraction. If the receiver must process all the data, and the sender produces data only in bursts, the user story can wire in a FIFO abstraction to smooth out the rate of data. The Fifo can have a reverse <em>flow control</em> channel that tells the source when to stop and start so the fio doesn&#8217;t overflow. If none of these solutions work, the user story can wire in a load splitter to multiple receivers.</p>
</div>
<div class="paragraph">
<p>If pull ports are quite common, we may then want 'pull' versions of some domain abstractions. For example, we may need a filter abstraction to have a pull variant.</p>
</div>
<div class="paragraph">
<p>In summary, I use push ports for domain abstractions by default. In situations where this doesn&#8217;t suit I can still use pull ports. When  incompatible ports need to be wired, then a variety of intermediary objects can be wired in to solve the issues without having to change the sender or receiver abstractions.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="truefan-in-fan-out-wiring"><a class="anchor" href="#truefan-in-fan-out-wiring"></a>4.4.4. Fan-in, fan-out wiring</h4>
<div class="paragraph">
<p>In chapter three, we used the terms <em>fan-in</em> and <em>fan-out</em> in relation to dependencies down layers. Here the terms <em>fan-in</em> and <em>fan-out</em> are used for something completely different. Here we are talking about wiring.</p>
</div>
<div class="paragraph">
<p>Fan-out means that an output port of one instance of an abstraction is wired to many instances. Fan-in means many instances are wired to a single input port. It depends on what makes sense for each particular programming paradigm.</p>
</div>
<div class="sect4">
<h5 id="truefan-out-implementation"><a class="anchor" href="#truefan-out-implementation"></a>Fan-out implementation</h5>
<div class="paragraph">
<p>Some programming paradigms support fan-out out of the box. An example is the UI programming paradigm. Many UI domain abstractions have a list port for  child UI elements. The WireTo can wire directly from this port to multiple instances of other UI elements.</p>
</div>
<div class="paragraph">
<p>Most output ports of domain abstractions for other programming paradigms do not use a list for their output ports, so they do not directly support fanout. This is because they are usually wired one point. If they used a list, then the domain abstraction internal code would need to use a <em>for</em> loop to output to every instance in the list. We can still do fanout using an intermediary object. This intermediary object simply contains the needed for loop. An example of such an intermediary for the Dataflow programming paradigm is:</p>
</div>
<div class="listingblock">
<div class="title">IDataFlow.cs</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">/// &lt;summary&gt;
/// DataFlowFanout has multiple uses:
/// 1) Allows fanout from an output port
/// 2) If the runtime order of fanout dataflow execution is important, DataFlowFanout instances can be chained using the Last port, making the order explicit.
/// 3) Allows an abstraction to have multiple input ports of the same type. (A C# class can implement a given type of interface only once.)
/// --------------------------------------------------------------------------------
/// Ports:
/// 1. IDataFlow&lt;T&gt; implemented interface: incoming data port
/// 2. List&lt;IDataFlow&lt;T&gt;&gt; fanoutList: output port that can be wired to many places
/// 3. IDataFlow&lt;T&gt; last: output port that will output after the fanoutList and IDataFlow_B data changed event.
/// 4. IDataFlow_B&lt;T&gt; implemented interface: ouput port but is wired opposite way from normal.
/// &lt;/summary&gt;

public class DataFlowFanout&lt;T&gt; : IDataFlow&lt;T&gt;, IDataFlowPull&lt;T&gt;, IDataFlow_R&lt;T&gt;  <i class="conum" data-value="1"></i><b>(1)</b> <i class="conum" data-value="2"></i><b>(2)</b> <i class="conum" data-value="3"></i><b>(3)</b>
// input, pull output, push output
{
    // properties
    public string InstanceName = "";

    // ports
    private List&lt;IDataFlow&lt;T&gt;&gt; fanoutList = new List&lt;IDataFlow&lt;T&gt;&gt;(); <i class="conum" data-value="4"></i><b>(4)</b>
    // ouptut port that supports multiple wiring

    private IDataFlow&lt;T&gt; Last; <i class="conum" data-value="5"></i><b>(5)</b>
    // output port that outputs after all other outputs to allow controlling order of execution through chaining instances of these connectors.


    // IDataFlow&lt;T&gt; implementation (input) ---------------------------------
    void IDataFlow&lt;T&gt;.Push(T data) <i class="conum" data-value="6"></i><b>(6)</b> <i class="conum" data-value="7"></i><b>(7)</b>
    {
        this.data = data; // buffer the data in case its needed by the pull output
        foreach (var f in fanoutList) f.Push(data);
        push_R?.Invoke(data);
        Last?.Push(data); <i class="conum" data-value="5"></i><b>(5)</b>
    }

    // IDataFlowPull&lt;T&gt; implementation ---------------------------------
    private T data = default;  // used to buffer data for later pull on the output port
    T IDataFlowPull&lt;T&gt;.Pull() { return data; } <i class="conum" data-value="7"></i><b>(7)</b>

    // IDataFlow_R&lt;T&gt; implementation ---------------------------------
    // make explicit so it's not visible without using the interface
    private event PushDelegate&lt;T&gt; push_R;
    event PushDelegate&lt;T&gt; IDataFlow_R&lt;T&gt;.Push { add { push_R += value; } remove { push_R -= value; } } <i class="conum" data-value="7"></i><b>(7)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>IDataFlow&lt;T&gt; is the input port</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>IDataFlowPull is an output port (purpose discussed later)</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>IDataFlow_R is an output port (purpose discussed later)</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Output port that&#8217;s a list to support fan-out. WireTo will wire it any number of times.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Output port called Last (purpose discussed later)</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Implementation of the input port. When data arrives at the input, it outputs the data directly to all the different output ports, including to every destination in the fanout output port list.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>All implemented interfaces are implemented explicitly in C# (not implicitly). There are two reasons for this in ALA: 1) We only want the interface&#8217;s method/event to be visible through a reference to the interface, not the public interface of the class. The public interface of the class is for the layer above to create and configure objects of the class. It generally has no need to access the ports of the class at run-time, and if it did we would want to cast to the interface to make that clear. 2) If there were two interfaces using the same method name or same event delegate, we will want to implement them separately.</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="truefan-out-ordering"><a class="anchor" href="#truefan-out-ordering"></a>Fan-out ordering</h5>
<div class="paragraph">
<p>The need for fan-out in the wiring is common for many programming paradigms. The order of the synchronous calls to the different fan-out destinations may or may not be significant. Only the layer above doing the wiring knows if the order is significant. Sometimes it is sufficient for the order to be defined as the order they are wired in, or ’down’ in a diagram. The UI fanout works this way to control top to bottom or left to right UI layouts. This is a satisfactory way to define order in a UI.</p>
</div>
<div class="paragraph">
<p>For events or Dataflows, this is not considered explicit enough. Where order matters, we should use ”Activity Flow” (exactly analogous to UML activity diagrams) to control ordering. The order can be controlled by using a chain of DataFlowFanout instances. DataFlowFanout has a port called <em>Last</em> which facilitate this chaining. Last is invoked after all other output ports.</p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <em>Last</em> port can be seen in the DataFlowFanout listing given above.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="truework-around-for-multiple-inputs-of-the-same-type"><a class="anchor" href="#truework-around-for-multiple-inputs-of-the-same-type"></a>4.4.5. Work around for multiple inputs of the same type</h4>
<div class="paragraph">
<p>C# and other languages don&#8217;t allow an interface to be implemented more than once. Sine we use interfaces as ports in ALA, this can be a serious limitation.</p>
</div>
<div class="paragraph">
<p>For example, consider implementing an AND gate with 4 inputs all IDataFlow&lt;bool&gt;.</p>
</div>
<div class="listingblock">
<div class="title">AndGate.cs</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">    public class AndGate : IDataFlow&lt;bool&gt;, IDataFlow&lt;bool&gt;, IDataFlow&lt;bool&gt;, IDataFlow&lt;bool&gt;
    {
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Implementing IDataFlow&lt;bool&gt; more than once like that gives a compiler error.</p>
</div>
<div class="paragraph">
<p>It&#8217;s a valid thing to do however. I can only assume that outside of ALA, no one seems to have needed it. In fact the whole concept of <em>ports</em> should be part of all object oriented languages. Only then would OOP realize it&#8217;s potential for reuse. (ALA is really just OOP done right.)</p>
</div>
<div class="paragraph">
<p>If the C# language allowed the same interface to be implemented multiple times, the only syntactical difference would be that the implementations would be given names:</p>
</div>
<div class="listingblock">
<div class="title">AndGate.cs</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">    // We want to do this, but can't in C#
    public class AndGate : IDataFlow&lt;bool&gt; Input1, IDataFlow&lt;bool&gt; Input2, IDataFlow&lt;bool&gt; Input3, IDataFlow&lt;bool&gt; Input4
    {
        void Input1.Push(bool data)
        {
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>You would be able to set a reference to the object&#8217;s interface using this name instead of casting to the interface type.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">// We want to do this, but can't in C#
var ag = new AndGate();
IDataFlow&lt;bool&gt; referenceToInput1 = ag.Input1;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Java almost allows this to be done using method references. But it only works when there is one method in the interface.</p>
</div>
<div class="paragraph">
<p>We already used a work-around for this limitation of C# in the <em>Add</em> domain abstraction in chapter 2. In that work-around we created a Double2 type which was a simple struct containing a double. That allowed us to implement both IDataFlow&lt;double&gt; and IDataFlow&lt;Double2&gt;. But it&#8217;s not a general solution.</p>
</div>
<div class="paragraph">
<p>A more general work-around for this limitation of C# is to use interface fields instead of interface implementations and reverse the wiring.</p>
</div>
<div class="listingblock">
<div class="title">AndGate.cs</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">    IDataFlow_R&lt;bool&gt; Input1;
    IDataFlow_R&lt;bool&gt; Input2;
    IDataFlow_R&lt;bool&gt; Input3;
    IDataFlow_R&lt;bool&gt; Input4;</code></pre>
</div>
</div>
<div class="paragraph">
<p>We append an "_R" to the name of the interface to indicate it is a 'reversed wired' interface. Here is the interface:</p>
</div>
<div class="listingblock">
<div class="title">IDataFlow.cs</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">    public delegate void PushDelegate&lt;T&gt;(T data);

    public interface IDataFlow_R&lt;T&gt;
    {
        event PushDelegate&lt;T&gt; Push(T data);
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The receiver registers an event handler method to the event in the interface:</p>
</div>
<div class="listingblock">
<div class="title">AndGate.cs</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">    private void Input1Initialize() <i class="conum" data-value="1"></i><b>(1)</b>
    {
        Input1.Push += PushHandler1;
    }

    private void PushHandler1&lt;T&gt;(T data) <i class="conum" data-value="2"></i><b>(2)</b>
    {
        ...
    }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>After the WireTo operator has wired a port, it looks for a method named &lt;Portname&gt;Intialize and calls it. This method is useful if the port&#8217;s interface has a C# event. It can be used to register a method to the event.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Method called for incoming data on port Input1.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To complete the workaround we need an intermediary object. Both the sender and receiver are wired <em>to</em> this object. It implements both IDataFlow&lt;T&gt; and IDataFlow_R&lt;T&gt;. The class for this object resides inside the IDataFlow programming paradigm abstraction:</p>
</div>
<div class="listingblock">
<div class="title">IDataFlow.cs</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">public class DataFlowIntermediary&lt;T&gt; : IDataFlow&lt;T&gt;, IDataFlow_R&lt;T&gt; // input, output <i class="conum" data-value="1"></i><b>(1)</b>
{
    void IDataFlow&lt;T&gt;.Push(T data) <i class="conum" data-value="2"></i><b>(2)</b>
    {
        push?.Invoke(data);
    }

    // IDataFlow_R&lt;T&gt; implementation ---------------------------------
    private event PushDelegate&lt;T&gt; push; <i class="conum" data-value="3"></i><b>(3)</b>
    event PushDelegate&lt;T&gt; IDataFlow_R&lt;T&gt;.Push { add { push += value; } remove { push -= value; } } <i class="conum" data-value="4"></i><b>(4)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Unlike normal output ports, this output port is an implemented interface.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>When data arrives on the input port it outputs it directly to the output port.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The output port interface has a C# event, which needs to be implemented.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The interface implemented explicitly so that the event is only accessible via a reference to the interface.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The above code is also added to the DataFlowFanout class listed above. See note 3 in that listing. This allows the DataFlowFanout intermediary object to be used for the purpose of this workaround among its other uses.</p>
</div>
<div class="paragraph">
<p>A problem with this workaround is that you need to wire in the reverse direction to the flow of data. So if data is to flow from A to B, we would need to write:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">var intermediary = new DataFlowFanout();
new A().WireTo(intermediary);
new B().WireTo(intermediary);</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is unintuitive at the wiring level.</p>
</div>
<div class="paragraph">
<p>We would prefer to write like we do normally:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">new A().WireTo(new(B));</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can write an override of WireTo in the programming paradigm abstraction and register it with the Foundation WireTo.</p>
</div>
<div class="paragraph">
<p>The override WireTo would look for a field interface in A that matches a field interface in B by name with a _R suffix.</p>
</div>
<div class="paragraph">
<p>TBD write the override WireTo.</p>
</div>
</div>
<div class="sect3">
<h4 id="truewiring-arbitrary-execution-models"><a class="anchor" href="#truewiring-arbitrary-execution-models"></a>4.4.6. Wiring arbitrary execution models</h4>
<div class="paragraph">
<p>To accomplish wiring, the application, feature or user story abstraction&#8217;s code makes calls to the WireTo method, passing in the two object/ports to be wired. The WireTo method, by default, wires the two objects by assigning the second object to a private field in the first object, provided the interface matches. This default behaviour sets up a direct connection between two communicating objects.</p>
</div>
<div class="paragraph">
<p>For arbitrary execution models, we don&#8217;t always want direct connection between connected objects. We may want an intermediate object to be automatically wired in, or other special behaviours. For example if the two objects being wired are in different locations, we will want to automatically wire in the necessary middleware intermediary objects. Intermediary objects are commonly needed in ALA. We have previously used them for several different purposes, such as asynchronous communications, pull communications, etc.</p>
</div>
<div class="paragraph">
<p>In the asynchronous programming code earlier in this chapter, we used an override of the WireTo method that had an extra parameter. But what if there is not extra parameter. Then the WireTo method that resides in the ALA foundation layer is the one that will be called. It can&#8217;t know anything about programming paradigms or execution models in higher layers. But it can know in an abstract way about allowing itself to be overridden.</p>
</div>
<div class="paragraph">
<p>The WireTo method in the foundation layer can support a list of registered override functions. It calls every override function in the list. If all return false, then it does its default behaviour.</p>
</div>
<div class="paragraph">
<p>The foundation WireTo can first do the reflection work. It can create lists of potential field and implemented interface ports in both the A and B objects. Then it can pass these lists to the override functions.</p>
</div>
<div class="paragraph">
<p>TBD Modify WireTo to support run-time overridding. Use it to implement a null decorator intermediary on the synchronous programming paradigm. Then use it to implement wiring of a push port to a pull port and a synchronousmiddleware for wiring objects in different locations.</p>
</div>
</div>
<div class="sect3">
<h4 id="truediamond-pattern-glitches"><a class="anchor" href="#truediamond-pattern-glitches"></a>4.4.7. Diamond pattern glitches</h4>
<div class="paragraph">
<p>Consider a wiring topology of an application in which wiring diverges from a single instance of an abstraction, and then converges to a single instance of an abstraction. The two paths will be executed at sightly different times. So one input of the end instance will get data from the common source before the other. During the time between the two, the inputs may be in an invalid state. This is what we mean by a glitch.</p>
</div>
<div class="paragraph">
<p>Glitches also happen in conventional code where they are a cross cutting concern. They also even happen in electronic circuits.</p>
</div>
<div class="paragraph">
<p>In ALA, they are a concern within a single abstraction, either the application abstraction, or a feature or user story abstraction. This is where the diamond topology of the wiring is apparent and the problem can be easily understood.</p>
</div>
<div class="paragraph">
<p>Abstractions may have a minor inputs which it expects to get data first and major input that triggers operation. In such a scenario, the application can control the order of execution in the wiring so that the major input gets its data last.</p>
</div>
<div class="paragraph">
<p>One solution is to provide an trigger event port on abstractions that have multiple inputs. The application must trigger the port once all inputs are valid.</p>
</div>
<div class="paragraph">
<p>It is a future topic of research to automatically detect glitches on abstractions with multiple inputs, and potentially to automatically resolve diamond wiring glitches.</p>
</div>
</div>
<div class="sect3">
<h4 id="truecircular-wiring"><a class="anchor" href="#truecircular-wiring"></a>4.4.8. Circular wiring</h4>
<div class="paragraph">
<p>In ALA, it is no problem to have circular data paths. Note that by <em>circular</em>, we are referring to wiring inside an abstraction, not dependencies between layers. Circular wiring naturally occurs in feedback systems, just as it does in electronics. It is nice to be able to represent such feedback systems directly in the wiring.</p>
</div>
<div class="paragraph">
<p>In conventional code, circular data paths may need a pull or an indirection to avoid circular dependencies. ALA does not have this problem. Circular wiring is as natural as it is in electronics.</p>
</div>
<div class="paragraph">
<p>A programming paradigm&#8217;s execution model needs to consider circular wiring. For example, circular wiring using all synchronous programming paradigm will result in an infinite loop at run-time, just as it does in conventional code. It easy to solve however. It can be as simple as an abstraction instance placed in the circuit that does an asynchronous call, or an abstraction instance that does a delay. This effectively causes a return to the main loop where the circuit can be called again. The main loop can process higher priority tasks first. It is no problem for such a circuit to repeat forever.</p>
</div>
<div class="paragraph">
<p>Alternatively, we can implement programming paradigms utilizing existing rigorous execution models, such as the discrete time execution models used in function blocks or clocked-synchronous execution models. The continuous time execution model underlying Functional Reactive Programming will automatically ﬂags such loops.</p>
</div>
<div class="paragraph">
<p>While circular data loops can occur in conventional code as well (recursion), they are more likely in ALA because ALA is likely to have dataflow abstractions which can easily be wired as a circuit. However, in ALA it is usually explicit and clear in the wiring diagram or code. The Calculator project in chapter two contained Dataflow loop circuits.</p>
</div>
</div>
<div class="sect3">
<h4 id="truesynchronous-vs-asynchronous"><a class="anchor" href="#truesynchronous-vs-asynchronous"></a>4.4.9. Synchronous vs asynchronous</h4>
<div class="paragraph">
<p>Although we already did simple coding examples for synchronous and asynchronous execution models at the start of this chapter, the design choice between synchronous and asynchronous needs deeper considerations.</p>
</div>
<div class="paragraph">
<p>Synchronous communication is like asking someone a question. You stop your life and wait, albeit for a brief time. You don&#8217;t resume your life until you get the answer or a nod. Asynchronous communication is like sending an e-mail.</p>
</div>
<div class="paragraph">
<p>Synchronous means that the calling code resumes execution after the callee has finished processing the communication.</p>
</div>
<div class="paragraph">
<p>There are reasons why you may want to use synchronous communications. The communication may cause a side effect, which we want to be sure is completed before continuing execution.</p>
</div>
<div class="paragraph">
<p>If the receiver will take a long time to execute, which can be for many reasons such as a long running algorithm, receiver not ready, external IO, a deliberate delay, etc, then a synchronous call will do what is referred to as blocking. Blocking means the thread will stop and wait. If the blocked thread needs to do something else in the meantime, this blocking will be a problem in one way or another.</p>
</div>
<div class="paragraph">
<p>In ALA we prefer single threaded solutions. Multi-threaded programming should only be used for performance reasons e.g. meeting a challenging latency or throughput requirement. A single threaded system will use run to completion, so in that respect is commonly referred to as cooperative. Being cooperative sounds like it doesn&#8217;t comply with ALA&#8217;s zero coupling. To some extent this is true, but the requirement to keep <em>all</em> routines short (non-blocking) can be thought of as an abstract requirement from a lower layer rather than relative coupling between domain abstractions. All higher abstractions need to know about this. Usually if nothing in an application blocks, the latencies needed for an application to respond to a human in reasonable time (which is the most common soft deadline requirement) will be acceptable. Using a single thread when things take time, or things need to happen in real time requires asynchronous communications.</p>
</div>
<div class="paragraph">
<p>Asynchronous means that the sender instance&#8217;s call returns before the callee has finished processing the communication. It will usually be before the callee even receives the communication.</p>
</div>
<div class="paragraph">
<p>Asynchronous calls can be implemented in several different ways. What they all have in common is that the caller makes a synchronous call that starts the communication or starts the callee&#8217;s execution in some way. The caller will then resume executing the next line of code pretty much immediately.</p>
</div>
<div class="paragraph">
<p>In ALA, as with the synchronous case, the caller does not know where it is sending the communication and the callee does not know where it came from. Where synchronous and asynchronous communications differ is only in when the call returns.</p>
</div>
<div class="paragraph">
<p>Note that here we are discussing the fundamental case of one way communication. We will consider two way communication programming paradigms later.</p>
</div>
<div class="paragraph">
<p>With one way communication, we have the option to decide at wiring time whether to use synchronous or asynchronous, provided the sender doesn&#8217;t care whether it resumes processing before or after the receiver gets or processes the message.</p>
</div>
<div class="paragraph">
<p>Some common ways of implementing asynchronous calls are:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The sender can make a synchronous call on the receiver, which just initiates an on-going activity and returns. It can be starting I/O, starting a timer, changing a state, etc.</p>
</li>
<li>
<p>The sender can make a synchronous call that just sets a flag, which is later polled by the main loop which then calls the receiver code.</p>
<div class="paragraph">
<p>In ALA this is easily implemented using an intermediary object that is wired between the caller and callee. See "Wiring arbitrary execution models" below. The intermediate object&#8217;s class resides inside the programming paradigm abstraction. It contains the flag. Within the programming paradigm abstraction, all the intermediary objects are put on a list. The main loop simply polls every object on the list. When the poll method in the object sees that the flag is set, it clears it and calls the callee.</p>
</div>
</li>
<li>
<p>The sender can make a synchronous call which is turned into an object which goes into a queue. The main loop takes these objects from the queue and calls the receiver code. In terms of run-time execution this is the same as the simple version of the reactor pattern or simply 'event loop'. Example code for this method was given above.</p>
</li>
<li>
<p>The sender can make a synchronous call which puts an object into the receiver&#8217;s queue on a different thread, process or processor.</p>
</li>
<li>
<p>If the language has async/await, the sender can call a method marked with the async keyword (without using await itself). The call returns immediately the first time the receiver awaits.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Other mechanisms are possible. Note that all of these mechanisms describe how the sender&#8217;s synchronous call returns before the receiver completes.</p>
</div>
<div class="paragraph">
<p>Remember that in all these implementation examples, we are talking about fundamental one-way communication - an event or pushing some data. Two-way communications gets more complicated, and is discussed below.</p>
</div>
<div class="paragraph">
<p>All the asynchronous programming paradigm execution models discussed above use pushing. Analogous pulling asynchronous communications are also possible. For an asynchronous pull, the receiver makes a synchronous call which returns a previously calculated result without waiting for the sender to calculate it. It returns the last result available from the sender, or a value from a FIFO, etc. The sender will calculate new values in its own time.</p>
</div>
<div class="paragraph">
<p>Asynchronous communications has inherent concurrency. This simply means that tasks of different features or user stories or channels or whatever can be executing in an interleaved fashion. That&#8217;s why we are using it. The concurrency is at a courser grained level compared with pre-emptive multitasking. There can still be a need to lock any resources that can be in an invalid state for a time, or to think in terms of <em>transactions</em>.</p>
</div>
</div>
<div class="sect3">
<h4 id="truewiring-incompatible-synchronousasynchronous-ports"><a class="anchor" href="#truewiring-incompatible-synchronousasynchronous-ports"></a>4.4.10. Wiring incompatible synchronous/asynchronous ports</h4>
<div class="paragraph">
<p>Generally ALA can use both asynchronous and synchronous execution models in its programming paradigms. It does not have rules for when to use one or the other. The design choices remain more or less the same as in non-ALA applications according to real-time factors discussed above.</p>
</div>
<div class="paragraph">
<p>However, ALA is all about abstractions and zero coupling at design-time. It would be good if the abstraction didn&#8217;t need to know whether the external communications beyond their ports is going to be asynchronous or synchronous. We would like to decide that when we wire instances of them up. It is therefore desirable that domain abstraction ports that generate events and ones that listen to events can be wired for either synchronous or asynchronous execution. That way, for example, they can be wired synchronously by default for best efficiency, but asynchronously if they are in different locations, or if the recipient will take a long time.</p>
</div>
<div class="sect4">
<h5 id="trueone-directional-case"><a class="anchor" href="#trueone-directional-case"></a>One directional case</h5>
<div class="paragraph">
<p>A sender port that is strictly one way can be coded to be synchronous and still be used asynchronously. The receiver can be either synchronous if the operation is quick, or asynchronous if the operation takes time. Either way the call returns quickly so that the sender is never blocked.</p>
</div>
<div class="paragraph">
<p>If it is strictly one way, we are not interested in the function call return value or its return timing. By <em>strictly</em> it means that the sender is zero-coupled with the reactions to the communication. It doesn&#8217;t care if it executes before our own next line of code or after.</p>
</div>
<div class="paragraph">
<p>In the example code at the beginning of this chapter, the domain abstractions did not change when we did the asynchronous version. But the order of output of system did. One was "123", and the other was "132". The application has knowledge of this order, but not the domain abstractions themselves.</p>
</div>
<div class="paragraph">
<p>If a certain domain abstraction needs to make an assumption that the next line of code executes after the call must execute after the effects of the call, then that abstraction knows something about the outside world. It isno longer an abstraction. It is probably orchestrating a side effect of some kind. It would need to be written differently and not use one-way communWhatever that orchestration is, it needs to be factored out into a higher layer where it will become cohesive code.</p>
</div>
</div>
<div class="sect4">
<h5 id="truetwo-directional-case"><a class="anchor" href="#truetwo-directional-case"></a>Two-directional case</h5>
<div class="paragraph">
<p>The two-directional, synchronous, case is familiar to us because it can be implemented with the common and elegant function call mechanism of the CPU.</p>
</div>
<div class="paragraph">
<p>Although a 2-way communication port can be implemented as a function call in the execution sense, in ALA it is always indirect. The function is always in an interface. The requester always has a reference to the reresponder, cast as the interface. The reference is always determined and set by the wiring in a higher layer. The interface itself always comes from a lower layer and is always more abstract, representing the request/response programming paradigm.</p>
</div>
<div class="paragraph">
<p>The subroutine call instruction can be thought of in this way: it passes both the request message and the CPU resource to the responder, and receives both the response message and the CPU resource back to the requester when done.</p>
</div>
<div class="paragraph">
<p>This allows the lines of code that are to be executed following the request/response completion to be written immediately following the call (direct style). We are so used to this that we take it for granted. But its actually a clever and elegant mechanism provided by the subroutine call instruction. Because of the convenience of this mechanism, the synchronous function call dominates as the default way to implement request/response in conventional code.</p>
</div>
<div class="paragraph">
<p>But the synchronous function call causes problems as soon as the function takes real time. For example, the responder may need to wait for input/output. Or, it may be in a different location or processor. Or it may have to delay. It will block the thread. Unlike the more fundamental one-way cases discussed earlier, if we want to use the CPU to do other work in the meantime during a real-time 2-way communication, life gets tricky in one way or another.</p>
</div>
<div class="paragraph">
<p>Unlike the one-direction case, a port cannot support both synchronous and asynchronous. Here are two example interfaces for synchronous and asynchronous respectively. For the asynchronous one, we have used callbacks because they are easy to understand, but there are other better mechanisms as will be discussed shortly.</p>
</div>
<div class="listingblock">
<div class="title">IRequestResponse.cs</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">namespace ProgrammingParadigms
{
    interface IRequestResponse&lt;T,R&gt;
    {
        R Request(T data);
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">IRequestResponseAsync.cs</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">namespace ProgrammingParadigms
{
    public delegate void CallbackDelegate&lt;R&gt;(R data);

    interface IRequestResponseAsync&lt;T,R&gt;
    {
        R Request(T data, CallbackDelegate callback); <i class="conum" data-value="1"></i><b>(1)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>For the asyncronous version of the interface, the request passes an additional parameter, the function to be called on completion.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Given that for 2-way communications, the interfaces for synchronous and asynchronous are different, you cannot directly wire a synchronous port to an asynchronous one or vice versa.</p>
</div>
<div class="paragraph">
<p>Ideally we would like to be able to wire instances of domain abstractions together without regard to whether the ports are synchronous or asynchronous. And we would like to be able to wire synchronous ports with  asynchronous wiring inbetween when we want to (for when they are on different processors.)</p>
</div>
<div class="paragraph">
<p>The only way to get this type of compatibility is for all senders to be asynchronous by nature. Asynchronous senders can work with either synchronous or asynchronous destinations. They can also work with asynchronous wiring (or synchronous wiring, provided the destination is synchronous).</p>
</div>
<div class="paragraph">
<p>Unfortunately, making senders asynchronous by nature means not using the function call mechanism.</p>
</div>
<div class="paragraph">
<p>A domain abstraction with an asynchronous output port needs to have a callback function:</p>
</div>
<div class="listingblock">
<div class="title">Sender.cs</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">namespace DomainAbstractions
{
    public class Sender
    {
        private IRequestResponseAsync&lt;string,string&gt; output;

        public void DoSomething()
        {
            output.Request("message", Callback);
        }

        public void Callback(string returnMessage)
        {
            Console.WriteLine(returnMessage);
            // next operation
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Of course, such a sender port can be wired directly to an instance of any domain abstraction implementing IRequestResponseAsync.</p>
</div>
<div class="paragraph">
<p>But the sender can also be wired to any domain abstraction implementing IRequestResponse (via a small intermediary object). The sender doesn&#8217;t care whether the callback is called back asynchronously or synchronously in the outgoing output.Request() call. Similarly if we had used a Task or Promise or async/await, it doesn&#8217;t care if the Task or Promise already in the <em>complete</em> state when it is returned.</p>
</div>
<div class="paragraph">
<p>Here is the intermediary object that needs to used when wiring an asynchronous port to a synchronous port:</p>
</div>
<div class="listingblock">
<div class="title">IRequestResponse.cs</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">public class RequestResponseAsyncToSyncIntermediary&lt;T,R&gt; : IRequestResponseAsync&lt;T&gt;, // input
{
    private IRequestResponse&lt;T,R&gt; output;

    void IRequestResponseAsync&lt;T,R&gt;.Request(T data, CallbackDelegate&lt;R&gt; callback)
    {
        R returnValue = output.Request(data);
        callback(returnValue);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can&#8217;t wire a sender with a synchronous port to an asynchronous destination. If we did, the call would return immediately without a result.</p>
</div>
<div class="paragraph">
<p>In summary, to have domain abstractions with two-way ports zero-coupled with respect to synchronous/asynchronous communications, the senders need to be asynchronous by nature.</p>
</div>
<div class="paragraph">
<p>Receivers with asynchronous ports can behave synchronously, but not the other way around.</p>
</div>
<div class="paragraph">
<p>If instances of any two abstractions are connected within the same processor they can both behave synchronously from a performance point of view. If instances are on different processors, asynchronous middleware can be easily wired in.</p>
</div>
</div>
<div class="sect4">
<h5 id="truemaking-sender-2-way-ports-asynchronous"><a class="anchor" href="#truemaking-sender-2-way-ports-asynchronous"></a>Making sender 2-way ports asynchronous</h5>
<div class="paragraph">
<p>Unfortunately, if you make all your domain abstractions that have 2-way requester ports asynchronous so that they are compatible with either asynchronous or synchronous responders, they must be written in the 'coding style' of asynchronous. While never impossible, this can be seriously awkward.</p>
</div>
<div class="paragraph">
<p>Mechanisms for asynchronous (2-way) calls include</p>
</div>
<div class="ulist">
<ul>
<li>
<p>using two separate one-directional calls, one in each direction (This is harder in conventional code, because you need to avoid circular dependencies. It is easy in ALA but requires two wirings. Intuitively a bi-directional port should need only one wiring.)</p>
</li>
<li>
<p>callbacks</p>
</li>
<li>
<p>coroutines or protothreads using Duff&#8217;s device</p>
</li>
<li>
<p>a promise or task object that will later have the result</p>
</li>
<li>
<p>continuations</p>
</li>
<li>
<p>async/await</p>
</li>
<li>
<p>a state machine (a <em>complete</em> event is sent back to the machine)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>We will cover most of these below, but first we need to know about direct programming style.</p>
</div>
</div>
<div class="sect4">
<h5 id="truedirect-programming-style"><a class="anchor" href="#truedirect-programming-style"></a>Direct programming style</h5>
<div class="paragraph">
<p>The problem with some of the mechanisms for asynchronous coding is that they don&#8217;t allow direct programming style. Direct style is when you can do successive operations with successive statements in a with simple syntax. For example, consider the following direct style synchronous code (which will block the thread):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">    RobotForward(7);
    Delay(1000);
    RobotTurnRight(90);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Using callbacks, it gets unwieldy:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">    void Step1() {RobotForward(7, Step2);}
    void Step2() {Delay(1000, Step3);}
    void Step3() {RobotTurnRight(90, null);}</code></pre>
</div>
</div>
<div class="paragraph">
<p>And with anonymous callbacks, even more unwieldy because of increasing indenting at each step:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">    RobotForward(7,
        ()=&gt;Delay(1000,
            ()=&gt;RobotTurnRight(90)
        )
    );</code></pre>
</div>
</div>
<div class="paragraph">
<p>That&#8217;s why some of the mechanisms listed above go to great lengths to allow direct programming style.</p>
</div>
<div class="paragraph">
<p>But even if you settle for callbacks or a state machine, at least it only affects code that is written inside a single domain abstraction where it is contained.</p>
</div>
</div>
<div class="sect4">
<h5 id="trueprescriptive-and-reactive-styles"><a class="anchor" href="#trueprescriptive-and-reactive-styles"></a>Prescriptive and reactive styles</h5>
<div class="paragraph">
<p>Callbacks or state machines have the advantage of not committing to <em>prescriptive style</em>. Prescriptive style means that we know what we expect to happen next. That&#8217;s why we want to use direct style so we can put what we expect to do next in the following statement.</p>
</div>
<div class="paragraph">
<p>But if something different may happen, then we want <em>reactive style</em>. We want to react to whatever events may happen in the meantime. In general we want to retain the flexibility to be reactive because during maintenance we learn about less likely scenarios.</p>
</div>
<div class="paragraph">
<p>Reactive style means we can easily add handling of unforeseen events to the code. There will almost always be a need to handle timeouts in abstractions because we don&#8217;t know to whom the ports will be wired. If they are wired asynchronously across an unreliable network, or to an external device, a timeout will likely be needed. Or, if something arrives on a different port while we are waiting for an asynchronous function, we will want to handle that. And we may want to abort the asynchronous communication. Callbacks and state machine handle these kinds of situations easily and naturally because the CPU is not stuck at one point in the code.</p>
</div>
<div class="paragraph">
<p>What we really want is the direct style of a multithreaded solution, and the reactive style of callbacks or state machines. They are not necessarily mutually exclusive.</p>
</div>
</div>
<div class="sect4">
<h5 id="trueasynchronous-execution-models"><a class="anchor" href="#trueasynchronous-execution-models"></a>Asynchronous execution models</h5>
<div class="paragraph">
<p>What asynchronous execution models all have in common is they use a synchronous call for the forward direction that always returns immediately, and possibly without a result. It must return all the way back to the main loop so that the thread can do other work. The response comes back later in some other way.</p>
</div>
<div class="paragraph">
<p>There are several ways to handle the response:</p>
</div>
<div class="sect5">
<h6 id="trueasyncawait"><a class="anchor" href="#trueasyncawait"></a>async/await</h6>
<div class="paragraph">
<p>If you have <strong>async</strong>/<strong>await</strong> available in your language, it is by far the best way to write asynchronous style code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">    await RobotForward(7);
    await Delay(1000);
    await RobotTurnRight(90);</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the Task object returned by any of the function calls is not complete, the CPU returns (from the containing function) at that point so it can do other things in the meantime. When the task is complete, the CPU magically returns to the point of the await to resume execution.</p>
</div>
<div class="paragraph">
<p><strong>await</strong> gives you the benefits of direct style, needing only the addition of the keyword <strong>await</strong> on every asynchronous call (and the addition of the <strong>async</strong> keyword on the containing function).</p>
</div>
<div class="paragraph">
<p><strong>await</strong> also gives you the benefits of reactive style. While the code waits for the response to an asynchronous function call, other code in the abstraction can still react to other incoming or internal events. If the waiting asynchronous function call needs to be cancelled, this can be done using a cancellation token. The await will release and you can use exceptions to change the course of the prescriptive part of the code.</p>
</div>
<div class="paragraph">
<p>async/await keywords must be put on every function in the call stack back to main. Apart from that, the direct style code looks syntactically the same as a synchronous function calls. But under the covers it is not - the compiler transforms the code into a state machine.</p>
</div>
<div class="paragraph">
<p>When an asynchronous call (using the await keyword) executes synchronously at the responder end, the task object that is returned by the call has a completed status and a return value already, and so awaiting on it simply causes execution to continue immediately with the next statement as if it was a synchronous call.</p>
</div>
<div class="paragraph">
<p>When an asynchronous call executes asynchronously at the responder end, the task object that is returned does not have a return value and a completed status. The requester async function returns immediately at the point of the await without executing the statements following the await. When the task object status changes to complete, the statements following the await then magically resume with the functions&#8217;s context all restored.</p>
</div>
<div class="paragraph">
<p>The code following the await is actually compiled as callback function, but the syntax is such that it looks like direct style. It&#8217;s the best of both worlds, however its confusing when you are new to it, because functions marked with async do not behave like normal functions.</p>
</div>
<div class="paragraph">
<p>Async/await is the best addition to programming languages since objects.</p>
</div>
</div>
<div class="sect5">
<h6 id="truestate-machine"><a class="anchor" href="#truestate-machine"></a>State machine</h6>
<div class="paragraph">
<p>Consider if the requester is better written as a state machine. If the requester is mostly reacting to events anyway, it might be best viewed as a state machine. The requester sends an event out the port and puts itself in a state for handling a response event. This solution is more flexible because it can also handle any other events that might happen in the meantime, or even instead of the response, such as a timeout. The response comes back on the port as an event for the state machine.</p>
</div>
<div class="paragraph">
<p>If the requester is not so much reacting to events but prescribing the order that things happen, then a state machine will be awkward, especially if the requesting function is nested in loops of other functions. In this case we want the direct style (that looks syntactically like a synchronous function call). Direct coding style allows the code that follows the request call to go immediately after it rather than in a different function.</p>
</div>
</div>
<div class="sect5">
<h6 id="truecoroutines-or-protothreads"><a class="anchor" href="#truecoroutines-or-protothreads"></a>Coroutines or protothreads.</h6>
<div class="paragraph">
<p>In C code there are mechanisms such as coroutines and protothreads that use macros that make the code style direct. Under the covers the macros make switch statements that work as a state machine.</p>
</div>
</div>
<div class="sect5">
<h6 id="truecallbacks"><a class="anchor" href="#truecallbacks"></a>Callbacks</h6>
<div class="paragraph">
<p>The requester can pass a callback function reference to the responder. When the responder has processed the communication it calls the callback function.</p>
</div>
<div class="paragraph">
<p>This can be a workable, albeit not entirely elegant, solution. The function containing the call to the asynchronous port is split up into two smaller functions, which is not great if direct style code would express the solution better. Also local variables or parameters that would have been in the original function now end up as globals to be shared by the multiple functions. You can&#8217;t put callback functions in a loop or another statement or inside another function, so such structures have to be split up also, and effectively made to work as a state machine.</p>
</div>
<div class="paragraph">
<p>The request call will be at the very end of the function that contains it. This is so that it returns to the main loop when the request call immediately returns (tail call). The callback function immediately follows this function so that the flow is still relatively clear.</p>
</div>
<div class="paragraph">
<p>Finally, the callback function could be passed by the request call as an anonymous function. However this involves much nesting of brackets and indenting for successive callback functions. This is called triangle hell. If there is more than one such request/response in a row, these nestings will quickly become unreadable. I find named functions following each other is clearer.</p>
</div>
</div>
<div class="sect5">
<h6 id="truetasks-futures-promises"><a class="anchor" href="#truetasks-futures-promises"></a>Tasks, Futures, Promises</h6>
<div class="paragraph">
<p>Without going into the detailed differences between futures and promises (the terms get mixed up anyway), this approach is more modern than callback functions.</p>
</div>
<div class="paragraph">
<p>The requester makes a synchronous call on the receiver which immediately returns with an object known as a future. The future object will have the result in it in the future. You can save a reference to the object, do something else in the meantime, and check it periodically.</p>
</div>
<div class="paragraph">
<p>The future can contain a continuation function, which is essentially just our previous callback function idea.</p>
</div>
<div class="paragraph">
<p>The future may contain a continuation function reference which gets called when the result is ready.</p>
</div>
</div>
<div class="sect5">
<h6 id="truepairs-of-ports"><a class="anchor" href="#truepairs-of-ports"></a>Pairs of ports</h6>
<div class="paragraph">
<p>Finally, request/response could be implemented asynchronously by having pairs of ports on each of the requester and responder and having two wirings, one to carry the request and one to carry the response. Both can be synchronous pushes in themselves, but the overall wiring is request/response.</p>
</div>
<div class="paragraph">
<p>Doing function calls in both directions is usually avoided in conventional programming because it would involve circular dependencies. But in ALA its just wiring, so it is quite feasible.</p>
</div>
<div class="paragraph">
<p>Sometimes, it turns out that what would be request/response function calls in conventional code are really best written without request/response at all.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s have a look at an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C" class="language-C hljs">void main()
{
    while (true)
    {
        data = Scale();
        Display(data);
        delay(1000);
    }
}


float scale()
{
    data = Filter;
    return = data*0.55 + 23.2;
}


float Filter()
{
    static float state = 0;
    data = Adc(channel=2);
    state = data*0.12 + state*0.88;
    return state;
}


float Adc(int channel)
{
    ...
}


void Display(float data)
{
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The function main requests data from the adc at intervals via two functions which processes the data during the return trip. Main then pushes it to a display.</p>
</div>
<div class="paragraph">
<p>The functions main, scale, filter and adc are chained using request/response implemented as function calls.</p>
</div>
<div class="paragraph">
<p>(The scale and filter functions being chained may look strange to some because they are so obviously abstractions. But add a few more application specific details to them and I have seen plenty of conventional code that chains function or method calls through multiple  modules or classes like this.)</p>
</div>
<div class="paragraph">
<p>The main function is not abstract. Not like the ideas of adc conversion, filtering, scaling or displaying. It&#8217;s code that&#8217;s deciding when to read the ADC and then passing the processed result to the display. In other words, it&#8217;s specific to the application. Also, in the chain of function calls, the chaining itself is specific to the application.</p>
</div>
<div class="paragraph">
<p>So let&#8217;s get closer to ALA by pulling out the application specific bits into an abstraction in the application layer.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C" class="language-C hljs">void main()
{
    while (true)
    {
        data = Adc();
        data = Filter(data);
        data = Scale(data);
        Display(data);
        delay(1000);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>It&#8217;s almost ALA compliant, but the application is handling data a lot at run-time. Handling data is not an application specific detail. It&#8217;s a very common implementation detail, so its done at the wrong abstraction level. The passing of data from abstraction to abstraction at run-time is the idea of dataflow, and it&#8217;s quite abstract so it should go into a layer below the domain abstractions.</p>
</div>
<div class="paragraph">
<p>Also the loop is a common implementation detail that doesn&#8217;t belong in the application abstraction. We wnt the application to just be a composition of the 'ideas' of adc, filter, scale, display and clock. Something more like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C" class="language-C hljs">void main()
{
    new Clock(1000)
    .WireTo(new(Adc(channel=2))
    .WireTo(new Filter(0.88))
    .WireTo(new Scale(0.55, 23.2))
    .WireTo(new Display());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>That&#8217;s our target code. Let&#8217;s see how to get there from the while loop code.</p>
</div>
<div class="paragraph">
<p>First let&#8217;s switch to diagram form. Lets use the request/response programming paradigm used by the original code so that it closely mimics the function calling execution model of the main loop version.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/diagram-clock-adc-filter-scale-display1.png" alt="diagram clock adc filter scale display1">
</div>
</div>
<div class="paragraph">
<p>We&#8217;ve put the main loop into a new domain abstraction called Main. It pulls data from its request/response port and pushes it out on its output port at regular intervals. The execution model is working the same way as the conventional code.</p>
</div>
<div class="paragraph">
<p>The Main domain abstraction is not a great abstraction because it assumes all possible applications are just going to pump data.</p>
</div>
<div class="paragraph">
<p>Lets fix that:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/diagram-clock-adc-filter-scale-display2.png" alt="diagram clock adc filter scale display2">
</div>
</div>
<div class="paragraph">
<p>We have introduced a new domain abstraction called a 'Pump' that pulls data from a request/response port and then pushes it out of an output port. The pump has an input event port to tell it when to do it. Pump will also be a temporary abstraction, but lets run with it for now.</p>
</div>
<div class="paragraph">
<p>Note that the arrow between the clock and the pump is using the event programming paradigm. The arrows between the Pump, the Scale, the Filter and the Adc are the request/response programming paradigm. The arrow between Pump and Display is Dataflow (which pushes data).</p>
</div>
<div class="paragraph">
<p>Because the Adc takes real time, the pump, scaler, filter and ADC must all now have asynchronous request/response ports. So they must all be written in asynchronous style. But, if we look at the diagram, we can wonder if we really need to use request/response. Is it a left over artefact of the conventional code?</p>
</div>
<div class="paragraph">
<p>We can see that we can lose some of the request/response ports simply by moving the Pump.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/diagram-clock-adc-filter-scale-display3.png" alt="diagram clock adc filter scale display3">
</div>
</div>
<div class="paragraph">
<p>Now the Filter and Scale abstraction uses simple push ports.</p>
</div>
<div class="paragraph">
<p>Now let&#8217;s take this one step further. The Adc abstraction is more versatile if the event that starts it does not have to come from the same place where the output goes. In other words, the Adc would be a better abstraction if it had a pair of ports, an event input called start, and a push dataflow port called output.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/diagram-clock-adc-filter-scale-display4.png" alt="diagram clock adc filter scale display4">
</div>
</div>
<div class="paragraph">
<p>Now we don&#8217;t need the Pump. It was there just to make the request/response execution model work and wasn&#8217;t providing anything useful. The application just wires the clocked event source directly to the ADC.</p>
</div>
<div class="paragraph">
<p>Now we have exactly what we wanted when we wrote that earlier code that just composed ideas. The composition now seems natural and elegant. The idea of splitting a request/response port into two separate ports has actually lead to better abstractions and a better solution overall.</p>
</div>
<div class="paragraph">
<p>It also makes sense to split a request/response port when the requesting end is already a state machine. Waiting for the response becomes just another state, and the response becomes just another event wired back to the state machine machine.</p>
</div>
<div class="paragraph">
<p>For receiving the response, the requester has an input port and a function that implements the interface of that port. If that function makes a further request, the stack will have two returns pending, one for the original request and one for the 2nd request. Some systems use 'tail optimization' for this situation to stop the stack accumulating calls. Because request calls occur at the end of a function, tail optimisation converts the instruction from a call to a jump.</p>
</div>
<div class="paragraph">
<p>The request/response pattern is common so we prefer to implement it as a single port on each of the requester and responder with a single wiring.</p>
</div>
<div class="paragraph">
<p>In summary, all these techniques allow us to write asynchronous requesters, which allows us to avoid using multithreading.</p>
</div>
<div class="paragraph">
<p>However there is still danger associated with these asynchronous mechinams compared with synchronous function calls. The CPU is freed up to do other work while a request that takes real time is being processed. This is still concurrency, its just not fine grained concurrency that multithreading has.  During concurrency, a shared state somewhere can be changed when you don&#8217;t expect it. For example, if the requester is performing a transaction such as the canonical debit one account and credit another, the requester that was written using normal synchronous calls is safe without locking the two accounts. This is because synchronous calls effectively lock everything by hogging the CPU resource until they complete. The asynchronous version has to be worried about what else might happen between two successive request/response calls. We call this type of non-splitable operation a transaction. Transactions still need explcit locking of resources that need to be kept in an internally consistent state. This needs to happen at the user story level becasue it is the user story that understands transactions. We can deal with this type of locking by using the "Arbitration programming paradigm", which is described later.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="truemultithreading"><a class="anchor" href="#truemultithreading"></a>Multithreading</h5>
<div class="paragraph">
<p>The conventional solution for function calls that take real time is to use multithreading.</p>
</div>
<div class="paragraph">
<p>At first this seems elegant as it keeps the same direct style syntax used for function calls that are non-blocking. This has the advantage that the code in the requester is written in almost the same way whether or not the instances it will be wired to will block. There is useful design-time decoupling resulting from that - the requester does not have to know what it will be wired to. It also appears to abstract concurrency, allowing other tasks to execute while the thread is blocked.</p>
</div>
<div class="paragraph">
<p>In ALA, every instance of an abstraction containing a prescriptive routine that could potentially block would need its own thread. But unfortunately threads do not remain confined within abstractions. They have far reaching effects as they call out into other abstractions. And abstractions that need to do work while waiting on a blocking call will themselves need multiple threads.</p>
</div>
<div class="paragraph">
<p>Because instances of abstractions do not know to whom they will be wired, they would need to assume that incoming function calls could be on a different thread. This would cause the multithreading model to have collaborative coupling between abstractions to have sufficient locking without causing deadlocks. This is the same problem for conventional classes as well, but its worse in ALA because abstraction internals must have zero design-time coupling with one another. They cannot collaborate on locking.</p>
</div>
<div class="paragraph">
<p>If a single thread is capable of doing all the work, I don&#8217;t recommend multithreading for solving the problem of function calls that take real time, even if unwieldy callbacks are the only alternative. Using callbacks to implement asynchronous ports is at least contained inside an abstraction.</p>
</div>
<div class="paragraph">
<p>Using non-preemptive multi-threading avoids race condition and deadlock problems by not requiring locks. All non-blocking sections of routines will run uninterrupted.</p>
</div>
<div class="paragraph">
<p>Once a multithreading is available, it tends to be the solution for every concurrency problem. That tends to commit code to prescriptive style even when a state machine would be better. (Prescriptive style as opposed to reactive style was discussed above.)</p>
</div>
<div class="paragraph">
<p>If we want to abort a blocked synchronous function call, (in the same way that we can abort an await with a CompletionToken,) we could have a second method in the programming paradigm interface called Cancel(). When the interface is implemented, the Cancel function (which has to run on a different thread) must release the block at the point where it is blocked, and cause it to return. It would return with a cancelled result so that the calling thread can follow a different flow. I have not tried this programming paradigm as yet.</p>
</div>
<div class="paragraph">
<p>Of course multithreading is still a solution for <em>throughput</em> types of performance issues. Multithreading is discussed further in a later section.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="truepriorities"><a class="anchor" href="#truepriorities"></a>4.4.11. Priorities</h4>
<div class="paragraph">
<p>Synchronous communications are deterministic. They prescribe the order in which everything happens. Furthermore, they effectively put a system wide lock on everything until the entire function calling tree completes. Nothing else can happen anywhere until it finishes.</p>
</div>
<div class="paragraph">
<p>Asynchronous communications, on the other hand, is inherently less deterministic. The non-determinism is made necessary by the external system, things like: real-time I/O, external networks, or by the need to improve performance.</p>
</div>
<div class="paragraph">
<p>During asynchronous communications, the functions can be executed in the order in which they are scheduled (using a simple queue) by default. This is what we did in the sample code at the start of this chapter. If this ordering scheme is used, then from the point of view of an asynchronous call tree, the natural order of execution is different from the synchronous function call tree. A synchronous function call tree will be depth first, whereas an asynchronous function call tree will be width first.</p>
</div>
<div class="paragraph">
<p>During the execution of a call tree, other call trees may be executing in parallel. This does not mean parallel in the fine grained sense of multithreading. It means parallel in the course grained sense that between the execution of asynchronous functions, other functions of other call trees may execute.</p>
</div>
<div class="paragraph">
<p>One consequence of asynchronous communications is that if any resource, including any object, is left in an invalid state between the running of two asynchronous functions, it must be locked. The need for locking is much less common than in a multithreaded situation. How locking can be accomplished without introducing coupling into the abstractions by using an arbitration programming paradigm is discussed later. Locking will change the order that functions execute.</p>
</div>
<div class="paragraph">
<p>The order of execution of asynchronous functions, can also be explicitly changed using priorities. Priorities are usually used to explicitly improve performance by doing more urgent things first.</p>
</div>
<div class="paragraph">
<p>Because the order of execution is outside the control of the abstractions involved, domain abstractions should not care about when it&#8217;s one-way asynchronous communications are executed. If the priority system were to reverse the order of execution of every asynchronous function in the system, a domain abstraction results should be the same (except for its performance). If the order does matter, the order needs to be explicit in some way.
For example, a domain abstraction could use a 2-way communications port so that it gets a communication back when something is complete and it can move onto the next step. Another example is to use an <em>activity</em> programming paradigm (UML activity diagram). Abstractions have <em>start</em> input port and a <em>finished</em> output port. The application wires instances of them in a sequence.</p>
</div>
<div class="paragraph">
<p>Priorities are generally a system wide concern, so the application abstraction (or feature or user story abstractions) are the only ones that have the knowledge to know how to set priorities.</p>
</div>
<div class="paragraph">
<p>In conventional modular systems, priorities are usually a cross-cutting concern, but in ALA they are cohesive with the wiring code, which is already in one place for a given feature or user story. The application may need to. prioritize the features and user stories.</p>
</div>
<div class="paragraph">
<p>TBD Show example implementation code for priorities. Add an optional priority parameter to the WireTo of the asynchronous programming paradigm abstraction.
The appplication can use priority numbers such as 0,1,2. We need a default priority so that WireTo can be called without specifying a priority. The application would configure the default, for example to 1.</p>
</div>
<div class="paragraph">
<p>The final requirement is that applications can still use the asynchronous programming paradigm without using priorities at all. There would be a default default priority level of 0.</p>
</div>
<div class="paragraph">
<p>A priority abstraction could be created in the domain abstractions layer. It would contain a dictionary for priority levels. You would not use an enum for priority level in this abstractions because the levels are specific to an application. The application configures the dictionary with level names such as Low, Middle, High, that associate with numeric priorities.</p>
</div>
<div class="paragraph">
<p>Also, we need to consider if domain abstractions may ever want to use priorities internally. If so we need to do it in such a way that they do not have a dependency on a priority abstraction because if they are used without priorities, we don&#8217;t want to have to include the priority abstraction.</p>
</div>
</div>
<div class="sect3">
<h4 id="truebusy-resources"><a class="anchor" href="#truebusy-resources"></a>4.4.12. Busy resources</h4>
<div class="paragraph">
<p>When a resource that takes is used asynchronously, more than one user may try to use it at the same time. For example a transaction on a database may involve several asynchronous function calls, and have multiple users. It would need to be locked for the duration of the transaction. Or an ADC converter that takes time to do a conversion may be used by multiple users. It would be busy to new requests while it is performing a conversion. If the resource is busy, the communication to the resource will need to be queued until it is ready.</p>
</div>
<div class="paragraph">
<p>The reactor pattern can handle this situation. It can check if the receiver is busy before giving it the communication. The dispatcher wont remove asynchronous function calls from the queue unless the destination resource is ready for it.</p>
</div>
<div class="paragraph">
<p>If a simple event loop is used, a solution to this problem, is an intermediary object that is wired in front of the resource. It keeps its own queue of event objects. When the resource signals that it is free, it takes the first event from the queue and sends it to the resource via the main event loop. That way only one event at a time can be in the event loop&#8217;s queue.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="trueexample-programming-paradigms"><a class="anchor" href="#trueexample-programming-paradigms"></a>4.5. Example Programming paradigms</h3>
<div class="paragraph">
<p>In the previous section of this chapter, we discussed many aspects of execution models in general. Many were applicable to both event-driven and 1-way dataflow programming paradigms.</p>
</div>
<div class="paragraph">
<p>Nest we will look at some particular programming paradigms and see how their execution models might work. It is not an exhaustive list. There are no doubt many other possibilities waiting to be invented that have new meanings for the composition of abstractions, and allow succinct expression of requirements.</p>
</div>
</div>
<div class="sect2">
<h3 id="truerequestresponse"><a class="anchor" href="#truerequestresponse"></a>4.6. Request/response</h3>
<div class="paragraph">
<p>A common type of 2-way communication is request/response. This programming paradigm is fundamentally an orchestration of two one-way messages, but we are used to thinking of it as a fundamental communication pattern in its own right. That&#8217;s because it&#8217;s implemented so easily with a common function call.
Earlier in the chapter we observed that if requesters were asynchronous by nature, they would have wiring compatibility with either synchronous or asynchronous receivers. And we discussed ways of writing requesters to be asynchronous.</p>
</div>
<div class="paragraph">
<p>A request carries two types of implicit information. Firstly, since they are wired point to point, a request is implicitly a command. It doesn&#8217;t need any command name or any explicit data specifying a command. Secondly a request and a response implicitly carry timing information. The time that they occur is in itself information.</p>
</div>
<div class="paragraph">
<p>Examples of request/response:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The requester needs to know when it&#8217;s completed (before it continues with the next line of code).</p>
</li>
<li>
<p>The requester needs to know a success or failure status of a command.</p>
</li>
<li>
<p>The requester needs to request latest information (pull) (e.g. from an I/O port).</p>
</li>
<li>
<p>The requester needs to request lazy information (information not calculated until its needed).</p>
</li>
<li>
<p>The requester needs to request specific information e.g from a database.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="truewiring-incompatible-requestresponse-ports"><a class="anchor" href="#truewiring-incompatible-requestresponse-ports"></a>4.6.1. Wiring incompatible request/response ports</h4>
<div class="paragraph">
<p>As discussed in earlier sections, synchronous and asynchronous 2-way communications have different advantages. There is a principle, GALS, that suggests that we use synchronous locally (within a processor) and asynchronous globally across processors. I think this is too simplistic. There are reasons other than cross-processor communications that cause certain communications to take real time, such as IO or delays. These communications should be asynchronous, and then all the ones that might be wired to them need to be asynchronous as well. Nevertheless there may be some communications in the average application which needs the advantages of synchronous communications.</p>
</div>
<div class="paragraph">
<p>The request/response ports of domain abstractions may end up a mixture of synchronous and asynchronous.</p>
</div>
<div class="paragraph">
<p>If the requester is asynchronous and the responder is synchronous, there is little problem in connecting them using an intermediary object. When the requester calls the intermediary, the intermediary in turn calls the responder which returns immediately. The intermediary then places the result in the task or future object, or calls the requester back if it uses a callback.</p>
</div>
<div class="paragraph">
<p>If the requester is synchronous and the responder is asynchronous, it would be possible to create an intermediary adapter, but it will block the requester&#8217;s thread, which probably isn&#8217;t what we want. The requester would need its own thread (or its requester), which, as I said earlier I don&#8217;t recommend as the way to solve this problem. So they are essentially incompatible. The requester code would need to change to asynchronous, as described by one of the methods above.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="trueevent-driven-programming-paradigm"><a class="anchor" href="#trueevent-driven-programming-paradigm"></a>4.7. Event-driven programming paradigm</h3>
<div class="paragraph">
<p>We now return to the 'Event driven' programming paradigm. At the beginning of this chapter we showed both synchronous and asynchronous code examples of this paradigm, both of which used the IEvent interface.</p>
</div>
<div class="paragraph">
<p>'Event' is an overloaded term in software engineering. Sometimes it means asynchronous, as in using an event loop. Sometimes it means indirect, as in C# events. Sometimes it means both. Earlier in this chapter we clarified these two independent notions. We discussed that in ALA, communications between abstractions within a layer are always indirect and explicit. We also discussed that they may be either synchronous or asynchronous. And we discussed 1-way and 2-way communications.</p>
</div>
<div class="paragraph">
<p>The interpretation of event-driven that I use is asynchronous and 1-way. Of course it&#8217;s always indirect and explicit in ALA.</p>
</div>
<div class="paragraph">
<p>Note that this interpretation is different from the C# language version of events. C# events are synchronous (they get delivered and processed before the function returns). C# events also directly support fanout. C# receivers are usually registered by the receiver itself (observer or publish/subscribe pattern). In ALA of course, events must be wired by a layer above.</p>
</div>
<div class="paragraph">
<p>In my interpretation of the event-driven programming paradigm, output ports can only be wired point to point. You would use a fanout intermediary object to achieve wiring an event to multiple destinations.</p>
</div>
<div class="paragraph">
<p>Even though my interpretation of even-driven is asynchronous, the output ports use a function or method call. This is fine because they are 1-way communications. The function gets the event on its way and returns immediately. The return itself carries no information.</p>
</div>
<div class="paragraph">
<p>When an event is taken from the event queue and dispatched to the receiver, we call it a task. The task is just the execution of a function or method, (which is different from a C# task object). A task must always runs to completion quickly. No task should take real time to execute (spin loop, or block).</p>
</div>
<div class="sect3">
<h4 id="trueevents-with-parameters"><a class="anchor" href="#trueevents-with-parameters"></a>4.7.1. Events with parameters</h4>
<div class="paragraph">
<p>Another section of this chapter discusses the dataflow programming paradigm. Dataflow can be similar to event-driven with a parameter when it pushes data. However Dataflow has variants where can be synchronous, can be pull rather than push, and can send a whole table of data in batches. For this reason Dataflow and event-driven are considered different programming paradigms.</p>
</div>
</div>
<div class="sect3">
<h4 id="truereactive-vs-prescriptive-programming"><a class="anchor" href="#truereactive-vs-prescriptive-programming"></a>4.7.2. Reactive vs prescriptive programming</h4>
<div class="paragraph">
<p>Event-driven programming is a <em>reactive</em> style in that it contrasts with the <em>prescriptive</em> or <em>orchestrated</em> style of the imperative or activity programming paradigms. In event-driven, the system is idle until something happens, and then things react to it, possibly changing some state, possibly generating more events, completion events, or timeout events. Event driven systems like to use interrupt routines to get events from the outside into the system. The interrupt routine puts the event directly into the main loop event queue.</p>
</div>
<div class="paragraph">
<p>In a reactive system, we don&#8217;t know what will happen next, in either the outside world or what code will execute next. It is less deterministic. Reacting to an event often changes some stored state. This state may change the way we will react to subsequent events. In other words, event-driven often goes hand in hand with state machines.</p>
</div>
<div class="paragraph">
<p>Event-driven programming is generally not thought of as a request/response type of paradigm. There can be a response, but it would be thought of as a completely separate message that needs its own point to point wiring. We don&#8217;t need synchronous communications because there is no response associated with an event (in the same wiring).</p>
</div>
<div class="paragraph">
<p>ALA is polyglot with respect to programming paradigms, so there is no reason to try to make an entire system either event-driven or prescriptive. Both can be mixed for maximum expressibility of the requirements.</p>
</div>
<div class="paragraph">
<p>When there are no forces favouring reactive or prescriptive, I generally default to reactive. This is because reactive systems are more versatile in maintenance. A prescriptive style becomes awkward when an unforeseen event needs to be handled in the middle of a prescriptive routine. The flow of the routine becomes more complicated.</p>
</div>
</div>
<div class="sect3">
<h4 id="trueproperties-of-event-driven-designs"><a class="anchor" href="#trueproperties-of-event-driven-designs"></a>4.7.3. Properties of event-driven designs</h4>
<div class="ulist">
<ul>
<li>
<p>Event-driven design easily accommodates events happening externally to the system at unpredictable times. We may be busy processing a previous event when a new events occurs. We typically have an interrupt put the event into the asynchronous event queue. When we are ready to process the event, we may still want to process higher priority events first.</p>
</li>
<li>
<p>Long running tasks such as a heavy algorithm or updating a large display may cause issues with latency for other events. They need to be split into a series of tasks, usually at the outer loop. The loop state needs to be coded manually as a state machine. The C# 'yield return' keyword will tell the compiler to do this for you.</p>
</li>
<li>
<p>Event driven systems need a Timer abstraction to be provided in the programming paradigms layer. The Timer can be asked to issue an event at a future time. It can be asked to issue events at regular intervals.</p>
</li>
<li>
<p>Wiring in ALA may be circular. There is no problem with this from a dependency point of view. Since event-driven is asynchronous there are no issues execution wise either. If they were synchronous, there would be recursion and an infinite loop. Events may flow around the circle continuously. If there are no delays around the circle, the main loop will be constantly busy processing the events as fast as it can.</p>
<div class="paragraph">
<p>Events in a loop should not fan out. Events in a loop that reproduce more events will overload the event queue.</p>
</div>
</li>
<li>
<p>The reactor pattern can be used for when the receiver is not ready. The reactor pattern is an event loop which will check if the receiver is in a ready state before dispatching any events to it.</p>
</li>
<li>
<p>A developer used to a synchronous function calling style may expect what looks like a synchronous function call inside a domain abstraction to fully process the event before returning. The port itself will show that it uses an IEvent interface. Inside the IEvent abstraction it can explain that it is an asynchronous programming paradigm. However, where the code actually sends the event, it will only have output.Send(); The choice of the word <em>Send</em> rather than <em>Execute</em> is to indicate it&#8217;s only sending the event not executing it.</p>
</li>
<li>
<p>Because the event-driven programming paradigm is asynchronous, senders and receivers can be on different processors or different locations. The decision about where instances of domain abstractions run can even be after the application or user stories abstractions are written. This means that within the architectural 4+1 views framework, the physical view can be changed independently of the logical view.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="trueglobal-event-names"><a class="anchor" href="#trueglobal-event-names"></a>4.7.4. Global event names</h4>
<div class="paragraph">
<p>Some conventional event-driven systems use global event names for inter-communication between modules. Each receiver names the events it is interested in, effectively a variation of the observer or publish subscribe pattern. They do this by registering to global event or signal names. This is considered relatively decoupled by its proponents, because senders and receivers don&#8217;t know directly about each other, only about global events names. It is illegal in ALA because most events will not abstract enough to be named and become globals. They will tend to be specific to pairs of modules that need to communicate.</p>
</div>
<div class="paragraph">
<p>Event names then essentially become symbolic wirings. Symbolic wiring is difficult to follow because you have to search for where the names appear throughout the entire code.</p>
</div>
<div class="paragraph">
<p>By effectively collaborating on symbol names, abstractions are coupled with each other still. It&#8217;s a rigid system because modules could not be rewired in a different way without changing them.</p>
</div>
<div class="paragraph">
<p>In ALA we use point to point wiring instead, or should I say port to port. Wiring is brought out to a coherent place. Because the wiring is point to point, the events are anonymous. You don&#8217;t have to name the lines on a diagram.</p>
</div>
<div class="paragraph">
<p>Having said that, it is possible to have an event that is abstract enough to go into a layer below. Such an event would need to be used by many many domain abstractions so that it is truly more abstract. If only a few domain abstractions need to use an event, then they should still use ports and be all wired up.</p>
</div>
<div class="paragraph">
<p>If you do create a global abstract event, it would be so ubiquitous that you never want to use the domain abstractions without it. They will have a dependency on it after all.</p>
</div>
<div class="paragraph">
<p>I can&#8217;t think of an example of such an event. Perhaps an event called <em>initialize</em>. It is generated after the wiring code has executed but before an application is set running. Domain abstractions use it to do initialization that needs the wiring in place.</p>
</div>
<div class="paragraph">
<p>Another example may be a <em>closing</em> event, giving domain abstraction instances a chance to persist their context data before the application closes down.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="truedataflow"><a class="anchor" href="#truedataflow"></a>4.8. Dataflow</h3>
<div class="paragraph">
<p>A dataflow model is a model in which wired instances in the program (or connected boxes on a diagram) are a path of data without being a path of execution-flow. The execution flow is like in another dimension relative to the data flow - it may go all over the place.</p>
</div>
<div class="paragraph">
<p>A stream of data flows between the connected components. Each component processes data at its inputs and sends it out of its outputs.</p>
</div>
<div class="paragraph">
<p>Each input and output can be operated in either push or pull mode. Usually the system prescribes all pull (LINQ), all push (RX), all inputs pull and outputs push (active objects with queues) or all outputs pull and inputs push (active connectors). In ALA we can use a mix of these different mechanism when we define the programming paradigm interfaces.</p>
</div>
<div class="paragraph">
<p>The network can be circular provided some kind of execution semantic finishes the underlying CPU execution at some point (see synchronous programming below).</p>
</div>
<div class="paragraph">
<p>The dataflow paradigm raises the question of type compatibility and type safety. Ideally the types used by the components are either parameterised and specified by the application at each connection or determined through type inference.</p>
</div>
<div class="sect3">
<h4 id="trueidataflowt"><a class="anchor" href="#trueidataflowt"></a>4.8.1. IDataFlow&lt;T&gt;</h4>
<div class="paragraph">
<p>I frequently use dataflow execution models.</p>
</div>
<div class="paragraph">
<p>Here is one variation which works well:</p>
</div>
<div class="paragraph">
<p>TBD</p>
</div>
<div class="paragraph">
<p>This variation has these properties:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>On a diagram, the line (wire) represents a variable that holds the value.</p>
</li>
<li>
<p>Fan-out - one output can connect to multiple inputs. All inputs read the same output variable.</p>
</li>
<li>
<p>Fan-in - multiple outputs cannot connect to one input.</p>
</li>
<li>
<p>Each output is implemented by a single memory variable whose scope is effectively all the places connected by the line (wire).</p>
</li>
<li>
<p>Receivers can get an event when the value changes</p>
</li>
<li>
<p>Receivers can read and re-read their inputs at any time.</p>
</li>
<li>
<p>Operator don&#8217;t need to have an output variable, they can pass the get through and recalculate every time instead.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Here is the version I use most often.</p>
</div>
<div class="paragraph">
<p>TBD</p>
</div>
<div class="paragraph">
<p>Note that domain abstractions may not collaborate on a specific type for T. A pair of domain abstraction may not, for example, share a DTO (data transfer object) class as that would then be an interface specific to one or other of those classes. T must be more abstract and come from a lower layer, so is often a primitive type from the programming language. T may be passed in by the application, which always knows types of data moving through the system.</p>
</div>
<div class="paragraph">
<p>Type inferencing is desirable. For example, an instance of a <em>DataStore&lt;T&gt;</em> abstraction could be configured by the application to have some specific fields. Ideally this is the only time the application specifies the fields. The application wires it to a <em>select</em> abstraction that removes one field and then to a <em>join</em> abstraction that adds one field. From there it is wired to a <em>form</em> abstraction that displays the fields. Ideally the form, select and join abstractions do not also have to be configured by the application to know the types of their ports. Instead they are able to infer the type as an anonymous class as it goes from port to port at compile-time.</p>
</div>
</div>
<div class="sect3">
<h4 id="trueitable"><a class="anchor" href="#trueitable"></a>4.8.2. ITable</h4>
<div class="paragraph">
<p>This interface moves a whole table of data at once. The table has rows and columns. The columns are determined at runtime by the source.</p>
</div>
<div class="paragraph">
<p>Run-time types can also be used. For example, the fields in an instance of a table abstraction may not be fully known at compile-time. This is especially true if the table abstraction provides persistence, or, for example, if the data source is a CSV file with unknown fields. In this case a ITable programming paradigm would transfer type information at run-time as well as the data itself.</p>
</div>
<div class="paragraph">
<p>TBD implementation examples</p>
</div>
</div>
<div class="sect3">
<h4 id="trueglitches"><a class="anchor" href="#trueglitches"></a>4.8.3. Glitches</h4>
<div class="paragraph">
<p>All systems can have glitches when data flows are pushed in a diamond pattern. The diamond pattern occurs when an output is wired to two or more places, and then the outputs of those places eventually come back together. If they never come together, even both seen by a human, then we generally don&#8217;t care what order everything is executed in. But when they come together, the first input that arrives with new data will cause processing, and use old data on the other inputs. This unplanned combination of potentially inconsistent data processed together is a glitch. It even happens in electronic circuits.</p>
</div>
<div class="paragraph">
<p>The following composition of dataflow operators is meant to calculate (X+1)*(X+2)</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/diagram-25.png" alt="diagram 25">
</div>
</div>
<div class="paragraph">
<p>When X changes, there can be a glitch, a short period of time, in which the output is (C<sub>new</sub>+1)*(C<sub>old</sub>+2).</p>
</div>
<div class="paragraph">
<p>In imperative programming, this problem is up to the developer to manage. He will usually arrange the order of execution and arrange for a single function or method to be called at the place where the data-paths come back together. As he does this, he is introducing a lot of non-obvious coupling indisde the modules of the system, which is one of the big problems with imperative programming.</p>
</div>
<div class="paragraph">
<p>When we have composability, we don&#8217;t know inside the abstractions how data will propagate outside, and how it will arrive at its inputs. We want to execute whenever any of our inputs change, because as far as we know it may be the only change that might happen. So we really want the execution model to take care of eliminating glitches automatically for us.</p>
</div>
<div class="paragraph">
<p>This is a work in progress for the IDataFlow execution model described above.
In the meantime, as a work-around I take care of it at the application level using a pattern. When I know dataflows will re-merge in a potentially inconsistent manner, I wire in an instance of an abstraction called 'Order' between the output and all its destination inputs. This instance of order is configured to explicitly control the order that the output date stream events are executed in. Then I will use a second abstraction called 'EventBlock' at the end of all data paths except one, the one that executes last.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/diagram-26.png" alt="diagram 26">
</div>
</div>
<div class="paragraph">
<p>By default multiple IDataFlows wired to a single output are executed in the order that they are wired anyway. On the diagram, they are drawn top to bottom in that order.  This improves the determinism but is a little too implicit for my liking, so that is why I use the order abstraction.</p>
</div>
</div>
<div class="sect3">
<h4 id="truelive-dataflow"><a class="anchor" href="#truelive-dataflow"></a>4.8.4. Live dataflow</h4>
<div class="paragraph">
<p>As used in the coffee-maker example earlier, this paradigm simulates electronic circuits instead of using the concept of discrete messages. Semantically the inputs have the values of the outputs they are wired to at all times. This type of flow is readily implemented with shared memory variables.</p>
</div>
<div class="paragraph">
<p>FRP (Functional Reactive Programming) also is effectively a live dataflow execution model.</p>
</div>
</div>
<div class="sect3">
<h4 id="truesynchronous-dataflow"><a class="anchor" href="#truesynchronous-dataflow"></a>4.8.5. Synchronous dataflow</h4>
<div class="paragraph">
<p>The use of the word synchronous here is different from its use in the discussion of synchronous/asynchronous events above. Here it means a master system clock clocks the data around the system on regular ticks. At each tick, every instance latches its own inputs and then processes them and places the results on their outputs. Data progresses through one operator per tick, so takes more time to get through the system from inputs to outputs. The result is a more deterministic and mathematically analysable system.</p>
</div>
<div class="paragraph">
<p>The execution timing and the timing of outputs occurs at a predictable tick time, albeit on a slower time scale than an asynchronous system. All timings are lifted into the normal design space.</p>
</div>
<div class="paragraph">
<p>Glitches that could occur in an asynchronous system (discussed earlier) are eliminated at the level of single clock ticks. A fast glitch could not occur. A glitch would occur when different data paths had different lengths, and would last for at least one tick duration. Controlling glitches is therefore lifted into the normal design space.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="trueactivity-flow"><a class="anchor" href="#trueactivity-flow"></a>4.9. Activity-flow</h3>
<div class="paragraph">
<p>The name Activity-flow comes from the UML activity diagram. Activities that are wired together execute in order. One starts when the previous one finishes. The activity itself may take a long time to complete (without blocking the CPU). Activity flows can split, run concurrently and recombine.</p>
</div>
<div class="paragraph">
<p>Activity-flow contrasts with event-driven. Where event-driven is reactive, activity-flow is prescriptive. It orchestrates what will happen rather than reacting to what might happen.</p>
</div>
<div class="paragraph">
<p>Activity-flow is not the same as the old flow diagrams. Flow diagrams were for the imperative programming paradigm where the flow was the flow of the CPU. Activity flow can have delays and other time discontinuities as it syncs with what&#8217;s happening in the outside world.</p>
</div>
<div class="paragraph">
<p>Activity-flow&#8217;s execution model can be the same as event driven. Each domain abstraction has a <em>start</em> input port and a <em>done</em> output port. The 'done' port of one instance of a domain abstraction can be wired to the 'start' port of the next. The ports are just event ports and can be wired for synchronous or asynchronous execution.</p>
</div>
<div class="paragraph">
<p>If the Activity-flow is a linear sequence, we can consider wiring the instances using text. However activity-flow abstractions will often need other wiring (using other programming paradigms) to UI or other input/output. C
The domain abstractions may have request/response ports for their I/O. These may be synchronous or asynchronous depending on the design factors discussed earlier. It may wish to poll something external at regular intervals to see if it&#8217;s complete, so it may register on a timer for regular events. (The timer is an abstraction in the programming paradigms layer, which is typically wired to the event-loop abstraction for asynchronous execution).</p>
</div>
<div class="paragraph">
<p>The domain abstractions may internally use an asynchronous execution model, such as for a delay.</p>
</div>
<div class="sect3">
<h4 id="truestructured-activity-flow-wiring-using-text-experimental"><a class="anchor" href="#truestructured-activity-flow-wiring-using-text-experimental"></a>4.9.1. Structured activity flow wiring using text (experimental)</h4>
<div class="paragraph">
<p>This is a thought experiment at this stage.
The experiment is to see if we can do structured programming for activity flow.
Remember activity flow is instances of domain abstractions, each of which generally has a <em>start</em> port and a <em>done</em> port.</p>
</div>
<div class="paragraph">
<p>The idea is to mimic imperative structured programming. Structural programming is what got rid of the goto and introduce block structured statements such as while and if. It is generally laid out with indenting that exactly matches the nested structure of braces. Your brain sees the indenting but the compiler sees the curly braces. (Except for Python which makes the compiler use what the brain sees).</p>
</div>
<div class="paragraph">
<p>In this program, we will string together some instances of domain abstractions and include a loop and a conditional. The indenting structure is the same as for the imperative version.</p>
</div>
<div class="paragraph">
<p>Remember this code is not executing the activity flow, it is just wiring it all up for later execution.</p>
</div>
<div class="paragraph">
<p>TBD need the corrsponding diagram here to show what this code is trying to do</p>
</div>
<div class="listingblock">
<div class="title">ActivityFlow.cs</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">program = new A();
    program.
    .WireIn(new B())
    .WireIn(
        Loop (
            new C()
            .WireIn(
                If (new D(),
                    new E(),
                    new F()
                )
            )
            .WireIn(new G())
            ,
            new H();
        )
    )
    .WireIn(new I())</code></pre>
</div>
</div>
<div class="paragraph">
<p>First remember that WireIn returns its second parameter to support this fluent style.
A is the first activity.
A&#8217;s done port is wired to B&#8217;s start port, so B is the second activity.
Everything else is in a loop.
The 'Loop' function takes two parameters, one is another flow and one is the looping condition, which in this case is H.
B gets wired to C.
'If' is a function that takes three parameters, a condition, which in this case is D, and two flows.
C gets wired to D.
The 'If' function expects D to have two done ports, called donetrue and donefalse.
It wires donetrue to E.
It wires donefalse to F.
'If' wires the done ports of both E and F to a null activity instance to recombine the flow.
The null instance is returned by 'If'.
The null instance is wired to G.
G gets wired to H.
The 'Loop' function expects H to have two exit ports calls done and loop.
'Loop' wires H&#8217;s loop port to C, and returns H.
H is wired to I.</p>
</div>
<div class="paragraph">
<p>This code looks okay, however, as is often the problem with text based representations of relationships, most of the instances will probably need additional wiring to other things as well. If this is the case, and the requirements implicitly contains a graph structure rather than a tree structure, then a diagram wll be the best way to represent it.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="truework-flow"><a class="anchor" href="#truework-flow"></a>4.10. Work-flow</h3>
<div class="paragraph">
<p>Persisted Activity-flow. This includes long running activities within a business process such as an insurance claim.</p>
</div>
</div>
<div class="sect2">
<h3 id="trueiiterator"><a class="anchor" href="#trueiiterator"></a>4.11. IIterator</h3>
<div class="paragraph">
<p>This dataflow interface allows moving a finite number of data values at once. It does so without having to save all the values anywhere in the stream, so has an efficient execution model that moves one data value at a time through the whole network.</p>
</div>
<div class="paragraph">
<p>This is the ALA equivalent of both IEnumerator and IObserver as used by monads. ALA uses the WireTo extension method that it already has to do the Bind operation. So the IIterator interface is wired in the same consistent way as all the other paradigm interfaces. There is no need for IEnumerable and IObservable type interfaces to support Also unlike monads, multiple arbirary interfaces can be wired between two objects with a single wiring operation.</p>
</div>
<div class="paragraph">
<p>IIterator has two variants that handle push and pull execution models. Either the A object can push data to the B object, or the A object can pull data from the B object.</p>
</div>
<div class="paragraph">
<p>TBD implementation examples</p>
</div>
</div>
<div class="sect2">
<h3 id="trueui-layout"><a class="anchor" href="#trueui-layout"></a>4.12. UI layout</h3>
<div class="paragraph">
<p>This programming paradigm is used for laying out a graphical user interface. A relationship means put the target instance of a UI element inside the first instance of a UI element. The order of the fanout of relationships sets the order that the elements appear. For most UI domain abstractions, UI elements default to going go vertically downwards.</p>
</div>
<div class="paragraph">
<p>I use two domain abstractions called vertical and horizontal to control whether they are layed out vertically or horizontally.</p>
</div>
<div class="paragraph">
<p>Here is the interface for use by domain abstractions that will use .NET&#8217;s WPF class library for the implementation.</p>
</div>
<div class="listingblock">
<div class="title">IUI.cs</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">using System.Windows;

namespace ProgrammingParadigms
{
    /// &lt;summary&gt;
    /// Hierarchical containment structure of the UI
    /// &lt;/summary&gt;
    public interface IUI
    {
        UIElement GetWPFElement();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This programming paradigm is similar to XAML. It doesn&#8217;t use XML syntax, it uses wiring code or diagrams the same as all other programming paradigms. Binding to data in XAML is done using dataflow ports on domain abstractions. Unlike XML, the entire application is built the same way.</p>
</div>
</div>
<div class="sect2">
<h3 id="trueui-navigation-flow"><a class="anchor" href="#trueui-navigation-flow"></a>4.13. UI navigation flow</h3>
<div class="paragraph">
<p>TBD</p>
</div>
</div>
<div class="sect2">
<h3 id="truedata-schema"><a class="anchor" href="#truedata-schema"></a>4.14. Data schema</h3>
<div class="paragraph">
<p>TBD</p>
</div>
</div>
<div class="sect2">
<h3 id="truelocking-resources"><a class="anchor" href="#truelocking-resources"></a>4.15. Locking resources</h3>
<div class="paragraph">
<p>Even in a single threaded system, we still have concurrency at a course grained level. We want to allow our one thread to do other tasks whenever something else is waiting. Or, whenever an asynchronous communication occurs, we may choose to do previously queued tasks, or higher priority tasks, before processing the latest one. We can call the concurrent sets of tasks an activity.</p>
</div>
<div class="paragraph">
<p>We may have a resource or external device that can be be used by multiple activities. There is a set of tasks that need to complete on the resource without interrupton by other activities. This is called a transaction. Examples of resources that can have transactions are a database or an external device such as a robot arm. Several queries or movements may be involved in the transaction.</p>
</div>
<div class="paragraph">
<p>We need a locking mechanism for the resource. I recommend an arbitration programming paradigm. At the application level, we need to specify which instances of domain abstractions that perform transactions need to collaborate by locking or waiting for a given resource.</p>
</div>
<div class="paragraph">
<p>Every domain abstractions that performs a transaction on a given resource has a port of this programming paradigm. All instances using a given resource are wired to a single instance of an arbitrator abstraction. Effectively this wiring specifies the collaboration that must occur between the instances. This collaboration is done at the abstraction level of the system, where it belongs, not inside the abstractions.</p>
</div>
<div class="paragraph">
<p>The ALAExample project at www.github.com/johnspray74 has an example of this. The IArbitrator interface is considered a programming paradigm. It contains an async method for locking the resource. This method can be awaited on until the resource is free. A second method releases the resource, which would allow another activity waiting to proceed.</p>
</div>
<div class="paragraph">
<p>The arbitrator abstraction could be given the ability to detect deadlocks and even break deadlocks.</p>
</div>
</div>
<div class="sect2">
<h3 id="truestate-machines"><a class="anchor" href="#truestate-machines"></a>4.16. State machines</h3>
<div class="paragraph">
<p>To get used to how different these programming paradigms can be, let&#8217;s go now to something completely different - state machines. We wont be going into understanding them at the code level because we want to support hierarchical state machines, and the code for that is a little bit non-trivial, but we do want to get an understanding of how state machines are just another programming paradigm that allows us to wire together instance of abstractions. The meaning of the wiring is different than what it was for the event programming paradigm.</p>
</div>
<div class="paragraph">
<p>I assume a basic understanding of what state machines are.</p>
</div>
<div class="openblock float-group">
<div class="content">
<div class="imageblock left">
<div class="content">
<img src="images/FSM-generic.png" alt="FSM-generic.png">
</div>
<div class="title">Figure 44. State machine execution model</div>
</div>
<div class="paragraph">
<p>At first it can be difficult to express the solution to a requirements problem as a state machine, even when the state machine is a suitable way to solve the problem. It takes some getting used to the first time. But it only takes a little bit of practice to begin to master it.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>I once had to express a set of user stories that involved different things that could happen from the outside, either through the UI or other inputs. I knew these were the kind of user stories that were nicely expressed by a state machine, but I had no idea where to start. I only knew that the previously written C code to do the job was a big mess that could no longer be maintained. But I started drawing the state machine, first on paper and then in Visio, and everything started to fall into place very nicely. Before I knew it I had represented what used to be 5000 lines of C code by a single A3 sized state machine diagram. This diagram so well represented the user stories that it was easy to maintain for years to come. This experience was a big factor in the final conception of ALA.</p>
</div>
<div class="paragraph">
<p>Here is the diagram.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/BigStateMachine.pdf.jpg" alt="BigStateMachine.pdf.jpg">
</div>
<div class="title">Figure 45. My first significant state machine for a real embedded device</div>
</div>
<div class="paragraph">
<p>Notice that the diagram makes heavy use of hierarchical states (boxes inside boxes). These turn out to be important in most of my state machines.</p>
</div>
<div class="paragraph">
<p>State machine diagrams are drawn in their own unique way. The boxes of the diagram are instances of the abstraction "State". The lines on a state machine diagram are actually instances of another abstraction, "Transition". Out of interest, to relate a state machine diagram to a more conventional ALA wiring diagram, you would replace all the lines on the state machine with boxes representing instances of Transition. The event, guard and actions that associate with a transition then go inside the transition box to configure it. Lines would then wire the transition box to its source state instance and destination state instance. Hierarchy is drawn on the state machine by boxes inside boxes, but in the conventional ALA wiring diagram, the boxes would be drawn outside with lines showing the tree structure. This analogous to the tree structured wiring we have used in previous examples for expressing UIs, which are actually 'contains' relationships.</p>
</div>
<div class="paragraph">
<p>The graphical tool being developed will allow the drawing of hierarchical state machines. It will internally transform it to conventional wiring of instances of states and transitions. Interfaces called something like ITransitionSource, ITransitionDestination and IHiercharical would be used to make it execute. It is a simple matter to write code inside the state and transition abstractions to make them execute that would be adequately efficient for most purposes.</p>
</div>
<div class="paragraph">
<p>How to make hierarchical state machine execute in an optimally efficient way is a non-trivial problem, but I have worked out the templates for what the C code should look like. Generating this code is a topic for another web page.</p>
</div>
</div>
<div class="sect2">
<h3 id="trueimperative"><a class="anchor" href="#trueimperative"></a>4.17. Imperative</h3>
<div class="paragraph">
<p>Much conventional code is written using the so called <em>imperative</em> programming paradigm. This paradigm has the same execution model of the underlying CPU hardware. Imperative means sequential execution flow of instructions or statements in computer time.</p>
</div>
<div class="paragraph">
<p>Imperative is seldom a good programming paradigm for expressing whole user stories. Even though we call our imperative languages high level languages, its actually quite a low level programming paradigm. However it is efficient because it executes almost directly on the hardware. Imperative highly prescriptive. We can code applications in it directly or we can use it to build other programming paradigms.</p>
</div>
<div class="paragraph">
<p>Function or method calls go to a named destination, and are synchronous (pass the CPU to the called function for execution, and pass it back to the caller on completion.</p>
</div>
<div class="paragraph">
<p>The imperative programming paradigm is wonderful for writing algorithms that are not tied to real-time. However, in modern software, that is a tiny fraction of what programs do. We will seldom use the 'imperative' programming paradigm in ALA.</p>
</div>
<div class="paragraph">
<p>Imperative can be structured to comply with ALA constraints, almost. The user story simply makes function calls or method calls to the domain abstractions in the layer below. The problem is that the user story ends up controlling the execution flow, and it handles the data at runtime. The data it receives from one domain abstraction will be passed to the next domain abstraction. This is not really a responsibility we want to put on the user story. We want to factor out execution flow and data. We want the user story to be just about composing instances of domain abstractions.</p>
</div>
</div>
<div class="sect2">
<h3 id="truemultithreading-2"><a class="anchor" href="#truemultithreading-2"></a>4.18. Multithreading</h3>
<div class="listingblock">
<div class="content">
<pre>Compared with ALA, modular programming will look like a big pool of mud. Multithreaded programming will look like a big pool of boiling mud.</pre>
</div>
</div>
<div class="paragraph">
<p>In the section about request/response, we briefly considered using multithreading to solve the problem when the request/response is implemented as a synchronous function call, but it takes time and the call blocks.</p>
</div>
<div class="paragraph">
<p>In this section we discuss briefly why we avoid using multithreading to solve that particular problem, and discuss what problems might justify using multithreading.</p>
</div>
<div class="paragraph">
<p>TBD WIP</p>
</div>
<div class="paragraph">
<p>Because threads block, we must put everything that needs to be concurrent on different threads. Whether it&#8217;s a conventional architecture or an ALA architecture this leads to coupling throughout the system. Modules may tend to be based on threads rather than a more logical separation. Furthermore, different parts of the system have to collaborate by locking accesses to shared state. There is a misconception that shared state is caused by globals. This is incorrect. Shared state occurs all the time in object oriented programs. Any objects accessed from different threads are shared state even if all state in an object is private. So if a UI object gets work done by a different thread so that the UI remain responsive, then the result will come back to the UI objects on a different thread unless this is carefully avoided. By default most objects are not thread-safe. Missing locks will lead to race conditions. As locks are added, there is even more blocking occurring. This can reduce performance, increase non-determinism, or require even more threads. Too much locking can lead to deadlocks or priority inversions. These issues will hide and appear rarely.</p>
</div>
<div class="paragraph">
<p>Unless it is required for latency or other performance throughput reasons that can&#8217;t be solved on a single thread, I don&#8217;t recommend going into the quagmire of pre-emptive multithreading. Even if another thread is needed for a specific performance case, I still recommend putting the majority of code in one thread despite any difficulties that entails (as discussed below).</p>
</div>
</div>
<div class="sect2">
<h3 id="trueagent-based-programming"><a class="anchor" href="#trueagent-based-programming"></a>4.19. Agent based programming</h3>
<div class="paragraph">
<p>Note that there is a different programming style of multithreading that doesn&#8217;t use shared state. It is called agent based programming. In this style, we think of every thread as effectively being on a different processor. They can only communicate with one another with messages. Every thread has a single input queue. <em>All</em> communications are asynchronous. Synchronous calls between agents is not possible, so there is no shared state.</p>
</div>
<div class="paragraph">
<p>The thread&#8217;s main loop does nothing other than take events from the input queue one at a time, process them, and asynchronously sends events to other such threads. This execution model is a completely different thing. It is called the agent model or producer/consumer. It is safe because there is no shared state and locks are not required. If there is a 'shared' resource, one thread can be assigned to resource. This model does not solve the problem of how to do synchronous request-response calls that block. It is not even the prescriptive programming style that we are trying to achieve with request/response. Every thread is already transformed into a reactive style. Such an execution model is equivalent to a single threaded system where all calls are asynchronous. Like an all asynchronous execution model, performance can be improved by assigning certain abstraction instances to their own processors.</p>
</div>
<div class="sect3">
<h4 id="truestate-machine-vs-multithreading-concurrency-styles"><a class="anchor" href="#truestate-machine-vs-multithreading-concurrency-styles"></a>4.19.1. State machine vs multithreading concurrency styles</h4>
<div class="paragraph">
<p>A bigger problem with callback functions or futures is that if the requester call is inside structured statements such as a loop or if statement, or has been called from another function, all the code right back to main() needs to be rewritten like a state machine. It must keep state variables to remember what would normally be implicit in the program counter state, and manually store any other stack based state that the compiler would normally handle for the execution flow through the program. If the code is a simple function called directly from main, this can be done fairly easily. Each time the function is called, it reads the state, which is usually a function pointer, and dispatches to it. Callbacks or continuations go to their own functions.</p>
</div>
<div class="paragraph">
<p>+
An advantage of this style of programming is that it easily handles all time discontinuities - things that would otherwise block a thread. It allows reacting to unexpected events much more easily. And it allows longish routines to yield by simply returning part way through, say inside a loop, to reduce the latency of any other concurrent tasks waiting to execute. When the main loop calls back, it can use the state variables to resume processing where it left off.</p>
</div>
<div class="paragraph">
<p>+
The great disadvantage of this style of programming is when the program is more prescriptive than reactive. There is a fixed sequence of things that will happen, and we want to express that as normal sequential lines of code, even though certain operations will block. For example, we are moving a large amount of data. Exceptions to the prescribed sequence are rare. I find that async/await or co-routines are the best solutions for this situation. If they are not available, then a cooperative (non-preemptive) thread could be considered to solve the one situation.</p>
</div>
<div class="paragraph">
<p>+
One of the most common requirements for concurrency is responding to user input. For this we may specify a soft deadline of 0.1s. This means that all state machine, callbacks, or other run-to-completion routines should execute in less than 0.1s. This not difficult to do because the vast majority will execute very quickly. What I sometimes do is put in a system timer to measure the longest running routine. It&#8217;s usually updating a large display.</p>
</div>
<div class="paragraph">
<p>+
What I see happening in most traditional systems is that once an RTOS is included in the system, it is considered to be the solution to <em>all</em> concurrency in the system. But probably 99% of concurrency in most systems can be done on a single thread. Most tasks may have priorities, but will wait until the CPU resource gets to them. So what I do is avoid using threads except for when the specific case of performance can&#8217;t be solved in any other way. So, in my entire career in embedded systems, I have never ended up having to use a second thread, even when I have an RTOS already in the system at my disposal. Short interrupt routines have handled all situations with hard real time latency requirements. The state machine programming style has better suited the reactive nature of most embedded systems.</p>
</div>
<div class="paragraph">
<p>+
Remember you can only have one highest priority thread. If you are really in a situation where you have one or more hard real time deadlines that can&#8217;t be done in interrupts,  then you should probably consider putting in multiple MCUs rather than trying to do, for example, rate-monotonic analysis.</p>
</div>
<div class="paragraph">
<p>+
Of course, if your system has multiple CPU cores, then you probably have a performance requirement that will need multiple threads to make use of them.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Some people, when confronted with a problem, think "I know, I&#8217;ll use regular expressions." Now they have two problems. - Jaimie Zawinski</p>
</div>
<div class="paragraph">
<p>Some people, when confronted with a problem, think "I know, I&#8217;ll use threads." Now they have ten problems. - Bill Schindler</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="trueagents-on-a-single-thread"><a class="anchor" href="#trueagents-on-a-single-thread"></a>4.19.2. Agents on a single thread</h4>
<div class="paragraph">
<p>TBD</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="trueexample-project-ten-pin-bowling"><a class="anchor" href="#trueexample-project-ten-pin-bowling"></a>4.20. Example project - Ten-pin bowling</h3>
<div class="paragraph">
<p>The full source code for the bowling application can be viewed or downloaded from here: <a href="https://github.com/johnspray74/GameScoring">https://github.com/johnspray74/GameScoring</a></p>
</div>
<div class="paragraph">
<p>The ten-pin bowling problem is a common coding kata. Usually the problem presented is just to return the total score, but in this example we will tackle the more complicated problem of keeping the score required for a real scorecard, which means we need to keep all the individual frame ball scores. We can afford to do this even for a pedagogical sized example because ALA can provide a simple enough solution.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/bowling_scorecard2.png" alt="bowling scorecard2">
</div>
</div>
<div class="paragraph">
<p>The ALA method starts by "describing the requirements in terms of abstractions that you invent". When we start describing the requirements of ten-pin bowling, we immediately find that "a game consists of multiple frames", and a "frame consists of multiple balls". Let&#8217;s invent an abstraction to express that. Let&#8217;s call it a "Frame". Instances of Frame can be wired together by a "ConsistsOf" relationship. So let&#8217;s invent an abstract interface to represent that, and call it 'IConsistsOf'.</p>
</div>
<div class="paragraph">
<p>Here is the diagram of what we have so far.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/diagram-bowling-1.png" alt="diagram bowling 1">
</div>
</div>
<div class="paragraph">
<p>This is the first time we are using a diagram for an ALA application, so le&#8217;s go through the conventions used.</p>
</div>
<div class="paragraph">
<p>The name in the top of the boxes is the abstraction name. The name just beneath that is the name of an instance of the abstraction. For the bowling application above, we are using two instances of the Frame abstraction, one called "game" and one called "frame". Below the abstraction name and instance name go any configuration information of the instance.</p>
</div>
<div class="paragraph">
<p>The Frame abstraction is configured with a lambda function to tell it when it is finished. The Frame abstraction works like this - when its last child is complete it will create a new one. It will stop doing that when the lambda expression is true. It will tell its parent it is complete when both the lambda expression is true and its last child Frame is complete.</p>
</div>
<div class="paragraph">
<p>The end of the chain is terminated with a leaf abstraction that also implements the 'IConsistsof' interface called 'SinglePlay'. It represents the most indivisible play of a game, which in bowling is one throw. Its job is to record the number of pins downed.</p>
</div>
<div class="paragraph">
<p>The concept in the Frame abstraction is that at run-time it will form a composite pattern. As each down-stream child frame completes, a Frame will copy it to start a new one. This will form a tree structure. The "game" instance will end up with 10 "frames", and each frame instance will end up with 1, 2 or 3 SinglePlays.</p>
</div>
<div class="paragraph">
<p>Note, in reference to the ALA layers, this diagram sits entirely in the top layer, the Application layer. The boxes are instances of abstractions that come from the second layer, the Domain Abstractions layer. The arrows are instances of the programming paradigm, 'InConsistsOf', which comes from the third layer, the ProgrammingParadigms layer.</p>
</div>
<div class="paragraph">
<p>This diagram will score 10 frames of ten-pin bowling but does not yet handle strikes and spares. So let&#8217;s do some 'maintenance' of our application. Because the application so far consists of simple abstractions, which are inherently stable, maintenance should be possible without changing these abstractions.</p>
</div>
<div class="paragraph">
<p>The way a ten-pin bowling scorecard works, bonuses are scored in a different way for the first 9 frames than for the last frame. In the first nine frames, the bonus ball scores come from following frames, and just appear added to the frame&#8217;s total. They do no appear as explicit throws. In the last frame, they are shown as explicit throws on the scorecard. That is why there are up to 3 throws in that last frame.</p>
</div>
<div class="paragraph">
<p>To handle the different last frame, we just need to modify the completion lambda expression to this.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>frameNum&lt;9 &amp;&amp; (balls==2 || pins==10) // completion condition for frames 1..9
|| (balls==2 &amp;&amp; pins&lt;10 || balls==3) // completion condition for frame 10</pre>
</div>
</div>
<div class="paragraph">
<p>To handle bonuses for the first 9 frames, we introduce a new abstraction. Let&#8217;s call it Bonuses. Although we are inventing it first for the game of ten-pin bowling, it is important to think of it as a general purpose, potentially reusable abstraction.</p>
</div>
<div class="paragraph">
<p>What the Bonus abstraction does is, after its child frame completes, it continues adding plays to the score until its own lambda function returns true.</p>
</div>
<div class="paragraph">
<p>The completed ten-pin bowling scorer is this:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/diagram-bowling-2.png" alt="diagram bowling 2">
</div>
</div>
<div class="paragraph">
<p>Note that the "game" instance (the left box of the diagram) implements IConsistsOf. This is where the outside world interfaces to this scoring engine. During a game, the number of pins knocked down by each throw is sent to this IConsistsOf interface. To get the score out, we would call a GetScore method in this interface.
The hard architectural work is done. We have invented abstractions to make it easy to express requirements. We have a diagram that describes the requirements. And the diagram is executable. All we have to do is put some implementation code inside those abstractions and the application will actually execute.</p>
</div>
<div class="paragraph">
<p>First let&#8217;s turn the diagram into equivalent code. At the moment, there are no automated tools for converting such diagrams to code. But it is a simple matter to do it manually. We get the code below:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>private IConsistsOf game = new Frame("game")
    .setIsFrameCompleteLambda((gameNumber, frames, score) =&gt; frames==10)
    .WireTo(new Bonus("bonus")
        .setIsBonusesCompleteLambda((plays, score) =&gt; score&lt;10 || plays==3)
        .WireTo(new Frame("frame")
            .setIsFrameCompleteLambda((frameNumber, balls, pins) =&gt; frameNumber&lt;9 &amp;&amp; (balls==2 || pins[0]==10) || (balls==2 &amp;&amp; pins[0]&lt;10 || balls == 3))
            .WireTo(new SinglePlay("SinglePlay")
    )));</pre>
</div>
</div>
<div class="paragraph">
<p>All we have done is use the 'new' keyword for every box in the diagram. We have made the constructor take the instance name as a string. (This name is not used except to identify instances during debugging.) We use a method called "WireTo" for every line in the diagram. More on that in a minute. And we pass any optional configuration into the instances using setter methods. The WireTo method and the configuration setter methods all return the 'this' pointer, which allows us to write this code in fluent style. If you are not familiar with fluent style it is just making methods return the this reference, or another object, so that you can chain together method calls using dot operators.</p>
</div>
<div class="paragraph">
<p>Not all ALA applications will be put together using the method in the previous paragraph, but I have found it a fairly good way to do it for most of them, so we will see this same method used for other example projects to come.</p>
</div>
<div class="paragraph">
<p>So far, this has been a fairly top-down, waterfall-like approach. We have something that describes all the details of the requirements, but we haven&#8217;t considered implementation at all. Past experience tells us this may lead us into dangerous territory. Will the devil be in the details? Will the design have to change once we start implementing the abstractions? The first few times I did this, I was unsure. I was not even sure it could actually be made to work. The reason it does work is because of the way we have handled details. Firstly all details from requirements are in the diagram. The diagram is not an overview of the structure. It is the actual application. All other details, implementation details, are inside abstractions, where they are hidden even at design-time. Being inside abstractions isolates them from affecting anything else. So, it should now be a simple matter of writing classes for those three abstractions and the whole thing will come to life.
Implementing the three abstractions turns out to be straightforward.</p>
</div>
<div class="paragraph">
<p>First, design some methods for the IConsistOf interface that we think we will need to make the execution model work:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>    public interface IConsistsOf
    {
        void Ball(int score);
        bool IsComplete();
        int GetScore();
        int GetnPlays();
        IConsistsOf GetCopy(int frameNumber);
        List&lt;IConsistsOf&gt; GetSubFrames();
    }</pre>
</div>
</div>
<div class="paragraph">
<p>The first four methods are fairly obvious. The Ball method receives the score on a play. The Complete, GetScore and GetnPlays methods return the state of the sub-part of the game. The GetCopy method asks the object to return a copy of itself (prototype pattern). When a child frame completes, we will call this to get another one. The GetSubFrames method is there to allow getting the scores from all the individual parts of the game as required.</p>
</div>
<div class="paragraph">
<p>The SinglePlay and Bonus abstractions are very straightforward.</p>
</div>
<div class="paragraph">
<p>So let&#8217;s code the Frame abstraction.
Firstly, Frame both implements and accepts IConsistsOf. A field is needed to accept an IConsistsOf. The WireTo method will set this field:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>// Frame.cs
private IConsistsOf downstream;</pre>
</div>
</div>
<div class="paragraph">
<p>Frame has one 'state' variable which is the list of subframes. This is the composite pattern we referred to earlier, and what ends up forming the tree.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>// Frame.cs

private List&lt;IConsistsOf&gt; subFrames;
private readonly Func&lt;int, int, int, bool&gt; isFrameComplete;
private readonly int frameNumber = 0;</pre>
</div>
</div>
<div class="paragraph">
<p>The second variable is the lambda expression that is a configuration passed to us by the application. It would be readonly (immutable) except that I wanted to use a setter method to pass it in, not the constructor, to indicate it is optional.</p>
</div>
<div class="paragraph">
<p>The third variable is the frameNumber, also immutable. It allows frame objects to know which child they are to their parent - e.g. 1st frame, 2nd frame etc. This value is passed to the lambda expression in case it wants to use it. For example, the lambda expression for a bowling frame needs to know if it is the last frame.</p>
</div>
<div class="paragraph">
<p>The methods of the IConsistsOf interface are now straightforward to write. Let&#8217;s go over a few of them to get the idea. Here is the most complicated of them, the Ball method:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>public void Ball(int player, int score)
{
    // 1. Check if our frame is complete, and do nothing
    // 2. See if our last subframe is complete, if so, start a new subframe
    // 3. Pass the ball score to all subframes

    if (IsComplete()) return;

    if (subFrames.Count==0 || subFrames.Last().IsComplete())
    {
        subFrames.Add(downstream.GetCopy(subFrames.Count));
    }

    foreach (IConsistsOf s in subFrames)
    {
        s.Ball(player, score);
    }
}</pre>
</div>
</div>
<div class="paragraph">
<p>It looks to see if the last child frame has completed, and if so starts a new child frame. Then it just passes on the ball score to all the child objects. Any that have completed will ignore it.</p>
</div>
<div class="paragraph">
<p>The IsComplete method checks two things: 1) that the last child object is complete and 2) that the lambda expression says we are complete:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>private bool IsComplete()
{
    if (subFrames.Count == 0) return false; // no plays yet
    return (subFrames.Last().IsComplete()) &amp;&amp;
        (isLambdaComplete == null ||
         isLambdaComplete(frameNumber, GetnPlays(), GetScore()));
}</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre></pre>
</div>
</div>
<div class="paragraph">
<p>GetScore simply gets the sum of the scores of all the child objects:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>private int GetScore()
{
    return subFrames.Select(sf =&gt; sf.GetScore()).Sum();
}</pre>
</div>
</div>
<div class="paragraph">
<p>The GetCopy method must make a copy of ourself. This is where the prototype pattern is used. This involves making a copy of our child as well. We will be given a new frameNumber by our parent.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>IConsistsOf GetCopy(int frameNumber)
{
    var gf = new Frame(frameNumber);
    gf.objectName = this.objectName;
    gf.subFrames = new List&lt;IConsistsOf&gt;();
    gf.downstream = downstream.GetCopy(0);
    gf.isLambdaComplete = this.isLambdaComplete;
    return gf as IConsistsOf;
}</pre>
</div>
</div>
<div class="paragraph">
<p>The few remaining methods of the IConsistOf interface are trivial. The implementation of IConsistsOf for the other two abstractions, SinglePlay and Bonuses, is similarly straightforward. Note that whereas Frame uses the composite pattern, Bonuses uses the decorator pattern. It implements and requires the IConsistsOf interface. The SinglePlay abstraction, being a leaf abstraction, only implements the IConsistsOf interface.</p>
</div>
<div class="paragraph">
<p>One method we haven&#8217;t discussed is the wireTo method that we used extensively in the application code to wire together instances of our domain abstractions. The wireTo method for Frame is shown below:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>public Frame WireTo(IConsistsOf c)
{
    downstream = c;
    return this;
}</pre>
</div>
</div>
<div class="paragraph">
<p>This method does not need to be implemented in every domain abstraction. I use an extension method for WireTo. The WireTo extension method uses reflection to find the local variable to assign to.</p>
</div>
<div class="paragraph">
<p>The WireTo method will turn out to be useful in many ALA designs. Remember in ALA we "express requirements by composing instances of abstractions". If the 'instances' of 'abstractions' are implemented as 'objects' of 'classes', then we will use the wireTo method. If the 'instances' of 'abstractions' are 'invocations' of 'functions', as we did in the example project in Chapter One, we wont use WireTo obviously. In the coffeemaker example to come, 'instances' of 'abstractions' are 'references' to 'modules' because a given application would only have one of each abstraction.</p>
</div>
<div class="paragraph">
<p>The wireTo method returns 'this', which is what allows the fluent coding style used in the application code. The configuration setter methods also return the this reference so that they too can be used in the fluent style.</p>
</div>
<div class="paragraph">
<p>Here is the full code for the Frame abstraction (with comments removed as we just explained everything above):</p>
</div>
<div class="literalblock">
<div class="content">
<pre>// Frame.c
using System;
using System.Collections.Generic;
using System.Linq;
using GameScoring.ProgrammingParadigms;
using System.Text;

namespace GameScoring.DomainAbstractions
{

    public class Frame : IConsistsOf
    {
        private Func&lt;int, int, int[], bool&gt; isLambdaComplete;
        private readonly int frameNumber = 0;
        private IConsistsOf downstream;
        private string objectName;
        private List&lt;IConsistsOf&gt; subFrames = new List&lt;IConsistsOf&gt;();


        public Frame(string name)
        {
            objectName = name;
        }




        public Frame(int frameNumber)
        {
            this.frameNumber = frameNumber;
        }



        // Configuration setters follow.

        public Frame setIsFrameCompleteLambda(Func&lt;int, int, int[], bool&gt; lambda)
        {
            isLambdaComplete = lambda;
            return this;
        }





        // Methods to implement the IConsistsOf interface follow


        public void Ball(int player, int score)
        {
            if (IsComplete()) return;

            if (subFrames.Count==0 || subFrames.Last().IsComplete())
            {
                subFrames.Add(downstream.GetCopy(subFrames.Count));
            }

            foreach (IConsistsOf s in subFrames)
            {
                s.Ball(player, score);
            }
        }




        public bool IsComplete()
        {
            if (subFrames.Count == 0) return false;
            return (subFrames.Last().IsComplete()) &amp;&amp;
                (isLambdaComplete == null ||
                 isLambdaComplete(frameNumber, GetnPlays(), GetScore()));
        }




        public int GetnPlays()
        {
            return subFrames.Count();
        }




        public int[] GetScore()
        {
            return subFrames.Select(sf =&gt; sf.GetScore()).Sum();
        }



        List&lt;IConsistsOf&gt; IConsistsOf.GetSubFrames()
        {
            return subFrames;
        }




        IConsistsOf IConsistsOf.GetCopy(int frameNumber)
        {
            var gf = new Frame(frameNumber);
            gf.objectName = this.objectName;
            gf.subFrames = new List&lt;IConsistsOf&gt;();
            gf.downstream = downstream.GetCopy(0);
            gf.isLambdaComplete = this.isLambdaComplete;
            return gf as IConsistsOf;
        }

    }
}</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="trueexample-project-tennis"><a class="anchor" href="#trueexample-project-tennis"></a>4.21. Example project - Tennis</h3>
<div class="paragraph">
<p>Now let&#8217;s modify the bowling application to score tennis. If the bowling game hadn&#8217;t been implemented using ALA, you probably wouldn&#8217;t contemplate doing this. But ALA excels for maintainability, and I want to show that off by changing Bowling to Tennis. The Frame and IConsistsOf abstractions look like they could be pretty handy for Tennis. A match consists of sets, which consists of games, which consists of SinglePlays.</p>
</div>
<div class="paragraph">
<p>We will need to make a small generalization to the Frame abstraction first. This will allow it to keep score for two players. We just change the type of the score from int to int[]. The Ball method will be generalised to take a player parameter to indicate which player won a play. A generalization of an abstraction to make it more reusable is a common operation in ALA.</p>
</div>
<div class="paragraph">
<p>The only other thing we will need to do is invent a new abstraction to convert a score such as 6,4 into a score like 1,0, because, for example, the winner of a game takes one point into the set score. This new abstraction is called WinnerTakesPoint (WTP in the diagram).</p>
</div>
<div class="paragraph">
<p>Here is the tennis scoring game:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/tennis1.png" alt="tennis1">
</div>
</div>
<div class="paragraph">
<p>The diagram expresses all the details of the requirements of tennis except the tiebreak.</p>
</div>
<div class="paragraph">
<p>Here is the diagram&#8217;s corresponding code:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>private IConsistsOf match = new Frame()
    .setIsFrameCompleteLambda((matchNumber, nSets, score) =&gt; score.Max()==3)
    .WireTo(new WinnerTakesPoint()
        .WireTo(new Frame()
            .setIsFrameCompleteLambda((setNumber, nGames, score) =&gt; score.Max()&gt;=6 &amp;&amp; Math.Abs(score[0]-score[1])&gt;=2)
            .WireTo(new WinnerTakesPoint()
                .WireTo(new Frame()
                    .setIsFrameCompleteLambda((gameNumber, nBalls, score) =&gt; score.Max()&gt;=4 &amp;&amp; Math.Abs(score[0]-score[1])&gt;=2)
                    .WireTo(new SinglePlay()))))));</pre>
</div>
</div>
<div class="paragraph">
<p>The new WinnerTakesPoint abstraction is easy to write. It is a decorator that implements and requires the IConsistsOf interface. Most methods pass through except the GetScore, which returns 0,0 until the down-stream object completes, then it returns either 1,0 or 0,1 depending on which player has the higher score.</p>
</div>
<div class="paragraph">
<p>And just like that, the tennis application will now execute. The frame abstraction we invented for bowling is already done.</p>
</div>
<div class="sect3">
<h4 id="trueadd-tiebreak"><a class="anchor" href="#trueadd-tiebreak"></a>4.21.1. Add tiebreak</h4>
<div class="paragraph">
<p>Now let&#8217;s switch our attention back to another example of maintenance. Let&#8217;s add the tiebreak feature. Another instance of Frame will score the tiebreak quite nicely. However we will need an abstraction that can switch us from playing the set to the tie break. Let&#8217;s call it Switch, and give it a lambda function to configure it with when to switch from one subframe tree to another. Switch simply returns the sum of scores of its two subtrees. Here then is the full description of the rules of tennis:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/tennis2.png" alt="tennis2">
</div>
</div>
<div class="paragraph">
<p>And here is the code version of that diagram. This application passes an exhaustive set of tests for the scoring of tennis.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>private IConsistsOf match = new Frame("match")
    .setIsFrameCompleteLambda((matchNumber, nSets, score) =&gt; score.Max()==3)
    .WireTo(new WinnerTakesPoint("winnerOfSet")
        .WireTo(new Switch("switch")
            .setSwitchLambda((setNumber, nGames, score) =&gt; (setNumber&lt;4 &amp;&amp; score[0]==6 &amp;&amp; score[1]==6))
            .WireTo(new Frame("set")
                .setIsFrameCompleteLambda((setNumber, nGames, score) =&gt; score.Max()&gt;=6 &amp;&amp; Math.Abs(score[0]-score[1])&gt;=2)
                .WireTo(new WinnerTakesPoint("winnerOfGame")
                    .WireTo(new Frame("game")
                        .setIsFrameCompleteLambda((gameNumber, nBalls, score) =&gt; score.Max()&gt;=4 &amp;&amp; Math.Abs(score[0]-score[1])&gt;=2)
                        .WireTo(new SinglePlay("singlePlayGame"))
                    )
                )
            )
            .WireTo(new WinnerTakesPoint("winnerOfTieBreak")
                .WireTo(new Frame("tiebreak")
                    .setIsFrameCompleteLambda((setNumber, nBalls, score) =&gt; score.Max()==7)
                    .WireTo(new SinglePlay("singlePlayTiebreak"))
            )
        )
    )
);</pre>
</div>
</div>
<div class="paragraph">
<p>And just like that we have a full featured executable tennis scoring engine.</p>
</div>
</div>
<div class="sect3">
<h4 id="truefinal-notes"><a class="anchor" href="#truefinal-notes"></a>4.21.2. Final notes</h4>
<div class="paragraph">
<p>Notice that I have added string names to the instances of Frame and other objects. This is not required to make the program function, but generally is a good habit to get into in ALA. It is because in ALA we typically use multiple instances of abstractions in different parts of the program. The names give us a way of identifying the different instances during any debugging. Using them I can Console.Writeline debugging information along with the object&#8217;s name.</p>
</div>
<div class="paragraph">
<p>Around 8 lines of code express the rules of ten-pin bowling and around 15 lines of code express the rules of tennis. That sounds about right for the inherent complexity of the two games. The two rule descriptions actually execute and pass a large battery of tests.</p>
</div>
<div class="paragraph">
<p>The domain abstractions are zero-coupled with one another, and are each straightforward to write by just implementing the methods of the IConsistOf interface according to what the abstraction does. The abstractions are simple and stable. So no part of the program is more complex than its own local part.</p>
</div>
<div class="paragraph">
<p>The domain abstractions are reusable in the domain of game scoring. And, my experience was that as the details inside the abstractions were implemented, the application design didn&#8217;t have to change.</p>
</div>
<div class="paragraph">
<p>Why two example applications? The reason for doing two applications in this example is two-fold.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>To show the decreasing maintenance effort. The Tennis game was done easily because it reused domain building blocks we had already created for bowling.</p>
</li>
<li>
<p>To emphasis where all the details of the requirements end up. The only difference between the bowling and tennis applications is the two diagrams, which are translated into two code files: bowling.cs and tennis.cs of 8 lines and 15 lines respectively. These two files completely express the detailed requirements of their respective games. No other source files have any knowledge of these specific games. Furthermore, Bowling.cs and Tennis.cs do not do anything other than express requirements. All implementation to actually make it execute is hidden in domain abstractions and programming paradigm abstractions.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Here is a link to the code on Github: <a href="https://github.com/johnspray74/GameScoring">GameScoring code</a></p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="truechapter-five-methodology"><a class="anchor" href="#truechapter-five-methodology"></a>5. Chapter five - Methodology</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="truethe-first-few-strokes"><a class="anchor" href="#truethe-first-few-strokes"></a>5.1. The first few strokes</h3>
<div class="paragraph">
<p>As a software engineer contemplating a new project, I have often asked myself "Where do I start?" This also happens with legacy code, when contemplating the direction that refactorings should take. "If this software were structured optimally well, what would it look like?"</p>
</div>
<div class="paragraph">
<p>Christopher Alexander, the creator of the idea of design patterns in building architecture, said, "As any designer will tell you, it is the first steps in a design process which count for the most. The first few strokes which create the form, carry within them the destiny of the rest". This has been my experience too.</p>
</div>
<div class="paragraph">
<p>In Agile, where architecture is meant to emerge, this wisdom has been lost. ALA restores that wisdom to software development, and gives the software architect the exact process to follow for that little piece of up-front design. No more than one sprint is required to do this architectural work, regardless of the size of the project.</p>
</div>
<div class="paragraph">
<p>Furthermore, once this architectural work is done, the Agile process works significantly better thereafter.</p>
</div>
<div class="paragraph">
<p>My experience over several projects so far is that the initial architecture does not need to change as the development proceeds if good quality abstraction are invented.</p>
</div>
<div class="paragraph">
<p>There is one aspect of ALA that is hard to master - the invention of appropriate abstractions in a new domain. The reason why the "standard deviation uses squareroot" example seems easy is that the squareroot abstraction was already invented, and we already know it. In ALA you will need to invent your own domain level abstractions. In other engineering disciplines, new abstractions come along only every few years, or hundreds of years sometimes. In software engineering, we have to do it every day in the first two weeks of a project in a new domain, and probably every iteration after that for a few iterations. But all whom I have taught how to do this have found it worth the effort, and all get much better at doing it. Working in the resulting zero-coupled code becomes a joy.</p>
</div>
</div>
<div class="sect2">
<h3 id="trueagility"><a class="anchor" href="#trueagility"></a>5.2. Agility</h3>
<div class="paragraph">
<p>ALA is inherently optimally agile (except for an Iteration zero which we will discuss next). By optimally agile, we mean that the amount of code that changes to change functional requirements is the minimum it can be. The amount of code that actuall depends on requirements is a small percentage of the total. This differs from the average application where most code depends on the requirements.</p>
</div>
<div class="paragraph">
<p>ALA achieves this at its first level of separation of concerns. This first  separation is to separate code that will just describe requirements from code that will implementation the abstractions needed to describe the requirements. This implementation code never has knowledge of any requirements, so it generally doesn&#8217;t change when requirements change. Only the code that describes requirements needs to change, and that code is optimally minimal.</p>
</div>
<div class="sect3">
<h4 id="trueiteration-zero"><a class="anchor" href="#trueiteration-zero"></a>5.2.1. Iteration zero</h4>
<div class="paragraph">
<p>When a new project begins, the only new information we have is the requirements. Any design decisions that don’t depend on the specific requirements could already have been made beforehand. It is those decisions that form the ALA reference architecture. Therefore, when we get the requirements, that is our immediate and total focus. We may not know all of them, but we will only need a sample to build start inventing our domain abstractions.</p>
</div>
<div class="paragraph">
<p>Looking at the available new information as a whole first instead of taking it a bit at a time during the project&#8217;s sprints will make a huge difference to the quality of the abstractions we invent, and eventually the quality of the application&#8217;s architecture.</p>
</div>
<div class="paragraph">
<p>The process in the first iteration takes requirements one by one, and represents them, in all their detail. Domain abstractions will be invented as you go, and they will have parameters or properties that will handle those details from requirements.</p>
</div>
<div class="paragraph">
<p>For the first green field application, you spend a maximum of one sprint. After that you do need to find out if your design works. So you may not get through all the known requirements. That does not matter.</p>
</div>
<div class="paragraph">
<p>To know whether knowledge from your design goes in the application layer or the domain abstractions layers, you consider what the scope of that knowledge is. Is the knowledge specific to this one requirement in the one application, or is it potentially reusable in the same or other applications? A softkey label is clearly specific and goes in the application. The concept of softkeys is clearly a domain abstraction.</p>
</div>
<div class="paragraph">
<p>The output of the first sprint does not implement any of the invented abstractions, but it does include all details of the requirements that are looked at. In so doing, you design the first approximation of a DSL. The DSL may be refined later as more requirements are looked at.</p>
</div>
<div class="paragraph">
<p>Each abstraction will eventually be implemented as a class, but initially we just record the names of the abstractions, and a short explanation that provides the insight into what the abstraction does.</p>
</div>
<div class="paragraph">
<p>By the end of the first sprint the requirements will have become easier and easier to represent, as the set of abstractions will have taken shape. Sometimes you will generalise an abstraction further to enable it to be useful in more parts of the application.</p>
</div>
<div class="paragraph">
<p>By keeping moving through the requirements at a much faster pace than in normal development (say one feature per hour instead of one per week), we can keep representing them in a coherent way, revising abstraction ideas we have already invented. Ideally, we will end up with a set of domain abstractions that can be wired together in different ways to represent the requirement space - the space of all possible requirements. That space, which we call the domain, will grow slightly as time goes on and it accommodates a growing family of products, but we don’t want it to grow beyond that. We don’t want to invent ways of implementing things we will never do.</p>
</div>
<div class="paragraph">
<p>On the other hand, we do want to invent quite a few abstractions during this first iterations so that we end up with a coherent set of them that will compose together in an infinite variety of ways.</p>
</div>
<div class="paragraph">
<p>The output of sprint zero is usually a diagram showing the wiring of instances of abstractions, together with configuration information for those instances.</p>
</div>
<div class="paragraph">
<p>It doesn’t matter if some of the requirements are wrong. Chances are they are still useful for scoping out the domain space. What we are actually producing in this phase are the necessary abstractions for the Domain Abstractions layer. If the requirements change later, it will be trivially simple to change them as only the Application layer wiring should change.</p>
</div>
<div class="paragraph">
<p>Once this process has started to become easy, which should happen within the first sprint, the burning question in our minds will become “Will all this actually work?” We have to trust that there will be a way to write those abstractions to make the whole system execute.</p>
</div>
</div>
<div class="sect3">
<h4 id="truehow-to-invent-domain-abstractions"><a class="anchor" href="#truehow-to-invent-domain-abstractions"></a>5.2.2. How to invent Domain Abstractions</h4>
<div class="paragraph">
<p>The most difficult part for people new to ALA is the skill of inventing the domain abstractions. You can fully understand the theory of ALA and why we need to invent abstractions, and still find it tricky to actually invent them. That&#8217;s because in this step in the process, we have to literally become inventors who are adding to the state of the art within your domain.</p>
</div>
<div class="paragraph">
<p>So the biggest insight I can offer here is don&#8217;t expect it to come without effort. Put your inventors hat on. Deliberate about the problem over a long period of time. Leave it overnight. Come back to it afresh in a week. Be patient.</p>
</div>
<div class="paragraph">
<p>I sometimes find that a solution will pop out of nowhere while reading about something completely unrelated. Once the human mind has been deliberating for some time, it remembers the whole context of the problem, and seems to carry on pattern matching for potential solutions in the background. I am reminded of the story of the Dam Busters. The British wanted to bomb the German dams to flood the industrial valleys below them. They worked out that they could deliver the bombs to the face of dam by skipping them across the surface of the lake. But they couldn&#8217;t get their bomber low enough to the water at night to get them to skip, because they had no way of knowing their height above the water.</p>
</div>
<div class="paragraph">
<p>Then one of the pilots was attending a play. He saw the spotlights pointing at the actor from different angles. And suddenly he had the solution. By mounting spotlights at the nose and the tail of the aircraft at a certain angle, they would know when they were at the correct height when the two spots came together at the surface of the water.</p>
</div>
<div class="paragraph">
<p>In my experience, there is always a solution, and it is always worth the effort. Just as good inventions are like gold, good abstractions are like gold in your application.</p>
</div>
<div class="paragraph">
<p>This section offers some practical tips on where to start.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>You start by simply expressing requirements. You are inventing domain abstractions to allow you to express the requirements succinctly, but including all their details.</p>
</li>
<li>
<p>Draw a diagram that describes the requirements. You will draw boxes with lines. The boxes are your invented domain abstractions. The lines are your invented programming paradigms.</p>
</li>
<li>
<p>Look at the English version of the requirements for words that recur. These are candidates for abstractions.</p>
</li>
<li>
<p>Your diagram should have about the same amount of information as the English requirements. It will be succinct, even though it will include lots of detail such as text strings that come from requirements. Anything else that even begins to look like implementation or how it will work or execute is the beginning of an idea for an abstraction. Don&#8217;t worry about them. Just concentrate on making a description of requirements.</p>
</li>
<li>
<p>Always keep in mind that reusability and abstraction are two sides of the same coin. Your invented abstractions are anything that is potentially reusable.</p>
</li>
<li>
<p>Start with the user interface. Sketch multiple parts of the UI to make it more concrete. Then it is relatively easy to invent abstractions for your UI. They are things that will recur in different parts of the UI that you will always want to be done the same way. We can draw inspiration from the many widgets we already find in UI frameworks. ALA will often have equivalent ones that are just a little more specialised to your domain. Buttons may have a consistent size and style in your domain. Or your domain may need Softkeys, which are not usually part of a UI framework.</p>
<div class="paragraph">
<p>ALA UI abstractions will usually be composed together in a tree structure representing the containment structure. This is similar to the tree structure of XAML, but in ALA we will usually do it as a diagram that is just one part of the entire application diagram.</p>
</div>
</li>
<li>
<p>Once you have designed some UI, you will then want to connect the UI elements that display data to some data sources. These data source are candidates for abstractions. For example, a data source that represents a disk file can be an abstraction that handles a disk file format. You will start to have dataflows between instances of data sources, be they UI elements or other source/destinations.</p>
</li>
<li>
<p>Between your data end points, data may need to be transformed, aggregated, filtered, sorted, validated or transacted (transacted means either all of it or none of it). All of these are great candidates for domain abstractions.</p>
</li>
<li>
<p>Sometimes a data source or destination will involve a protocol. A protocol is a domain abstraction. One abstraction should be invented to know about the protocol so that no other abstraction needs to know anything about the protocol. Sometimes there are protocols on top of protocols. For example, on top of a serial data stream protocol such as line terminated text, you may have another protocol that specifies the expected content of the first line.</p>
<div class="paragraph">
<p>This same idea applies to file formats. A file format, such as a CSV file becomes an abstraction. If there is further formatting expected on top of the basic CSV format, such as a header row, that becomes a second abstraction.</p>
</div>
<div class="paragraph">
<p>As with all abstractions, these abstractions know all about the details of something, e.g. a protocol or a format, and become the only thing in the entire application that does know about it.</p>
</div>
<div class="paragraph">
<p>As a result these types of abstractions will usually handle the data going in both directions - sending and receiving, reading and writing.</p>
</div>
</li>
<li>
<p>If you have hardware devices, each will become an abstraction. For example, an ADC device will become a domain abstraction. The abstraction will know all the detail about the device (everything that is in the datasheet for the device). No other part of the program will know these details.</p>
<div class="paragraph">
<p>If you have an ADC device that has an SPI interface, that will become two abstractions, one that knows all the details of the device, and one that knows all the details of the basic SPI interface.</p>
</div>
</li>
<li>
<p>Sometimes a section of requirements will seem like it should become a 'module' or 'function' - for example to parse a string. Try to turn the module or function into something more generally useful. Even if you still end up having only one instance of it for now, by separating that module or function into a general part and a configuration part (that has the information for it&#8217;s specific use in the one part of your application), you will make the general part easier to know what it does - simply because it is more abstract. In time you will often generalise it further and start to have instances of it elsewhere.</p>
</li>
<li>
<p>If all else fails, just start writing code that implements the requirements in the old fashioned way, not worrying about how messy it gets. When it is functioning as you want, then refactor it to ALA as follows. This is actually quite a straightforward process.</p>
<div class="paragraph">
<p>Any code that has details that come from requirements, move that to the application layer, leaving behind generalised functions or classes that have parameters or configuration properties that the application will pass in.</p>
</div>
<div class="paragraph">
<p>At first the generalised classes may have only one instance each. Look for ones that have similar functionality and combine them. The difference between them become further configuration properties, sometimes in the form of lambda expressions.</p>
</div>
<div class="paragraph">
<p>Now refactor the generalised classes or functions so that they do not call each other directly.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>In the case of functions, this step will involve adding new 'wiring' parameters that themselves take functions. The application will pass in the function that it needs to be wired to. These wiring parameters will usually either be to pull the input or push the output. The wiring function signatures should be even more generalised to allow Lego-like composition of functions by the application. They become interfaces in the programming paradigms layer. Section 1.11 has a worked example of refactoring of functions to ALA.</p>
</li>
<li>
<p>In the case of classes, this step will involve adding dependency injection setters. These will be used by the application to specify what class and instance it will talk to. This step removes all uses of the "new" keyword from the class (except ones that are instantiating classes in a lower abstraction layer such as your framework).</p>
<div class="paragraph">
<p>If you have any uses of the observer pattern (publish/subscribe pattern), move the code that does the actual registering or subscribing up to the application. Provide a dependency injection setter for it to use.</p>
</div>
<div class="paragraph">
<p>The dependency injection setters should all take generalised interfaces as thier parameter to allow Lego-like composition of class instances by the application.</p>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Your classes and functions are now proper abstractions because they don&#8217;t know anything about the outside world, including who they are wired to, making them reusable.</p>
</div>
</div>
<div class="sect3">
<h4 id="true2nd-sprint"><a class="anchor" href="#true2nd-sprint"></a>5.2.3. 2nd Sprint</h4>
<div class="paragraph">
<p>In the second sprint we start converging on normal Agile. You pick one feature to implement first. Agile would say it should be the most essential feature to the MVP (minimum viable product), but this can be tempered by the need to choose one that requires a fewer number of abstractions to be implemented. Next, you design the interfaces that will allow those abstractions to plug together according to the wiring you already have from the first sprint. What messages will these paradigm interfaces need to pass at runtime between the unknown clients to make them work?</p>
</div>
<div class="paragraph">
<p>It may take several sprints to produce the first working feature, depending on the number of abstractions it uses.</p>
</div>
<div class="paragraph">
<p>At first this sounds as if it might be just the waterfall method reincarnated. Do an overall design, document it or model it, and then write lots of code before everything suddenly starts working. But the design we created in iteration zero is very different from what a normal waterfall would produce, and is resilient to the sorts of problems waterfall creates. Instead of a ‘high level’ design of how the implementation will work which is lacking in detail, the design is a representation of requirements, in full detail. The design is not a model. It is executable.</p>
</div>
<div class="paragraph">
<p>There is one more important thing that the design phase in Iteration Zero does. While it deliberately doesn’t address any implementation, it does turn the remainder of the implementation into abstractions, and those abstractions are zero coupled. To convert from executable to actually executing, it only remains to implement these now completely separate parts. You can give these abstractions to any developer to write.  Together the developers will also easily be able to figure out the paradigm interface methods needed to make them work, and the execution models to take care of the execution flow through them with adequate performance.</p>
</div>
<div class="paragraph">
<p>Often when a project is split into two phases, the first phase turns out to be waste. The devil is in the details so to speak. This happens because the implementation details in phase two are coupled back to and affect the design in phase one. As learnings take place during implementation, the design must change. In ALA the output from phase one is primarily abstractions, which are inherently stable and therefore hide details that can&#8217;t affect the overall design. If the abstractions are good, phase two will typically have little effect on the work done in phase one.</p>
</div>
<div class="paragraph">
<p>Once the first feature is working, several abstractions will have been implemented. The second feature will take less time because some of the abstractions are already done. In ALA velocity increases as time goes on and keeps increasing until new features only involve instantiating, configuring and wiring domain abstractions in new ways. This velocity acceleration is the complete opposite of what happens in monolithic code.</p>
</div>
</div>
<div class="sect3">
<h4 id="truelater-sprints"><a class="anchor" href="#truelater-sprints"></a>5.2.4. Later sprints</h4>
<div class="paragraph">
<p>Imagine going into a sprint planning meeting with a Product Owner, a small team of developers, and a mature ALA domain that already has all the common domain abstractions done. As the Product Owner explains the requirements, one of the team members writes them down directly as they would be represented in terms of the domain abstractions. Another team member watches and remembers any lost details without slowing the product owner down. A third member implements the acceptance tests in similar fashion, and a fourth provides him with test data. It would be nice to have a tool that compiles the diagram into the equivalent wiring code. With such a tool, the team could have it executing by the end of the meeting. At the end of the planning meeting the development team say to the product owner "Is this what you had in mind?". The team can get immediate feedback from the Product Owner that the requirements have been interpreted correctly.</p>
</div>
<div class="paragraph">
<p>Of course, the planning meeting itself would only produce 'normal' functionality. Usually it is up to the development team, not the Product Owner, to uncover all the abnormal scenarios that can happen, and that is usually where most of the work in a software system goes. Having said that, in a mature domain, the validation of data already has decorator abstractions ready to go.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/effort_curve.png" alt="effort curve">
</div>
</div>
<div class="paragraph">
<p>The graph shows the effort per user story against months into a green-field project. The left axis is arbitrary - the shape of the curves is what is important. For a big ball of mud, experience tells us that the effort increases dramatically and can asymptote at around 2 years as our brains can no longer handle the complexity, and the project must be abandoned.</p>
</div>
<div class="paragraph">
<p>The COCOMO model, which is an average of industry experience, has a power relationship with program size, with an exponent of around 1.05 to 1.2. I have used the mid point, 1.1, for this graph. The model appears to imply that getting lower than 1.0 is a barrier, but there is no reason to believe this is the case. Reuse can make the power become less than 1. The range of 1.05 and 1.2 probably results from some reuse mitigating some ever increasing complexity.</p>
</div>
<div class="paragraph">
<p>ALA takes advantage of the fact that zero-coupled abstractions can keep complexity relatively constant and drastically increase reuse. A spectacular fall in effort per user story is thus possible.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="truetechnical-debt"><a class="anchor" href="#truetechnical-debt"></a>5.3. Technical debt</h3>
<div class="paragraph">
<p>Technical debt is real. Convincing your non-technical manager that it is real is not realistic, especially when you tell him that this is based on estimates. He already knows about your 'estimates'. Even if you could measure it, and offer your manager a payback period for a one-day investment in refactoring, there is a problem. He is measured on this sprints performance. Or he is measured on some other criteria such as this years budgeted sales. Technical debt is tomorrow&#8217;s problem, and that is not his problem, not ever.</p>
</div>
<div class="paragraph">
<p>A better answer would be to not generate technical debt in the first place. In Agile we are taught that the architecture depends on the what we learn as we write the code. The Definition of Done is supposed to tell us to clean it up as we learn. But it is also possible that we will learn something that requires previous sprint&#8217;s of work to be cleaned up. A refactoring could need changes to the structure at the largest granularity level.</p>
</div>
<div class="paragraph">
<p>So here is a better solution. What if, as far as possible, we know a meta architecture that all software programs should follow. It is a big scale meta-architecture, so it gets things into the right places in the big scale.</p>
</div>
<div class="paragraph">
<p>So now you just get it right in the first place. Isn&#8217;t that better?</p>
</div>
<div class="paragraph">
<p>Now some will argue that they do that already. Their large scale structure is layering, or it is MVC or it something else. I have been told that this doesn&#8217;t work because we fail to actually keep to the prescribed architecture. But think it is because up till now, these architectural patterns have not worked very well.</p>
</div>
</div>
<div class="sect2">
<h3 id="truefolder-structure"><a class="anchor" href="#truefolder-structure"></a>5.4. Folder structure</h3>
<div class="literalblock">
<div class="content">
<pre>[tree,file="folderstructure.png"]
root
|--Application1
|  `--application.cpp
|--Application2
|  `--application.cpp
|--DomainAbstractions
|  |--abstraction1.cpp
|  |--abstraction1.h
|  |--abstraction2.cpp
|  `--abstraction2.h
`--ProgrammingParadigms
   |--Paradigm1.h
   `--Paradigm2.h</pre>
</div>
</div>
<div class="paragraph">
<p>This is a suggested folder structure for ALA. Because ALA does not use decomposition, you don&#8217;t end up with components that are contained by the applications, so there are no subfolders under the application. Instead, you end up with Domain Abstractions outside the application, so they go in their own folder in a flat structure.</p>
</div>
<div class="paragraph">
<p>Similarly, the Programming Paradigms code is not contained by an application, or even by the domain, so would not be contained by the domain&#8217;s projects folder.</p>
</div>
</div>
<div class="sect2">
<h3 id="trueconvention-over-configuration"><a class="anchor" href="#trueconvention-over-configuration"></a>5.5. Convention over configuration</h3>
<div class="paragraph">
<p>When the application create an instance of an abstraction, most of the configuration of that abstraction should have defaults. In ALA, setters allow optional configuration, reducing the amount of information that would otherwise be required in the application to fully configure each abstraction. Any configuration that we wish to enforce goes into the constructor.</p>
</div>
<div class="paragraph">
<p>There is a counter argument that says that all configuration should be explicit so that nothing can be forgotten. ALA prefers optional configuration because we want the application to just express the requirements. Also optional configuration allows abstractions to default to their simplest form, making them easier to learn.</p>
</div>
</div>
<div class="sect2">
<h3 id="trueknowledge-prerequisites"><a class="anchor" href="#trueknowledge-prerequisites"></a>5.6. Knowledge prerequisites.</h3>
<div class="paragraph">
<p>When other programmer are doing maintenance on your code, you should make sure they have the knowledge they need. They will need knowledge of ALA. They will need to know about the programming paradigms used. They will need to know about the domain abstractions, and the insight of what each one does. And then they should know that the application diagram is the source code. It is up to you that every develop that follows will know all this.</p>
</div>
<div class="sect3">
<h4 id="trueintellisence"><a class="anchor" href="#trueintellisence"></a>5.6.1. Intellisence</h4>
<div class="paragraph">
<p>After they have modified the diagram, the maintaining developers will need to manually modify the corresponding code. Here they will see instances of abstractions being used all over the place, either 'new' keywords or function calls. If we have done our job with knowledge prerequisites, they will have been introduced to these abstractions. However, it doesn&#8217;t hurt to have brief reminders of what they are pop up when the mouse is hovered over them. So put in triple slash comments (or equivalent) describe the abstraction succinctly, with the intention of it being a reminder to someone who has already met the abstraction. Put a full explanation in the remarks and examples sections.</p>
</div>
<div class="paragraph">
<p>The class name after a new keyword is actually the constructor name, so you must duplicate the summary section there. Often in ALA, the class name is not referred to at all in the application.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="truetwo-roles"><a class="anchor" href="#truetwo-roles"></a>5.7. Two roles</h3>
<div class="paragraph">
<p>ALA requires two roles. Both can be done by the same person, but always he should be wearing only one hat at a time. There is the role of the architect, and the role of the developer.</p>
</div>
<div class="paragraph">
<p>The role of the architect is harder than that of the developer, that&#8217;s why we have the role. Expect it to be hard.
Perhaps, surprisingly, the architect&#8217;s main job is to focus on the requirements, and the developers main job is to implement the abstractions (which know nothing of the requirements). In describing the requirements, the architect invents domain abstractions.</p>
</div>
<div class="paragraph">
<p>The architect also has a role in helping the developer to design the interface&#8217;s methods. In other words, how at runtime the system will be made to work.</p>
</div>
<div class="paragraph">
<p>This aspect of ALA can also be difficult at times. I have sometimes got stuck for a day or so trying to figure out how the interfaces should work, while still keeping them more abstract than the domain abstractions. The ALA constraints are that these interfaces should work between any two domain abstractions for which it may be meaningful if they are composed together in an application. However, the problem has always been solvable, and once solved, it always seems to have a certain elegance, as if you have created a myriad of possibilities at once. Implementation of the interfaces by the relevant domain abstractions becomes easy. Development then proceeds surprisingly quickly.</p>
</div>
</div>
<div class="sect2">
<h3 id="trueexample-project-coffee-machine"><a class="anchor" href="#trueexample-project-coffee-machine"></a>5.8. Example Project - Coffee machine</h3>
<div class="paragraph">
<p>Robert Martin posed an interesting pedagogical sized embedded system problem about a coffee maker in his book “Agile Software Development: Principles, Patterns and Practices”. The original chapter is called “Heuristics and Coffee”.</p>
</div>
<div class="paragraph">
<p>In the original chapter, the worked solution to this problem uses decomposition into three modules that collaborate or interact with one another. The ALA solution follows the opposite philosophy. It has three abstractions (which correspond with the three modules), but they do not collaborate or interact with one another. Being abstractions, they don&#8217;t know anything about each other. As domain abstractions, they also know nothing about the coffee machine. The coffee machine is then constructed (as another abstraction in the top layer) that makes use of the three domain abstractions.</p>
</div>
<div class="paragraph">
<p>This example uses different execution models from the 'consistsof' and 'dataflow' ones that we used in previous examples. Here we will use some extremely simple, yet quite interesting electronic-signal-like execution models that have a simple main-loop polling type implementation, just as Robert Martin&#8217;s original solution also had.</p>
</div>
<div class="paragraph">
<p>Reading an ALA application requires first knowing the pre-requisite knowledge you need from lower layer abstractions. So before presenting the application, let&#8217;s first familiarise ourselves with the abstractions we need from the domain layer, and the Programming Paradigms layer.</p>
</div>
<div class="sect3">
<h4 id="truedomain-abstractions-layer-2"><a class="anchor" href="#truedomain-abstractions-layer-2"></a>5.8.1. Domain abstractions layer</h4>
<div class="paragraph">
<p>Here are the three domain abstractions:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/Coffee%20Maker%20Domain%20Components.vsd.jpg" alt="Coffee Maker Domain Components.vsd.jpg">
</div>
<div class="title">Figure 46. Coffee maker domain abstractions</div>
</div>
<div class="paragraph">
<p>Take a moment to look at these three abstractions:</p>
</div>
<div class="paragraph">
<p>&#8201;&#8212;&#8201;The UI has a lamp you can control, and a push button which outputs an event (should have been two separate abstractions).</p>
</div>
<div class="paragraph">
<p>&#8201;&#8212;&#8201;There is a WarmerPlate. It tells you whether or not a container is on the warmer plate, and whether or not it is empty. It controls its own heater.</p>
</div>
<div class="paragraph">
<p>&#8201;&#8212;&#8201;There is a  Boiler. It can be turned on or off. It will tell you when it is empty of water. And you can stop water flow instantly with a steam release valve. It will turn its own heater off if it runs out of water, or the valve is opened.</p>
</div>
<div class="paragraph">
<p>That&#8217;s all there is to know about the three domain abstractions.</p>
</div>
</div>
<div class="sect3">
<h4 id="trueprogramming-paradigms-layer-2"><a class="anchor" href="#trueprogramming-paradigms-layer-2"></a>5.8.2. Programming Paradigms layer</h4>
<div class="paragraph">
<p>We have three programming paradigms</p>
</div>
<div class="paragraph">
<p>&#8201;&#8212;&#8201;live dataflow (works like an electronic circuit)</p>
</div>
<div class="paragraph">
<p>&#8201;&#8212;&#8201;events</p>
</div>
<div class="paragraph">
<p>&#8201;&#8212;&#8201;simple state machine</p>
</div>
<div class="paragraph">
<p>The API for the Programming Paradigms layer is described in the key on the right of the diagram below. It gives you all the knowledge from this layer to be able to read the diagram. So, for example, a solid line is a dataflow; the rounded box is state with the states enumerated inside it.</p>
</div>
<div class="paragraph">
<p>The details of how to turn the diagram into code is explained in a project document, also provided in the Programming Paradigms layer.</p>
</div>
</div>
<div class="sect3">
<h4 id="trueapplication-layer-3"><a class="anchor" href="#trueapplication-layer-3"></a>5.8.3. Application layer</h4>
<div class="paragraph">
<p>Now that we have understood the knowledge dependencies in all lower layers, we can read the diagram that resides in the top layer, the application layer:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/Coffee%20Maker%20Dataflow%20diagram.vsd.jpg" alt="CoffeeMaker Dataflow diagram">
</div>
<div class="title">Figure 47. Coffee maker solution</div>
</div>
<div class="paragraph">
<p>The diagram to the left is the application itself. Instances of the three domain abstractions, UI, Boiler and Warmer plate are shown as boxes.</p>
</div>
<div class="paragraph">
<p>Follow me now as we go through the user stories by looking at the lines on the diagram:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>When the UI push button is pressed, we set the state to Brewing, provided the Boiler has water and the pot is on the Warmerplate.</p>
</li>
<li>
<p>When the state is brewing, it turns on the boiler, and coffee making starts.</p>
</li>
<li>
<p>If someone takes the pot off, the valve is opened to momentarily release pressure from the boiling water, which stops the water flow.</p>
</li>
<li>
<p>When the boiler becomes empty, the state is set to Brewed. When the state is Brewed, the light in the UI is turned on.</p>
</li>
<li>
<p>When the coffee pot is replaced empty, the state goes back to the idle state where we began.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>That&#8217;s all there is to reading this application. The code for the coffee machine can be read and understood in about one minute. Compare that with reading other solutions to the coffee machine problem.</p>
</div>
<div class="paragraph">
<p>Note that the paragraph above is pretty much a restatement of the requirements in English. It could have been the requirements. The amount of information in the English form (or the diagram form) is about the same, thus the Domain Abstractions gave us the correct level of expressiveness. Further confirmation of this is if the level of expressiveness allows us to modify it.</p>
</div>
<div class="paragraph">
<p>For example, say a requirement was added that a coin device was to enable the machine to be used. The coin device is an abstraction that provides an output when a coin is given, and has a reset input. Looking at the diagram, and being able to reason about its operation so easily, you can see that the coin device&#8217;s output would intercept the Pushbutton using another instance of an AND gate. And to reset the coin device, you could use the boiler empty output event.</p>
</div>
</div>
<div class="sect3">
<h4 id="trueexecution"><a class="anchor" href="#trueexecution"></a>5.8.4. Execution</h4>
<div class="paragraph">
<p>To make it actually execute, we apply the manual procedure documented in “Execution models.doc”. This document is in the Programming Paradigms layer. It will generate these 6 lines of code:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>if (userInterface.Button &amp;&amp; warmerPlate.PotOnPlate &amp;&amp; !boiler.Empty) { state = Brewing; } userInterface.Button = false;
boiler.OpenSteamReleaseValve = !warmerPlate.PotOnPlate;
boiler.On = state==Brewing;
if (boiler.Empty &amp;&amp; !prevBoilerEmpty) { state = Brewed; } prevBoilerEmpty = boiler.Empty;
if (warmerPlate.PotEmpty &amp;&amp; !prevPotEmpty) { state = Idle; } prevPotEmpty = warmerPlate.PotEmpty;
userInterface.LightOn = state==Brewed;</pre>
</div>
</div>
<div class="paragraph">
<p>There is a one-to-one correspondence between the lines in the diagram and the lines in the code.</p>
</div>
<div class="paragraph">
<p>As you can see, the execution model is a simple one. The 6 lines of code are continually executed in a loop. This execution model is effective and appropriate for this small application.</p>
</div>
<div class="paragraph">
<p>The 6 lines of code can be built into a complete program shown below:</p>
</div>
<div class="literalblock">
<div class="content">
<pre> #ifndef _COFFEE_MAKER_H_
 #define _COFFEE_MAKER_H_
 // Coffee Maker domain abstraction
 #include "CoffeeMakerAPI.h"  // original hardware abstraction supplied by hardware engineers
 // Knowledge dependencies :
 // "PolledDataFlowProgrammingParadigm.doc" -- explains how to hand compile a dataflow diagram of this type to C code
 // Following are 3 Domain abstractions that the application has knowledge dependencies on



 #include "UserInterface.h"
 #include "Boiler.h"
 #include "WarmerPlate.h"



 class CoffeeMaker
 {
 private:
    enum {Idle, Brewing, Brewed} state;
    Boiler boiler;
    UserInterface userInterface;
    WarmerPlate warmerPlate;
    bool prevBoilerEmpty, prevPotEmpty;
    void _Poll();
 public:
    CoffeeMaker()
        : state(Idle), prevBoilerEmpty(boiler.Empty), prevPotEmpty(warmerPlate.PotEmpty)
    {}
    void Poll();
 };
 #endif //_COFFEE_MAKER_H_</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre> // CoffeeMaker.c
 // This is not source code, it is code hand compiled from the CoffeeMaker application diagram
 #include "CoffeeMaker.h"

 void CoffeeMaker::_Poll() <i class="conum" data-value="1"></i><b>(1)</b>
 {
    if (userInterface.Button &amp;&amp; warmerPlate.PotOnPlate &amp;&amp; !boiler.Empty) { state = Brewing; } userInterface.Button = false;
    boiler.OpenSteamReleaseValve = !warmerPlate.PotOnPlate;
    boiler.On = state==Brewing;
    if (boiler.Empty &amp;&amp; !prevBoilerEmpty) { state = Brewed; } prevBoilerEmpty = boiler.Empty;
    if (warmerPlate.PotEmpty &amp;&amp; !prevPotEmpty) { state = Idle; } prevPotEmpty = warmerPlate.PotEmpty;
    userInterface.LightOn = state==Brewed;
 }



 void CoffeeMaker::Poll()
 {
    // get inputs processed
    userInterface.Poll();
    boiler.Poll();
    warmerPlate.Poll();
    // run application
    _Poll();
    // get outputs processed
    userInterface.Poll();
    boiler.Poll();
 }</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The 6 lines of code appear in the "CoffeeMaker::_Poll()" function.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you are using a diagram as we are in this solution, you always change the diagram first when the requirements change. It provides the expressiveness needed to see the application’s requirements represented in a clear, concise and coherent way. There the logic can be ‘reasoned’ with. It is not documentation, it is the source code representation of the requirements, and executable, both important aspects of ALA.</p>
</div>
<div class="paragraph">
<p>The next step is to implement the three abstractions. These are straightforward using the same execution model as was used for the application, so are not shown here.</p>
</div>
<div class="paragraph">
<p>The resulting application passes all of Martin&#8217;s original acceptance tests plus a number of additional tests of behaviour gleaned from his original text.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="truechapter-six-perspectives"><a class="anchor" href="#truechapter-six-perspectives"></a>6. Chapter six - Perspectives</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In this chapter, our aim is to look at ALA from the perspective of many existing principles, patterns and styles (PPS) one at a time.</p>
</div>
<div class="paragraph">
<p>The idea is to understand ALA in terms of similarities and differences to get a deeper undertsnading if your way of thinking is already deeply rooted in one of these principles, patterns or styles.</p>
</div>
<div class="paragraph">
<p>In some cases we show how ALA satisfies the PPS automatically. In some cases we point to problems that various writers have about PPSs, and show how ALA solves the problem.</p>
</div>
<div class="paragraph">
<p>PPSs take a long time for the average developer to grasp, and then only make incremental improvement to software quality, if any. Ultimately the aim is that ALA is a reference architecture that makes the PPSs redundant.</p>
</div>
<div class="sect2">
<h3 id="trueencapsulation-polymorphism-and-inheritance"><a class="anchor" href="#trueencapsulation-polymorphism-and-inheritance"></a>6.1. Encapsulation, polymorphism and inheritance</h3>
<div class="paragraph">
<p>ALA replaces encapsulation with abstraction.</p>
</div>
<div class="paragraph">
<p>ALA removes associations and inheritance and instead uses composition (provided the composition uses a more abstract abstraction).</p>
</div>
<div class="paragraph">
<p>ALA replaces polymorphism with zero coupling.</p>
</div>
<div class="paragraph">
<p>The first two we know as fundamental principles in ALA, and have already been discussed in chapter three.</p>
</div>
<div class="paragraph">
<p>The third statement requires some elaboration.</p>
</div>
<div class="paragraph">
<p>In the meme pool of software engineering we have at least five memes for the one concept. These are polymorphism, information hiding, protected variations, dependency inversion principle and open closed principle.</p>
</div>
<div class="paragraph">
<p>I shall argue in their individual discussion later that none of them is a principle.
All five are just a simple pattern. The motivation is that if you have code that couples knowledge of different 'things', you extract the knowledge into their own modules. Now when the 'thing' changes, you can change it or swap it out without affecting the client module. Switch statements were a smell in traditional code that different things were mixed.</p>
</div>
<div class="paragraph">
<p>You may already have separated out one implementation of a thing. So now your client code talks to a concrete thing. The conical example is a particular database. But now you need to use a different thing. Instead of putting in a switch statement everywhere to talk to different databases, you use the polymorphism / information hiding / protected variations / dependency inversion / open closed pattern.</p>
</div>
<div class="paragraph">
<p>The pattern itself consists of an interface. That&#8217;s it. All those memes all trying to tell you to use an interface. Oh, and another one - if you have heard the phrase "program to interfaces".</p>
</div>
<div class="paragraph">
<p>On top of that, single responsibility also pretty much forces the use of an interface. Referring to a peer concrete object is always a second resposibility.</p>
</div>
<div class="paragraph">
<p>ALA does not use this pattern.</p>
</div>
<div class="paragraph">
<p>To understand why, lets call the client module B and the modules that implement the interface, C1, C2 etc. B doesn&#8217;t know which of the C modules it is talking to at run-time. If we want it to be C2 for a particular application, we have higher level code that injects C2 into B.</p>
</div>
<div class="paragraph">
<p>It&#8217;s important that we realize that in this pattern the interface is owned by B. It describes what B <em>requires</em>. It is cohesive with B. It is part of abstraction B. This still the case even if the interface is split out into a module or even a different compilation unit of its own.</p>
</div>
<div class="paragraph">
<p>Therefore C1, C2 etc have a dependency on B. They implement B&#8217;s requirements. They collaborate with it. The dependency in the design is just inverted from what it might have been. C1 &amp; C2 are coupled with B.</p>
</div>
<div class="paragraph">
<p>So this is illegal in ALA (assuming B and C1, C2 etc are all at a similar level of abstraction, which they likely are. That&#8217;s why for ALA I have stated that the equivalent is zero coupling. ALA replaces the dependency with nothing at all between A and C1, C2 etc.</p>
</div>
<div class="paragraph">
<p>We have talked about how ALA still works in Chapters three and four. It does still use an interface but it is not owned by B (or C1 or C2). It is at a much more abstract level, the level of a programming paradigm. For example if abstractions B, C1 and C2 know about the event-driven programming paradigm, then instances of them may be wired together.</p>
</div>
<div class="paragraph">
<p>ALA further requires that the higher level code that does the injecting is also an abstraction. It is just one that is specific to a user story. Let&#8217;s call it A. A needs to cohesively do all the wirings of all the instances of domain abstractions to implement a whole user story in a cohesive way.</p>
</div>
<div class="paragraph">
<p>These five memes don&#8217;t have anything to say about that. They are redundant with respect to ALA. By just using ALA the job is done in a better way.</p>
</div>
<div class="paragraph">
<p>The SRP, DIP amd OCP are discussed further in the sections below.</p>
</div>
</div>
<div class="sect2">
<h3 id="truesolid-principles"><a class="anchor" href="#truesolid-principles"></a>6.2. SOLID Principles</h3>
<div class="paragraph">
<p>The SOLID principles collated by Robert Martin are confusing. Their one or two sentence descriptions don&#8217;t describe them very well, so you have to go a read a lot to understand them. Unfortunately they are collected up into the catchy acrostic "SOLID" with a meaning that is undeserved. This has made the collection more well known than it deserves, as we shall explain.</p>
</div>
<div class="sect3">
<h4 id="truesingle-responsibility-principle"><a class="anchor" href="#truesingle-responsibility-principle"></a>6.2.1. Single Responsibility Principle</h4>
<div class="paragraph">
<p>The SRP strangly worded differently from it&#8217;s name. It states that a module (function, class or package) should have only one reason to change. I find this s strange formulation of the name.</p>
</div>
<div class="paragraph">
<p>By using abstractions, the SRP is complied with in terms of reasons to change. However, some abstractions arguably have more than responsibility. I often use the question "What do you know about?" to an abstraction. It is always one thing it knows about, but it may have multiple responsibilites for that thing.</p>
</div>
<div class="paragraph">
<p>Examples:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>An ADC driver (analog to digital converter hardware) knows all about a particular ADC chip. It has the responsibilies of initializing it and getting the readings from it. It changes only if the HW chip changes.</p>
</li>
<li>
<p>A protocol abstraction knows about a protocol. It has the responsibility to send data using the protocol and to receive it. It changes only if the protocol changes.</p>
</li>
<li>
<p>A file format abstraction, such as CSVFileReaderWriter knows about a file format. It has the responsibility to both read it and write it. It changes if the file format changes.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>My advice is that the SRP is made redundant by thinking in terms of abstractions, which accomplishes the intention of the SRP better.</p>
</div>
</div>
<div class="sect3">
<h4 id="trueopen-closed-principle"><a class="anchor" href="#trueopen-closed-principle"></a>6.2.2. Open Closed Principle</h4>
<div class="paragraph">
<p>Talk about confusing. Firstly Betrand Meyer coins the phrase, which is impossible to understand without further reading. On further reading you find that Robert Martin has a completely different principle by exactly the same name. Then he has two verions of that, one for modules in the same compilation unit and one for when the client is in a different compilation unit and is already published. By the way, being already published was also the context of Meyers OCP.</p>
</div>
<div class="paragraph">
<p>None of them are principles - they would need to be used in the right conext at best. They have associated patterns anyway (or anti-patterns relative to ALA).</p>
</div>
<div class="sect4">
<h5 id="truemartins-version"><a class="anchor" href="#truemartins-version"></a>Martins version</h5>
<div class="paragraph">
<p>The sources of knowledge about the meanings of these memes are:</p>
</div>
<div class="paragraph">
<p>Craig Larman
Kevlin Henny</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="trueliskov-substitution-principle"><a class="anchor" href="#trueliskov-substitution-principle"></a>6.2.3. Liskov Substitution Principle</h4>
<div class="paragraph">
<p>TBD</p>
</div>
</div>
<div class="sect3">
<h4 id="trueinterface-segregation-principle"><a class="anchor" href="#trueinterface-segregation-principle"></a>6.2.4. Interface segregation principle</h4>
<div class="paragraph">
<p>TBD</p>
</div>
</div>
<div class="sect3">
<h4 id="truedependency-inversion-principle"><a class="anchor" href="#truedependency-inversion-principle"></a>6.2.5. Dependency Inversion Principle</h4>
<div class="paragraph">
<p>The DIP is stated:</p>
</div>
<div class="olist upperalpha">
<ol class="upperalpha" type="A">
<li>
<p>High-level modules should not import anything from low-level modules. Both should depend on abstractions (e.g., interfaces).</p>
</li>
<li>
<p>Abstractions should not depend on details. Details (concrete implementations) should depend on abstractions.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>This sounds the same as the ALA fundamental rule that all dependencies must be on abstractions that are more abstract.</p>
</div>
<div class="paragraph">
<p>The Dependency Inversion Principle, and its associated pattern goes some way toward ALA in one respect and far too far in another respect.</p>
</div>
<div class="paragraph">
<p>Firstly ALA uses the word abstraction for the unit of code. The DIP really only uses the word abstraction as a synonym for interface – e.g. abstract class. The essence of the difference is that when ALA allows a dependency on an abstraction, it means more abstract than what DIP does. In both cases an interface is introduced. But in DIP, that interface is owned by the first module, and expresses what that module requires, so it’s highly coupled with the module, not really more abstract than it. ALA’s interfaces don’t belong to domain abstractions but go all by themselves in a lower layer. They are so much more abstract that we call them programming paradigms.</p>
</div>
<div class="paragraph">
<p>To be more precise, the DIP (as its name suggests) reverses a dependency used for communication between two classes, but ALA completely removes it. But the ALA wiring pattern also adds other dependencies. It adds a dependency on each module from a higher layer for dependency injection and it adds dependencies from each module to a programming paradigm interface in a lower layer for ports.</p>
</div>
<div class="paragraph">
<p>Let’s start with conventional code where B talks to C. It uses a dependency:</p>
</div>
<div class="paragraph">
<p>B ---&#8594; C</p>
</div>
<div class="paragraph">
<p>DIP does this:</p>
</div>
<div class="paragraph">
<p>B &lt; --- C</p>
</div>
<div class="paragraph">
<p>ALA does this:</p>
</div>
<div class="paragraph">
<p>B ---- &gt; I</p>
</div>
<div class="paragraph">
<p>C ---- &gt; I</p>
</div>
<div class="paragraph">
<p>Those who know the DIP might immediately say “no the DIP has a version where the interface is put into its own separate package like that as well”. The DIP allows for the interface to be placed in a different compilation package than B. Lets call it IB. Theoretically this allows C (the implementer of IB) to be reused without B. However, this is a superficial change from the point of view of abstraction level. Simply moving IB doesn&#8217;t make it more abstract. That interface is still owned by B - it represents what B requires. So as it still just a part of the B abstraction.</p>
</div>
<div class="paragraph">
<p>With DIP, you get to choose a specific implementation, C, to satisfy what B requires. In ALA you get a port with a programming paradigm that will take any domain abstraction instance with a compatible port of the same programming paradigm.</p>
</div>
<div class="paragraph">
<p>Both DIP and ALA require dependency injection. So let’s draw the injection dependencies as well:</p>
</div>
<div class="paragraph">
<p>Conventional code version:</p>
</div>
<div class="paragraph">
<p>B ---&#8594; C</p>
</div>
<div class="paragraph">
<p>DIP version:</p>
</div>
<div class="paragraph">
<p>A --&#8594; B</p>
</div>
<div class="paragraph">
<p>A --&#8594; C</p>
</div>
<div class="paragraph">
<p>C &#8592;-- B</p>
</div>
<div class="paragraph">
<p>ALA version</p>
</div>
<div class="paragraph">
<p>A ---&#8594; B</p>
</div>
<div class="paragraph">
<p>A ---&#8594; C</p>
</div>
<div class="paragraph">
<p>B ---- &gt; I</p>
</div>
<div class="paragraph">
<p>C ---- &gt; I</p>
</div>
<div class="paragraph">
<p>DIP effectively moves the interface from C to B. B gains an interface that does a similar job to C. C then implements it and B uses it.</p>
</div>
<div class="paragraph">
<p>Because the new interface is owned by B, it may be different from the one in C because now it’s about what B requires rather than what C provides.</p>
</div>
<div class="paragraph">
<p>Because of this, it might often be an adapter that implements the interface, and then the adapter uses the original interface of C.</p>
</div>
<div class="paragraph">
<p>TBD</p>
</div>
<div class="paragraph">
<p>Think of B as being some business logic and C being the database. B no longer depends directly on a specific database. But the databases do now depend on B. To avoid changing the databases, you would use adapters. The pattern is designed to increase the reuse potential of B, the business logic, because different databases can be plugged into it. But it likely decreases the reuse potential of the things around the business logic unless adapters are used. The DIPs application is primarily around making business logic reusable, and leads to hexagonal architecture, which has the business logic in the middle, and all the peripherals are plugged into its interfaces.</p>
</div>
<div class="paragraph">
<p>Returning to the sentence in the DIP that states: “High-level modules should not import anything from low-level modules.”.</p>
</div>
<div class="paragraph">
<p>The 2nd  ALA dependency rule is in a way less constraining than the DIP here. If a low-level module is much more abstract, ALA allows to keep the dependency. This is what allows the dependencies between the application user stories and the domain abstractions. It comes down to what is meant by high-level and low-level in Martin’s writings. I think by ‘low-level’ he refers to what would have been depended on in conventional code. Things like the database, middleware for communications, and frameworks.(e.g. for supporting asynchronous events.)</p>
</div>
<div class="paragraph">
<p>In ALA, yes you would wire the specific database adapter and the specific middleware adapter (and the specific UI), but you wouldn’t wire in the framework. It doesn’t matter that the abstraction depended on is low level. I want to commit to only one implementation of the framework. It would be silly to have to use ports on every single domain abstraction so I can wire in a framework of my choice, and have to wire it to every single domain abstraction, when I want to commit to using one. This becomes more obvious as you get to even lower levels such as math libraries. I don’t need to allow for swapping out the math library implementation. So ALA allows dependencies on more abstract abstraction even if they are low-level modules. In fairness, Martin probably doesn’t mean to include all low-level modules in the DIP, just certain ones that should be decoupled.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="truedependency-injection-pattern"><a class="anchor" href="#truedependency-injection-pattern"></a>6.3. Dependency injection pattern</h3>
<div class="paragraph">
<p>By know we know that ALA uses dependency injection. It uses it for wiring up all instances or all domain abstractions.</p>
</div>
<div class="paragraph">
<p>We have favoured using reflection to do the injection in our examples, but that is just a syntactic shortcut that allows domain abstraction to have many ports without also having many setters. It also allowed us to keep the ports private from direct access by the application layer, so that a wiring operator was always used.</p>
</div>
<div class="paragraph">
<p>ALA uses explicit wiring.</p>
</div>
<div class="paragraph">
<p>This is one of the most important aspects of ALA. You do not want the knowledge that the wiring represents to disappear into the abstractions themselves. As many of the principles in this section will say, you do not want direct function calls or method calls on concrete classes just for communication.</p>
</div>
<div class="paragraph">
<p>ALA never uses dependency with automatic wiring. Having a dependency injection container means that the wiring itself is implicit in the interface types. If one module requires an interface, and the container has a module that implements it, that means these two modules get wired together. This type of implicit wiring is indirect and obfuscated and illegal in ALA.</p>
</div>
<div class="paragraph">
<p>In ALA, abstraction pairs don&#8217;t have their own interfaces for their instances to communicate. So we don&#8217;t have the situation where class A has a dependency on class B, and so an object of class B (or one of its subclasses) is injected into class A. Similarly, we wouldn&#8217;t have the situation where class A requires an interface that is implemented by class B.</p>
</div>
<div class="paragraph">
<p>In ALA the interfaces must be programming paradigm interfaces, which are a whole abstraction layer more abstract. So we need to be thinking that if class A accepts or implements a certain programming paradigm interface, there could be any number of other abstraction instances that could be attached. Furthermore, we could build arbitrarily large assemblies - composability. Or with some ports, we don&#8217;t have to wire an instance at all. So it doesn&#8217;t really make sense to call what we are injecting 'dependencies'. We just think of it as wiring things up. You wouldn&#8217;t describe what an electronics engineer does as dependency injecting components.</p>
</div>
<div class="paragraph">
<p>In ALA, the explicit wiring can&#8217;t be XML or JSON. Usually user stories contain a graph structure of relationships. So the wiring should be a diagram to best show that structure.</p>
</div>
<div class="paragraph">
<p>However, if the graph is mostly a tree structure (with a relatively few cross connections), then it may still make sense to avoid the weight of a diagramming tool, and represent the wiring in text form. But in this case I much prefer the readability of code written in a programming language than XML or JSON. The argument can be made for the declarative nature of say XAML and that UI designers could learn this declarative language more easily than a programming language. But I would maintain that a programming language can use declarative style. That&#8217;s what most of the wiring examples in this website are. And in ALA, UI and the rest of user story are considered cohesive. We express them inside one abstraction. If we want a UI designer on the team, great, just teach him the subset of domain abstractions that are used for the UI, how to configure them, and how to wire instances of them together. Languages like XAML are not particularly easy just because they are declarative.</p>
</div>
</div>
<div class="sect2">
<h3 id="truephysical-boundaries"><a class="anchor" href="#truephysical-boundaries"></a>6.4. Physical boundaries</h3>
<div class="paragraph">
<p>I was listening to a talk by Eric Evans where he said that Microservices works because it provides boundaries that are harder to cross. We have been trying to build logical boundaries for 60 years, he said, and failed. So now we use tools like Docker that force us to use say REST style interfaces in oder to have physical boundaries. I have also heard it suggested that using multiple MCUs in an embedded system is a good thing because it provides physical boundaries for our software components. And I think, really? Is that the only way we can be create a logical boundary? I can tell you that multiple MCUs for this reason is not a good idea if only because all those MCUs will need updating, and the mechanisms and infrastructure needed to do that make it not worth it. Unless there is a good reason, such as to make different parts of your code independently deployable, the extra infrastructure required for physical boundaries that are just logical boundaries is not necessary. Furthermore, physical boundaries, like modules do not necessarily make good abstractions. The only boundary that works at design-time is a good abstraction. So ALA achieves it&#8217;s design-time boundaries by using abstractions.</p>
</div>
</div>
<div class="sect2">
<h3 id="truetest-driven-development"><a class="anchor" href="#truetest-driven-development"></a>6.5. Test Driven Development</h3>
<div class="paragraph">
<p>It is said that TDD&#8217;s main advantage is not so much the testing, but the improvement in the design. In other words, making modules independently testable makes better abstractions. This is probably true, but in my experience, TDD doesn&#8217;t create good abstractions nearly as well as pursuing that goal directly. The architecture resulting from TDD is better but still not great.</p>
</div>
</div>
<div class="sect2">
<h3 id="trueobserver-pattern"><a class="anchor" href="#trueobserver-pattern"></a>6.6. Observer pattern</h3>
<div class="paragraph">
<p>TBD</p>
</div>
</div>
<div class="sect2">
<h3 id="truelayer-patterns"><a class="anchor" href="#truelayer-patterns"></a>6.7. Layer patterns</h3>
<div class="sect3">
<h4 id="truemvc"><a class="anchor" href="#truemvc"></a>6.7.1. MVC</h4>
<div class="paragraph">
<p>TBD</p>
</div>
</div>
<div class="sect3">
<h4 id="trueapplication-services-drivers-hardware"><a class="anchor" href="#trueapplication-services-drivers-hardware"></a>6.7.2. Application, Services, Drivers, Hardware</h4>
<div class="paragraph">
<p>TBD</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="truefactory-method-pattern"><a class="anchor" href="#truefactory-method-pattern"></a>6.8. Factory method pattern</h3>
<div class="paragraph">
<p>The Factory Method pattern in both the GOF book and in online examples has multiple variations. The only thing they seem to have in common is that the client doesn&#8217;t use "new ConcreteProduct()". It just wants an object that implements an interface, IProduct. For any reason it doesn&#8217;t want to be the one who will decides at design-time what that concrete product will be.</p>
</div>
<div class="paragraph">
<p>Here are some of the variations.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Several ConcreteCreators exists to encapsulate knowledge of how to use the ConcreteProduct constructor which has many parameters, in a consistent way to make a valid ConcreteProduct. The common example is different named pizzas or sandwiches.</p>
</li>
<li>
<p>The Client finds out at run-time what ConcreteProduct is needed (usually a string name). We want to move the switch statement out of the client and into a Creator class.)</p>
</li>
<li>
<p>The client knows when the objects are needed, but needs to be more stable. Which product is needed changes more often (although still known at design-time). So it goes into a class that changes.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In all cases we end up with two objects wired together through the IProduct interface. These two objects we will refer to as the Client and the ConcreteProduct (from the pattern terminology). To get them wired using the Factory Method pattern requires the use of a FactoryMethod. The FactoryMethod typically goes in an abstract class called ICreator, which may do the creating itself, or maybe overridden by one or more ConcreteCreators.</p>
</div>
<div class="paragraph">
<p>In the context of abstraction layers, ALA gives more insight into the FactoryMethods pattern. Remeber we expect lower layers to more stable. The IProduct and ICreator interfaces are in the ProgrammingParadigms layer (lowest layer). The Client and all the different ConcreteProducts are in the DomainAbstractions layer (middle layer). The ConcreteCreator is in the Application layer and wires one of the ConcreteProducts to the client. So now when we want to change the ConcreteProduct, only the ConcreteCreator in the application layer has to change.</p>
</div>
<div class="paragraph">
<p>But in ALA we typically accomplish that in a far simpler way. We commonly let the application code instantiate the right concrete class (that implements the interface, IProduct), and wire it to the Client object using the WireTo() method. This is nothing more than static wiring, but can only work when the required ConcreteProduct is known at design-time.</p>
</div>
<div class="sect3">
<h4 id="truecase-1"><a class="anchor" href="#truecase-1"></a>6.8.1. case 1</h4>
<div class="paragraph">
<p>Now to the case in ALA where we have a client that needs a concrete product creating later than design-time, that is at run-time. Such a client is the Multiple Abstraction. It&#8217;s job is to make many instances of a Domain Abstraction. But it is an abstraction so can be used to make instances of any object. They don&#8217;t even have to implement a specific interface such as IProduct, because Multiple doesn&#8217;t interact with these instances itself.</p>
</div>
</div>
<div class="sect3">
<h4 id="truecase-2"><a class="anchor" href="#truecase-2"></a>6.8.2. case 2</h4>
<div class="paragraph">
<p>Let&#8217;s say you have a Table domain abstraction that stores a table of data. In your application, you want to instantiate many Tables. Now lets suppose that we want these Table instances to persist their data. A database must be attached via an IPersistance interface. We don&#8217;t want the Table class to know about concrete Databases. We want the application layer at the top to do that. But we don&#8217;t want the application layer to have to wire the database to every instance that requires an IPersistance. We want the Application to be able to just use a Table as if it is a self-contained abstraction. We want the Table instances to take care of themselves for Persistence. So we make a Peristence abstraction in the Programming paradigms layer. The concept of Persistence is at the right abstraction level to go in this layer. The Table class can use this persistence abstraction through a FactoryMethod. A variable in the Persistence abstraction stores the IPeristence object. The application instantiates which database it wants to use and passes it to the Peristence abstraction.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="truedecorator-pattern"><a class="anchor" href="#truedecorator-pattern"></a>6.9. Decorator pattern</h3>
<div class="paragraph">
<p>TBD</p>
</div>
</div>
<div class="sect2">
<h3 id="truebridge-pattern"><a class="anchor" href="#truebridge-pattern"></a>6.10. Bridge pattern</h3>
<div class="paragraph">
<p>TBD</p>
</div>
</div>
<div class="sect2">
<h3 id="truearchitecture-styles"><a class="anchor" href="#truearchitecture-styles"></a>6.11. Architecture styles</h3>
<div class="paragraph">
<p>I am not an expert at these so called 'Architectural styles'. Any feedback about the accuracy of the following comparisons would be appreciated.</p>
</div>
<div class="sect3">
<h4 id="truecomponents-and-connectors-2"><a class="anchor" href="#truecomponents-and-connectors-2"></a>6.11.1. Components and connectors</h4>
<div class="paragraph">
<p>David Garlan and Mary Shaw in their paper titled "An Introduction to Software Architecture" 1994 use components and connectors as a framework for viewing architectural styles. Depending on the style, the connectors can be a procedure call, event broadcast, database query, or pipe (which we call dataflow).</p>
</div>
<div class="paragraph">
<p><strong>Similarities</strong></p>
</div>
<div class="paragraph">
<p>ALA follows this idea closely.</p>
</div>
<div class="paragraph">
<p><strong>Differences</strong></p>
</div>
<div class="paragraph">
<p>In ALA we call the styles programming paradigms, and it is emphasised that multiple programming paradigms can be used in the one user story. The reason not to call them 'styles' in ALA is that the word style tends to imply using a single style throughout the program.</p>
</div>
<div class="paragraph">
<p>In ALA 'components' becomes 'abstractions' and 'connectors' becomes 'ports and wirings'. This change in terminology is to emphasis that the wiring is distinct from the abstractions themselves. The term components and connectors can (albeit not necessarily)) refer to an effectively monolithic system that is just separated into pieces and the pieces connected back together in a fixed rigid arrangement. This is especially true if the design methodology is decomposition of the system into elements and their relations. Such a system is loosely coupled at best. In ALA you can&#8217;t do that. Systems must be composed of instances of abstractions wired together by a higher layer abstraction that directs the wiring. Abstractions are necessarily zero-coupled with one another. They use ports that have the types of a small number of programming paradigms so that instances of them can be composed in (generally) an infinite variety of ways. The style where components being filters and connectors being pipes works this way.</p>
</div>
<div class="paragraph">
<p>I suspect that most components and connector systems use interfaces that are specific to the components.</p>
</div>
<div class="paragraph">
<p>Examples using the UML component diagram, even though it uses the term ports, show interfaces that rigidly couple their components to one another, for example, interfaces with names such as CustomerLookup. This would mean that only components that are implementations of that specific interface could be substituted. Usually there appears to be only one, making the components effectively just modules. In UML, components appear to be just containers. They are the first level of decomposition of a system, and themselves just contain connected classes. This type of architecture is incompatible with ALA.</p>
</div>
</div>
<div class="sect3">
<h4 id="truecomponent-based-software-engineering"><a class="anchor" href="#truecomponent-based-software-engineering"></a>6.11.2. Component Based Software Engineering</h4>
<div class="paragraph">
<p>ALA uses many of the same methods found in component based engineering or the Components and Connector architectural style.</p>
</div>
<div class="sect4">
<h5 id="truesimilarities"><a class="anchor" href="#truesimilarities"></a>Similarities</h5>
<div class="ulist">
<ul>
<li>
<p>Components are Abstractions.</p>
</li>
<li>
<p>Reusable software artefacts.</p>
</li>
<li>
<p>Connection ports for I/O.</p>
</li>
<li>
<p>Composability</p>
</li>
<li>
<p>Both instantiate components, specialize them by configuration, and compose them together to make a specific system.</p>
</li>
<li>
<p>ALA&#8217;s 3rd layer has interfaces used to wire abstractions in the 2nd layer, so at a lower level (more abstract) level. They represent something more like programming paradigms. The equivalent pattern in components engineering is "Abstract Interactions".</p>
</li>
<li>
<p>The architecture itself is composed of a generic part and a specific part. The general part is the ALA reference architecture itself and the components or the connectors architectural style. The specific part is the wiring diagram of the full system.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="truedifferences"><a class="anchor" href="#truedifferences"></a>Differences</h5>
<div class="ulist">
<ul>
<li>
<p>Component based engineering technologies such as CORBA primarily solve for platform and language interoperability in distributed system whereas ALA brings some of the resulting concepts and properties to everyday small-scale, non distributed development as well, where the only separation is logical.</p>
</li>
<li>
<p>In ALA there is perhaps more particular emphasis on making components clearly more abstract than the systems they are used in, and making the interfaces clearly more abstract than the components. The components are pushed down a layer and the interfaces down to a layer below that. Then all dependencies must be strictly downwards in these layers. In component based engineering, this structure is not necessarily enforced. If the components are just a decomposition of the system, then the system, components and interfaces may all be at the same level of abstraction, making the system as a whole complex.</p>
</li>
<li>
<p>ALA depends on the 'abstractness property' of components to get logical separation, and so calls them 'Abstractions' and not components to help them retain that property. Even if there will only be one use and one instance, it is still called an abstraction. This keeps them zero coupled and not collaborating with other abstractions they will be wired to.</p>
</li>
<li>
<p>ALA layers are knowledge dependency layers.  Components may still be arranged in layers according to run-time dependencies, such as communication stacks. In ALA run-time dependencies are always implemented as explicit wiring inside another higher layer component.</p>
</li>
<li>
<p>ALA&#8217;s top layer must be a straight representation of the requirements, whereas components may tend to be decomposed pieces of the system.</p>
</li>
<li>
<p>ALA&#8217;s 2nd layer of components are designed for expressiveness of user stories or requirements, and provide DSL-like properties. ALA puts emphasis on the 2nd layer of components having the scope of a domain as the means of explicitly controlling the expressiveness of the pallet of components.</p>
</li>
<li>
<p>ALA is not fractal. In ALA the components of components are abstractions that become more abstract and thus ubiquitous and reusable. ALA therefore uses abstraction layers rather than hierarchies.</p>
</li>
<li>
<p>ALA forces decisions about which abstraction layers the software artefacts go into, and then controls knowledge (semantic) dependencies accordingly.</p>
</li>
<li>
<p>ALA tries to make the abstraction layers discrete and separated by a good margin.</p>
</li>
<li>
<p>ALA puts greater emphasis on wiring being able to represent any programming paradigm that suits the expression of requirements, and the use of many different paradigms in the same wiring diagram.</p>
</li>
<li>
<p>ALA emphasises the cohesion of functional parts of a system such as UI, logic and Data, by bringing them all together in one small diagram using domain level components</p>
</li>
<li>
<p>Instead of 'required' interfaces, in ALA they are called 'accepts' interfaces. This is because the abstractions are more abstract and composable, so, as with Lego blocks, there isn&#8217;t necessarily a connection to another instance.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="truepresentation-business-services-persistence-database"><a class="anchor" href="#truepresentation-business-services-persistence-database"></a>6.11.3. Presentation, Business, Services, Persistence, Database</h4>
<div class="paragraph">
<p>TBD</p>
</div>
</div>
<div class="sect3">
<h4 id="truepresentation-application-domain-infrastructure"><a class="anchor" href="#truepresentation-application-domain-infrastructure"></a>6.11.4. Presentation, Application, Domain, Infrastructure</h4>
<div class="paragraph">
<p>The middle two layers appear to be the same as ALA&#8217;s. The Presentation (UI) only has run-time dependencies on the Application, and the Domain layer only has run-time dependencies on the Infrastructure (Persistence etc), so these layers are not present in ALA.</p>
</div>
<div class="paragraph">
<p>Instead Presentation is done in the same way as the rest of the application, by composing and configuring abstractions in the domain. The meaning of composition for UI elements (typically layout and navigation-flow) is different from the meaning of composition in the use-cases (typically workflow or dataflow).</p>
</div>
<div class="paragraph">
<p>In ALA, the foundation layer is also done in the same way as the rest of the application, at least a little. Domain abstractions that represent say a persistent table are in the Domain layer. The composition and configuration of them again goes in the Application layer. This time the meaning of composition is, for example, columns for the tables and schema relations.</p>
</div>
<div class="paragraph">
<p>If the implementation of any domain abstraction is not small (as is the case with the persistent Table abstraction mentioned above, which will need to be connected to a real database), it will be using other abstract interfaces (in the Programming Paradigms layer) connected to its runtime support abstractions in a technical domain, the same as in Hexagonal Architecture.</p>
</div>
</div>
<div class="sect3">
<h4 id="trueobject-oriented-programming"><a class="anchor" href="#trueobject-oriented-programming"></a>6.11.5. Object Oriented Programming</h4>
<div class="paragraph">
<p>From my reading, it seems that the most characteristic feature of OOP is that when data and operations are cohesive, they are brought together in an object. Others may see it as enabling reuse, inheritance, and still others may see it as polymorphism. New graduates seem to be introduced to polymorphism in inheritance and not be introduced to interfaces at all, which is a shame because the concept of interfaces is much more important.</p>
</div>
<div class="paragraph">
<p>I have never been an expert at Object Oriented Design as I found the choice of classes difficult and the resulting designs only mediocre. But I think the most fundamental and important characterising feature of OOP is under-rated. That is the separation of the concepts of classes and objects. This separation is not so clearly marked when we use the terms modules or components. The separation is fundamentally important because it&#8217;s what allows us to remove all dependencies except knowledge dependencies. In the way described earlier in this article, you can represent the knowledge of most dependencies as a relationship between instances completely inside another abstraction. What OOP should have done is represent relationships between objects completely inside another class. The problem is that OOP doesn&#8217;t take advantage of this opportunity. Instead, it puts these relationships between objects inside those objects' classes, as associations or inheritance, thereby turning them into design-time dependencies, and destroying the abstract qualities of the classes. Abstractions, unlike classes, retain their zero coupling with one another.</p>
</div>
<div class="paragraph">
<p>ALA addresses the problem by calling classes abstractions and objects instances. Abstractions differ from classes by giving us a way to have logical zero coupling, as if they were on different physical platforms. Instances differ from objects by having ports because their classes give them no fixed relationships with other objects.</p>
</div>
<div class="paragraph">
<p>Of course, when you are writing ALA code, abstractions are implemented using classes, but you are not allowed associations or inheritance. Instances are implemented as objects but with ports for their connections. A port is a pair of interfaces that allow methods in both directions. The interfaces are defined in a lower layer.</p>
</div>
<div class="paragraph">
<p>In ALA, the UML class diagram completely loses relevance. Because classes have no relationships with each other, bar knowledge dependencies, a UML diagram in ALA would just be a lot of boxes in free space, like a pallet of things you can use. You could show them in their layers and you could even draw the downward composition relationships that represent the knowledge dependencies, but there would be no point to this except in explaining the concepts of ALA. When you are designing an actual system, the real diagram is the one inside of an abstraction, especially the uppermost one, the application. It shows boxes for instances of the abstractions it uses, with the name of the abstraction in the box, the configuration information for those instances, and of course the lines showing how they are wired together. The names inside the boxes would not even need to be underlined as in UML, because the boxes in such diagrams would always be instances.</p>
</div>
<div class="paragraph">
<p>Such a diagram is close to a UML object diagram. However, a UML object diagram is meant to be a snapshot of a dynamic system at one point in time. In ALA, any dynamic behaviour is captured in a static way by inventing a new abstraction to describe that dynamic behaviour. Thus the design-time view is always static. So the object diagram is static. The application class specifies a number of objects that must be instantiated, configured, and wired together to execute at run-time. Since the structure is always static, ideally this would be done by the compiler for best efficiency, but there is no such language yet. So, in the meantime, it is done at initialization time. The object diagram can be fairly elegantly turned into code using the fluent coding style shown in the XR5000 example.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="truedsls"><a class="anchor" href="#truedsls"></a>6.12. DSLs</h3>
<div class="paragraph">
<p>We briefly discussed ALA as a DSL in the structure chapter <a href="#DSL1">here</a></p>
</div>
<div class="paragraph">
<p>ALA includes the main idea of DSLs in that the fundamental method "represent[s] requirements by composition of domain abstractions". It shares the DSL property that you can implement a lot more requirements or user stories in a lot less code.</p>
</div>
<div class="paragraph">
<p>But ALA only tries to be a light-weight way of telling ordinary developers how to organise code written in your underlying language. Although the domain abstractions do form a language and the paradigm interfaces give it a grammar, ALA doesn&#8217;t pursue the idea of a language to the point of textural syntactic elegance. Instead, you end up with explicit wiring methods to combine domain entities, or plain old functional composition, or some other form of composition in the wider sense of the word. Often, the text form is only a result of hand translation of an executable diagram. ALA certainly doesn&#8217;t overlap with DSLs to the extent of an external DSL, nor does it try to sandbox you from the underlying language. It therefore does not require any parsing and doesn&#8217;t need a language workbench, things that may scare away 'plain old C' developers.</p>
</div>
<div class="paragraph">
<p>Like DSLs, ALA can be highly declarative depending on the paradigm interfaces being used to connect domain abstractions. It is better to have the properties of composition and composability in the your domain language even if they may not be in a perfectly elegant syntactic form. ALA may end up composing abstractions with calls to wireTo methods instead of spaces or dots. But often a diagram using lines is even better than spaces and dots.</p>
</div>
<div class="paragraph">
<p>In DSLs, it is important that different languages can be combined for different aspects of a problem. For example, a DSL that defines State machines (the state diagram) and a DSL for data organisation (Entity Relationship Diagram) may be needed in the same application. You don&#8217;t want to be stuck in one paradigm. ALA recognises this importance by having paradigm interfaces that are more abstract than the domain abstractions.</p>
</div>
<div class="paragraph">
<p>DSLs probably work by generating a lot of code from templates whereas ALA works by reusing code as instances of abstractions. Both of these methods are fine from the point of view of keeping application specific knowledge in its place, and domain knowledge in its place. Howver, the distinction between ALAs domain layer and programming paradigms layer is probably not so as clearly made in the implementation of the templates.</p>
</div>
<div class="paragraph">
<p>It is an advantage of DSLs that they can sandbox when needed. An example from the wiring pattern earlier is that the ports of instances do not need to be wired. Therefore, all abstractions need to check if there is something wired to a port before making a call on it. Enforcing this is a problem I have not yet addressed.</p>
</div>
<div class="paragraph">
<p>A possible solution, albeit inferior to a real DSL that would tell you at design-time, might be that when there are tools that generate wiring code from diagrams, they automatically put stubs on all unwired ports. These stubs either throw an exception at run-time, or just behave inertly.</p>
</div>
<div class="paragraph">
<p>ALA is different from external DSLs. ALA is just about helping programmers organise their code in a better way. It doesn&#8217;t try to make a syntactically elegant language, as a DSL does. Certainly an external DSL will end up representing requirements in a more elegant syntax. But that is not the most important thing in ALA. The most important thing is the separation of code that has knowledge of the requirements, which will cause the invention of abstractions that have zero coupling (because the coupling was really in each requirement - that is why a requirement is cohesive). ALA also avoids taking the average imperative language programmer out of their comfort zone. It does not require a language workbench and does not sandbox you from the underlying language.</p>
</div>
<div class="paragraph">
<p>ALA probably does fit into the broadest definition of an internal DSL. However, again, it does not target syntactic convenience in the expression of requirements so much as just separating the code that knows about those requirements from the code that implements them. An internal DSL usually aims to have a mini-language that is a subset of the host language, or it tries to extend the host language through clever meta-programming to look as if it has new features. ALA is about abstraction layering. It is about this design-time view of knowledge dependencies: what abstractions in lower layers are needed to understand a given piece of code.</p>
</div>
</div>
<div class="sect2">
<h3 id="truemulti-tier-architecture"><a class="anchor" href="#truemulti-tier-architecture"></a>6.13. Multi-tier Architecture</h3>
<div class="paragraph">
<p>TBD</p>
</div>
</div>
<div class="sect2">
<h3 id="trueclean-architecture"><a class="anchor" href="#trueclean-architecture"></a>6.14. Clean Architecture</h3>
<div class="paragraph">
<p>Clean architecture is initially viewed as concentric circles which are in effect layers. Entities are innermost, with business logic next, and the external system consisting of things like database, UI and communications on the outer. These layers are allowed to have dependencies going inwards.</p>
</div>
<div class="paragraph">
<p>In conventional code, dependencies tend to follow communications, and communications, when implemented in the form of direct function or method calls, flow from the initiator of the communications.</p>
</div>
<div class="paragraph">
<p>This gives rise, for example, to dependencies from the UI to the business logic, and then from the business logic to the database. In clean architecture, these are referred to as primary and secondary I/O with respect to the business logic. The idea in clean architecture is to invert the secondary dependencies so that all communications dependencies are now toward the business logic.</p>
</div>
<div class="paragraph">
<p>In this way the business logic at the core is reusable, and perhaps more importantly understandable without knowing details of a concrete database, middleware, or UI. It also facilitates easier testing of the business logic.</p>
</div>
<div class="paragraph">
<p>The business logic uses interfaces to communicate with the outside world. The primary communications have interfaces that the business logic <em>implements</em> (unchanged from conventional code). The secondary communications have interfaces which the business logic <em>requires</em>. The concrete implementations of database, etc are passed in or injected in. This wiring is specific to a unique application, so in ALA terms, it goes in the top layer.</p>
</div>
<div class="paragraph">
<p>From the point of view of the business logic only, this is compliant with ALA, except for the dependencies on entities, which is discussed below. The elements of the business logic, which in clean architecture are called use cases, can be considered abstractions that know about the business use cases and nothing else.</p>
</div>
<div class="sect3">
<h4 id="trueadapters"><a class="anchor" href="#trueadapters"></a>6.14.1. Adapters</h4>
<div class="paragraph">
<p>In the clean architecture, dependencies, such as those between business logic and database, are reversed (following the dependency inversion principle) from what it would have been in conventional code. These reversed dependencies do not comply with ALA. I think most implementations recognise these as bad dependencies, and solve it by removing the dependencies altogether using adapters. This is now a lot closer to ALA compliance.</p>
</div>
<div class="paragraph">
<p>Something must pass-in or inject the adapters into each of the business logic use cases. If this logic is thought of as being in a higher layer, then this is also ALA compliant.</p>
</div>
<div class="paragraph">
<p>In terms of ALA abstraction layers, the use cases, the database, the UI, and other IO are all about the same level of abstraction. They all know about different types of details. While the use cases know about the domain and it&#8217;s requirements, the database knows about how to efficiently store data. They are all abstractions that are zero coupled with one another. The adapters go in a layer above, and are specific to a use case / external IO pairing. The main() (or a function it delegates) goes in a layer above that and wires everything up using (usually) constructor dependency injection on the use cases.</p>
</div>
</div>
<div class="sect3">
<h4 id="trueentities"><a class="anchor" href="#trueentities"></a>6.14.2. Entities</h4>
<div class="paragraph">
<p>Clean architecture allows dependencies of use cases on entities. This is incompatible with ALA.</p>
</div>
<div class="paragraph">
<p>Entities typically hold all sorts of domain details, for example various informations about customers. When the requirements change, these will change. We expect requirements to change - that&#8217;s why we have agile.</p>
</div>
<div class="paragraph">
<p>Entities are an easy place to just add all fields to do with an identity. They will tend to hold some fields that, although they associate with an identify, really belong to separate use cases. These fields should be cohesive with their use cases. If entities hold information that is not significantly abstract with respect to use cases, such as the customer&#8217;s address, which is primarily used by one or two use cases only, then it is not ALA compliant. The customer identity abstraction&#8217;s responsibility should not be to know all data that can be associated with a customer, but to know about the idea of identity. It should not be used as the carrier of information between two use cases, which would expose all entity data to all use cases. Instead, use cases should all know about the abstraction, <em>customer identity</em>. A particular use case should only know about it&#8217;s own data, and only store it against a customer identity.</p>
</div>
<div class="paragraph">
<p>In other words, a user story should be able to have private data that is associated with an identity and still ultimately stored with all other data for that identity in the database. The only idea that is abstract enough to go in a layer below the use cases is the customer identity, which is likely to be reused by most new use cases. Subclassing, so that every use case has its own subclass may solve the problem in one way, but I expect would cause other problems.</p>
</div>
<div class="paragraph">
<p>Even if some customer detail needs to be shared with another use case, communicating this via a shared entity is bad. For example, consider a use case in a system that knows about the address that customers enter into the system. It could have an output port called 'address' that can be used to wire it to other use cases. This port will probably have a DTO type that belongs to it. The DTO cannot be shared with other features in the same layer without violating ALA constraints. A feature such as frieghtcost may need an address to calculate freight. Remember it is written separately from the address feature so is not coupled with it.  It cannot know about the address feature. It can&#8217;t know the DTO of the address. Nor does it need the entire address. So it may be written, for example, to have input ports for country and zip code. Yet another feature is shipping. It needs an address for a shipping label. It may have an input port that takes a string for of address, because it isn&#8217;t interested in the content of the address, only in faithfully printing it. So these three ports are incompatible. The wiring layer, which knows that it needs to wire these three together also knows how to adapt them, which can be done quite simply by passing in a lambda expression into the WireTo method (analogous to a Select clause in LINQ).</p>
</div>
<div class="paragraph">
<p>More generally in ALA, such applications are best viewed primarily in terms of dataflows rather than abstracted entities. Dataflows to/or from the database, for example. It flows to particular use cases, and only the data that is needed by the use case. At any point in the flow, the flow has a type. It is still nice to have a compiler generated, anonymous, fully type checked class at each point in the flow. But nowhere do we want to create an explicit class for sharing a whole entity, or even a part of an entity.</p>
</div>
<div class="paragraph">
<p>The identity of a customer itself is probably an abstract concept that can be used by all features. We therefore want a shared abstraction for the identity (just knowing about a unique internal or external number or key).</p>
</div>
<div class="paragraph">
<p>It should be possible to add a feature that needs a new private field (private to the feature). The data can still be associated with an identity and be stored in the database. Adding this field should cause a database migration, but not changes to other use cases.</p>
</div>
<div class="paragraph">
<p>So the way entities should be handled is quite different in ALA.</p>
</div>
<div class="paragraph">
<p>TBD do a simple 'task list' application on Github in both ALA and clean architecture to show how entities are handled in ALA. Then add a feature such as e-mail notification on due date to show how a new feature can have it&#8217;s own private data stored against the task identity (the e-mail sent status) and communicate via a port with an existing feature (the due date feature).</p>
</div>
</div>
<div class="sect3">
<h4 id="trueprimary-separation-2"><a class="anchor" href="#trueprimary-separation-2"></a>6.14.3. Primary separation</h4>
<div class="paragraph">
<p>There is a second major difference between clean architecture and ALA. In clean architecture, the UI and other externals IO such as the database are considered to be separated first. That is how it is shown on an architecture diagram, almost as if they are separate packages. You hear of being able to switch between a GUI or CLI based UI.</p>
</div>
<div class="paragraph">
<p>This view of primarily separating UI from business logic will likely lead to coupling. It is unlikely that the UI is so generic that it knows nothing about the business logic. It will need to specific to the data the business logic needs or produces. Similarly, the design of the UI will usually influence the way the business logic works. For example, the UI may be designed so that you enter all data first (like a form) and then submit, or it may be designed so that you select generally what you want to do, and then wizards guide the user through. The choice is likely to affect the way the business logic works.</p>
</div>
<div class="paragraph">
<p>In ALA, the primary separation is by features first. The UI and the business logic for a particular feature is considered to be cohesive with respect to that feature abstraction. The use case will wire up both the elements of the business logic and the elements of the UI (and those for the necessary database queries, etc). The UI elements used can still be swapped out for different ones, but that is an operation on the feature.</p>
</div>
<div class="paragraph">
<p>In the case that the UI design is not changing, but its implementation is, that involves swapping out the implementations of the UI domain abstractions. The abstraction themselves do not change, so the use cases wont change. But the new UI abstractions can shift to a different technology, shift from desktop to cloud, or the like.</p>
</div>
</div>
<div class="sect3">
<h4 id="truedtos"><a class="anchor" href="#truedtos"></a>6.14.4. DTOs</h4>
<div class="paragraph">
<p>DTOs have two different uses.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>part of an interface to group together related data that is sent through the interface at one time.</p>
</li>
<li>
<p>to collect data together to be transported together to cut down on the overhead of messaging.</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="trueinterface-dtos"><a class="anchor" href="#trueinterface-dtos"></a>interface DTOs</h5>
<div class="paragraph">
<p>In ALA, DTOs are not generally abstractions in themselves. Therefore, they may not be put in a lower layer and shared by two abstractions to communicate. That would couple the knowledge inside the two abstractions. If many abstractions want to know about the same DTO, this is likely to be the case as new abstractions are added, then maybe it is sufficiently abstract to be in a lower layer and shared.</p>
</div>
<div class="paragraph">
<p>Otherwise in ALA, you need to use adapters. This can be as simple as a lambda expression passed to the WireTo operator, in the same way that you would pass a lambda expression to a .Select clause in LINQ.</p>
</div>
<div class="paragraph">
<p>Although this is ALA compliant, in ALA we generally prefer not to use adapters. Instead we use interfaces that are a significantly more abstract that are not owned by the business logic core. These are of course at the abstraction level of programming paradigms. These types of interfaces are heavily reused, allow composability in the wiring, and help tremendously to keep all abstractions from being implicitly coupled.</p>
</div>
<div class="paragraph">
<p>If a DTO can be avoided by, for example, having two dataflow ports that use primitive types, this will increase the abstraction level, reusability and composability of your abstractions.</p>
</div>
</div>
<div class="sect4">
<h5 id="truetransport-dtos"><a class="anchor" href="#truetransport-dtos"></a>transport DTOs</h5>
<div class="paragraph">
<p>In ALA you wouldn&#8217;t use DTO for transport purposes. Instead, invent an abstraction say called multiplexer_demultiplexer for packing/unpacking (or serializing/deserializing) multiple input or output ports. Then instances of any two abstractions A and B, that would normally be compatible for wiring together, and which use asynchronous communications, can be physically deployed to opposite sides of the transport system. The wireTo operator, knowing they are in different physical locations, defers to a version that wire each of them to the respective multiplexer_demultiplexer instances.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="truestability-of-wiringadapterfeature-layers"><a class="anchor" href="#truestability-of-wiringadapterfeature-layers"></a>6.14.5. Stability of wiring/adapter/feature layers</h4>
<div class="paragraph">
<p>A system built from a wiring layer at the top, then an adapters layer below that, and then a layer below that for independent features, use cases, databases, UIs etc is ALA compliant. This is because the abstraction layers are more abstract as you go down. The top layer abstraction is a specific application. The second layer adapters are specific to pairs of things in the third. The third is the layer of fully reusable things. A database, even though we call it concrete, is a lot more reusable than a particular application, or a particular adapter.</p>
</div>
<div class="paragraph">
<p>An ALA application using these three types of layers is a little different from the layers we normally talk about, which uses domain abstractions that are wired directly together using compatible ports instead of via adapters in the layer above. To enable the ports to be compatible, there must be a layer below that provides abstract interfaces, which is what we call the programming paradigms. This latter arrangement has compositionality. For example, two domain abstractions currently wired together can have another domain abstraction, which is a decorator such as a filter, wired between them.</p>
</div>
<div class="paragraph">
<p>The two styles of layering can be used together.</p>
</div>
</div>
<div class="sect3">
<h4 id="trueswapping-out-technology"><a class="anchor" href="#trueswapping-out-technology"></a>6.14.6. Swapping out technology</h4>
<div class="paragraph">
<p>In clean architecture, part of the reason for avoiding dependencies from business logic to things like a particular database or framework is to allow swapping out the technology. The database in the third layer can be exchanged for a completely different type - the coninical example is changing it from a relational database to a simple file. The business logic does not change. Only new adapters are needed, one for each use case. The top layer wiring of course also needs to change to use the different adapters.</p>
</div>
<div class="paragraph">
<p>An ALA application that uses the preferred layering scheme of application layer, domain abstractions layer, programming paradigms layer can also have its technologies swapped out. Let&#8217;s again use the canonical example of swapping a relational database for a simple file. The domain abstraction that implements persistence using a database will have a port that implements a suitable programming paradigm. Usually this port has a type like ITableDataflow. You only need to substitute this domain abstraction with one that uses the same programming paradigm, but implements it as a simple file. Effectively these domain abstractions are wrappers, not adapters.</p>
</div>
<div class="paragraph">
<p>The wiring again needs to change in all the places that were instantiating the database implementation. This is probably the only practical way to do it, as the database implementation probably needs different application specific configuration than what a simple file implementation would.</p>
</div>
<div class="paragraph">
<p>Now let&#8217;s consider swapping out the UI. Let&#8217;s say we are changing the UI from a desktop windowed application to a browser, or from a PC window to a CLI (Command Line Interface).</p>
</div>
<div class="paragraph">
<p>In the original PC application, the wiring instantiates UI GUI domain abstractions. These domain abstractions are wrappers for, say, WPF UI elements. The wrappers have ports which the wiring uses to connect them to the corresponding parts of the business logic. These ports are, or course, abstract interfaces from the programming paradigms layer.</p>
</div>
<div class="paragraph">
<p>To swap out the UI involves changing the wiring to instantiate from a different set of these UI domain abstractions. They will have the same ports that are still wired to their relevant place in the business logic as before.</p>
</div>
<div class="paragraph">
<p>In the case of the browser, these new domain abstraction work by changing elements of the HTML that will be returned by an initiating HTTP request. Just as the windowed domain abstractions were wired to their containing window, browser domain abstractions will be wired to their containing page. The containing page will request their content when it is time to send the response to the HTTP request.</p>
</div>
<div class="paragraph">
<p>The case of the CLI is more interesting. Whenever there is a case of either a GUI or a CLI user interface in conventional architecture, the business logic is tied to the CLI commands, and the GUI then uses the CLI. But in ALA we have the option to do this without coupling the design of the business logic to the design of the CLI commands.</p>
</div>
<div class="paragraph">
<p>This is how it could work. Imagine we have previously built the application as a desktop windowed application, just as we did before. Now we change the wiring to use a set of CLI domain abstractions instead. Actually we need only two abstractions, one called command and one called response. Instances of the command abstraction are configured with the command that they handle. The command has an output event port which fires when the command is entered. If there are parameters, the abstraction can have other output ports for them, which are output before the event port fires. Alternatively you could chain up a series of parameter abstractions, each with a single output port. The response abstraction has an input port, and just prints any input data it receive. Optionally it could have a configuration name so it can identity itself when it prints.</p>
</div>
<div class="paragraph">
<p>Just as there are containing domain abstractions that describe layout for the GUI types of UI domain abstractions, CLI domain abstractions would also connect to a common domain abstraction that receives commands in a general form and passes them to the handler that is configured for that command. It would also collate the responses, add newlines to the output, etc.</p>
</div>
<div class="paragraph">
<p>There is one other possibility. In the above cases of swapping out the UI, we changed the names of UI domain abstraction instantiated by the wiring. That was potentially all we needed to change.</p>
</div>
<div class="paragraph">
<p>It is possible that the configuration of the domain abstractions did not need to change. For example, CLI command abstractions need to be configured with the actual command string they will respond to, whereas their GUI equivalents, which are buttons, need to be configured with a button name. These could potentially be the same. If other configuration information of UI domain abstractions, such as style, is implemented in a generic way such as having a style port wired using WireMany, then it is possible that the wiring only needs to specify the UI domain abstraction names.</p>
</div>
<div class="paragraph">
<p>In this case we could name all equivalent UI domain abstraction with the same name. Then by which set of classes we include in the project, it will be built for different technologies. I&#8217;m not really proposing it be done this way, just exploring the idea.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="trueonion-architecture"><a class="anchor" href="#trueonion-architecture"></a>6.15. Onion Architecture</h3>
<div class="paragraph">
<p>TBD</p>
</div>
</div>
<div class="sect2">
<h3 id="truehexagonal-architecture-ports-and-adapters"><a class="anchor" href="#truehexagonal-architecture-ports-and-adapters"></a>6.16. Hexagonal Architecture (Ports and Adapters)</h3>
<div class="paragraph">
<p>ALA includes the basic idea of hexagonal architecture, but with modification using the Bridge Pattern to keep cohesive knowledge belonging to the application from being split.</p>
</div>
<div class="paragraph">
<p>In a previous section we intimated that the sideways chains of interfaces going out in horizontal directions were the same as hexagonal architecture. While ALA shares this aspect of hexagonal architecture, there is still an important difference.</p>
</div>
<div class="paragraph">
<p>ALA retains domain abstractions of the UI, Database, communication and so on. For instance, in our XR5000 example, we had a domain abstraction for a persistent Table. We had domain abstractions for UI elements such as Page, Softkey etc. We don&#8217;t just have a port to the persistence adapter, we have an abstraction of persistence. We don&#8217;t just have a port for the UI to bind to, we have abstractions of the UI elements. The implementation of these abstractions will then use ports to connect to these external system components. Why is it important that we have domain abstractions of these external components?</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The Database and the UI will have a lot of application specific knowledge given them as configuration. Remember the creativity cycle. After instantiation of an abstraction comes configuration. The database will need a schema, and the knowledge for that schema is in the application. The Softkey UI elements will need labels, and that knowledge is in the application. By making domain abstractions for persistence and UI, the application can configure them like any other domain abstraction as it instantiates and wires up the application. To the application, these particular domain abstractions look like wrappers of the actual database and UI implementations, but they are more like proxies in that they just pass on the work.</p>
<div class="paragraph">
<p>The Persistence abstraction then passes this configuration information, via the port interface to the actual database. The Softkey abstraction then passes its label, via the port interface, to the softkeys. Otherwise the Application would have to know about actual databases and actual softkeys.</p>
</div>
<div class="paragraph">
<p>If you need a design where the UI can change, you just make the UI domain abstractions more abstract. A softkey may be a command abstraction. It is still configured with a label. But it may be connected to a softkey, a menu item, a CLI command, a web page button, or a Web API command.</p>
</div>
</li>
<li>
<p>From the point of view of a DSL, it makes sense to have concepts of UI and persistence and communications in the DSL language. The application is cohesive knowledge of requirements. The UI and the need for persistence are part of the requirements. In fact, for product owners communicating requirements, the UI tends to be their view of requirements. They talk about them in terms of the UI. Many of the product owners I have worked with actually design the UI as part of the requirements (with the backing of their managers, who are easily convinced that software engineers can&#8217;t design UIs. PO can&#8217;t either, but that is another story.). The point here is that the UI layout, navigation, and connection to business logic is all highly cohesive. We explicitly do not want to separate that knowledge.</p>
<div class="paragraph">
<p>As a restatement of an earlier tenet of ALA, it is much better to compose the application with abstractions of Business logic, UI and persistence than to decompose the application into UI, persistence and business logic.</p>
</div>
</li>
<li>
<p>We want the application to have the property of composability. We have previously discussed how that means using programming paradigm interfaces for wiring up domain abstractions. By using domain abstractions to represent external components, the abstractions can implement the paradigm interfaces and then be composable with other domain abstractions. For example, the Table domain abstraction which represents persistence may need to be connected directly to a grid, or to other domain abstractions that map or reduce it. Indeed, the Table abstraction itself can be instantiated multiple times for different tables and be composed to form a schema using a schema programming paradigm interface. I have even had a table instance&#8217;s configuration interface wired to a another Table instance. (So its columns can be configured by the user of the application.)</p>
</li>
<li>
<p>The fourth reason why it is important for the application to not directly have ports for external components of the system is that we don&#8217;t want the logical view of the architecture to become just one part of the physical view. If there is a communications port that goes to a different physical machine where there is more application logic, the application&#8217;s logical view should not know about that. It may be presented as an annotation on the application (lines) connecting certain instances, but it shouldn&#8217;t split the application up. At the application level, the collaboration between parts instantiated on different machines is still cohesive knowledge and belongs inside one place - the application.</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="truedomain-driven-design"><a class="anchor" href="#truedomain-driven-design"></a>6.17. Domain Driven Design</h3>
<div class="paragraph">
<p>Domain Driven Design&#8217;s "Bounded Contexts" and ALA&#8217;s Domain Abstractions layer have the same goal, that of encapsulation of the domain specific knowledge.</p>
</div>
<div class="paragraph">
<p>Domain driven design appears to concentrate on common languages to allow  pairs of elements to communicate, which ALA explicitly avoids. ALA tries to abstract the languages so that they are more abstract and fundamental than the domain, and more like programming paradigms.</p>
</div>
</div>
<div class="sect2">
<h3 id="truemicroservices"><a class="anchor" href="#truemicroservices"></a>6.18. Microservices</h3>
<div class="paragraph">
<p>TBD</p>
</div>
</div>
<div class="sect2">
<h3 id="truearchitecture-evaluation-methods"><a class="anchor" href="#truearchitecture-evaluation-methods"></a>6.19. Architecture evaluation methods</h3>
<div class="paragraph">
<p>Methods such as ATAM tell us how to evaluate an architecture for quality attributes such as maintainability, for instance by giving it modification scenarios to test how difficult the modifications would be to implement. There are several scenarios based methods to do this such as ATAM. Using this we could, theoretically, iteratively search over the entire architecture design space to find a satisfactory solution. It&#8217;s a bit analogous to numerically solving for the maxima of a complex algebraic formula. In contrast, ALA is analogous to an 'algebraic solution'. If the desired quality attributes, and all the software engineering topics listed above are the equations, ALA is the algebraic solution. It simplifies them down into a parameterised template architecture, ready for you to go ahead and express your requirements.</p>
</div>
<div class="paragraph">
<p><a id="Monads"></a></p>
</div>
</div>
<div class="sect2">
<h3 id="truemonads"><a class="anchor" href="#truemonads"></a>6.20. Monads</h3>
<div class="paragraph">
<p>We have talked about monads a few times because they are an important example of composition of instances of abstractions. Also, like ALA, they can use the concept of separating (in time) composition from execution. You can bind functions to monads making new monads, and it builds a structure that you can then execute. ALA is like a generalisation of monads. In the same way, you can wire instances of domain abstractions together, and it builds a structure that you can later execute.</p>
</div>
<div class="paragraph">
<p>When you execute a monad structure (generally by calling a function on the last monad you binded), it (usually) terminates. It is only executes again if it is wired up again. An exception is when using hot observables, such as an IO monad. The monad structure stays in existence, and it executes whenever there is input or output. ALA is more similar to this second case. When you start execution of a wired ALA structure, it usually starts running continuously.</p>
</div>
<div class="paragraph">
<p>Monads are restricted to generic types that have a single type of value. Each monad binding is restricted to stay in this generic type, and only the type of the internal data can change. The functions that are binded must take one parameter and have one return value. Dataflows in one direction.</p>
</div>
<div class="paragraph">
<p>ALA wiring is more arbitrary in its meaning. It can be anything depending on the relationships that need to be expressed in the requirements. A single wired connection can carry data as needed in both directions, or the composition may be about something completely different from dataflow.</p>
</div>
<div class="paragraph">
<p>Often when monads are used, the execution is done immediately following the binding. So the deferred nature of the execution is not always obvious.  I found that the separation between composition and execution of monads to be an important aspect to understand when comparing with ALA composition. In ALA all composition takes place at a clear wiring phase time. Then comes run-time.</p>
</div>
<div class="paragraph">
<p>For queries with monads you run code to compose (bind) IObservable or Task monads etc each time for a query. In ALA you would tend to compose (wire up) data streams once at the start and then initate them to re-run when needed with a wired event.</p>
</div>
<div class="paragraph">
<p>Another difference is syntax. Monads are composed using a dot operator, a method call, and configured with lambda function passed to the method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">source.Filter(x=&gt;x&gt;=0).Select(x=&gt;sqrt(x))</code></pre>
</div>
</div>
<div class="paragraph">
<p>This code filters out values from the source that are negative and then calculates the squareroots. In ALA, because composition is generalised, the syntax would look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">source.WireIn(new Filter(x=&gt;x&gt;=0)).WireIn(new Select(x=&gt;sqrt(x))</code></pre>
</div>
</div>
<div class="paragraph">
<p>But usually this code is generated from a diagram.</p>
</div>
<div class="paragraph">
<p>In functional programming, the code that composes monads is pure functional code without side effects. The functions that are binded are pure functions. When the composed structure 'executes', that may not be pure functional code. It may change states, perform I/O or write to a database. But all that code is inside the well tested monads. Al the code you wrote to compose those monads was purely functional.</p>
</div>
<div class="paragraph">
<p>ALA makes use of this same property of reusable abstractions. Domain abstraction may not internally be purely functional. Being object oriented they are almost certainly not. But they can be tested to ensure they are correct. The code that uses them to build specific applications can be pure functional.</p>
</div>
<div class="sect3">
<h4 id="truemonad-syntax"><a class="anchor" href="#truemonad-syntax"></a>6.20.1. Monad syntax</h4>
<div class="paragraph">
<p>Sometimes in ALA, we will wire together domain abstractions that operate on dataflows. Domain abstractions that perform the same function as Select, Where, and OrderBy are possible. This is in the same problem space that monads also solve. So it is worth comparing the two systems. I am not an expert on monads, but here is my current understanding of how ALA wiring and monad binding compare with one another.</p>
</div>
<div class="paragraph">
<p>When we want to bind a function to a monad such as Nullable&lt;T&gt;, it&#8217;s contained value can be immediately unwrapped, operated on, and then wrapped in a new monad Nullable&lt;R&gt;. But when we want to bind a function to a monad such as IEnumerable&lt;T&gt;, we may not want to pull all the values out immediately. Instead we just want a new IEnumerable&lt;R&gt; that when enumerated wil get values from the first IEnumerable&lt;T&gt; and perform the function on them. Similarly, when we want to bind a function to a monad such as Task&lt;T&gt;, we can&#8217;t immediately get its content because the value wont be there until some time in the future. Instead we want a new Task&lt;R&gt; that waits for the first task and then applies the function. In the second two examples, the binding to a monad is like wiring in ALA. Successive binding creates a connected chain of objects that collectively know how to do the workflow. Same in ALA, the wiring code creates a connected chain of objects which know how to process data through them later.</p>
</div>
<div class="paragraph">
<p>We can try to compare the monad pattern&#8217;s <em>bind</em> with ALA&#8217;s <em>WireIn</em>.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s assume for the ALA case, that the instanceB being wired converts objects from one type to another, the same as a function binded to monad does. So in both cases, we have a source of TAs and we want wire in a function that will convert them to TBs.</p>
</div>
<div class="paragraph">
<p>Both bind and WireIn have an object as their first argument. That object is the source for TAs. Both bind and WireIn can be written using the dot operator style:</p>
</div>
<div class="listingblock">
<div class="title">Monad wiring code</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">objectA.bind(...)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">ALA wiring code</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">instanceA.WireIn(...)</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>bind</em> and <em>WireIn</em> are different in their second argument. <em>bind</em> requires a function and WireIn requires an object. The function takes a TA and returns an MTB (a TB wrapped in a monad container). The object has an input port of type TA and an output port of type TB.</p>
</div>
<div class="listingblock">
<div class="title">Monad wiring code</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">monadA.bind((a)=&gt;(func&lt;TA,Monad&lt;TB&gt;&gt;)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">ALA wiring code</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">instanceA.WireIn(instanceB)</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the monad case, the bind function returns a new monad object.
In the ALA case, the WireIn function returns instanceB.
Therefore, in both cases you can now chain additional operators using fluent style:</p>
</div>
<div class="listingblock">
<div class="title">Monad wiring code</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">monadA.bind(func&lt;TA,Monad&lt;TB&gt;&gt;).bind(...)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">ALA wiring code</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">instanceA.WireIn(instanceB).WireIn(...)</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the monad version, we often want to specify the function to return a TB instead of a Monad containing a TB. That is what Select is for in C#. Select uses bind under the covers but does the wrapping of the TB into a monad for you:</p>
</div>
<div class="listingblock">
<div class="title">Monad wiring code</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">monadA.Select(func&lt;TA,TB&gt;)</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the ALA case, we will usually use a prexisting domain abstraction to perform the operation. For example, we might use the domain abstraction OffsetAndScale. This allows code to be generally be inside domain abstractions layer, and only configuration constants (that come directly from requirements) to be in the application layer. But to get closer to the same problem that monads solve, let&#8217;s assume we have no domain abstraction that does what we need, and we really do want to specify the mapping function in the application layer right in amongst the wiring. In other words we want a domain abstraction that is configured with a lambda function. In this case we can invent a domain abstraction called Lambda which takes a lambda function when it is constructed:</p>
</div>
<div class="listingblock">
<div class="title">ALA wiring code</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">instanceA.WireIn(new Lambda&lt;TA,TB&gt;(funct&lt;TA,TB&gt;))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Just as <em>Select</em> is a more specialized version of bind that changes the type, <em>Where</em> is also a more specialized version that removes records from the stream. It requires a predicate function that returns a bool:</p>
</div>
<div class="listingblock">
<div class="title">Monad wiring code</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">monadA.Where(funct&lt;TA,bool&gt;)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">ALA wiring code</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">instanceA.WireIn(new Where&lt;TA&gt;(funct&lt;TA,bool&gt;))</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can see that the ALA syntax for solving this particular problems is now more verbose. It requires the additional use of WireIn and the <em>new</em> keyword. The tradeoff for the extra words is versatility. We could consider using the less verbose Monad syntax for all ALA wiring. What would we lose if we did that:</p>
</div>
<div class="paragraph">
<p>For example:</p>
</div>
<div class="listingblock">
<div class="title">ALA wiring code</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">    adc.WireIn(new LowPassFilter(10)).WireIn(new OffsetAndScale(0,0.5));</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">consider monad style ALA wiring code</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">    adc.LowPassFilter(10).OffsetAndScale(0,0.5);</code></pre>
</div>
</div>
<div class="paragraph">
<p>To accomplish this syntax, we would have to provide methods with the same names as the domain abstractions. These methods would perform the new operation and then the wiring operation.</p>
</div>
<div class="paragraph">
<p>We would briefly consider defining these methods directly on the domain abstractions such as ADC, but that would pollute ADC with knowledge of LowPassFilter. Since there are many ways of wiring things, every abstraction would need methods for every other abstraction to which it could be wired. That would be ridiculous.</p>
</div>
<div class="paragraph">
<p>Instead we might make every domain abstraction implement an <em>IWireable</em> interface. I think this inerface would be empty. Then all the wiring methods would be extension methods on <em>IWireable</em>. They would all return an <em>IWireable</em> ready for fluently calling the next wiring method. Now the code for ALA would look like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">    (adc as IWireable).LowPassFilter(10).OffsetAndScale(0,0.5);</code></pre>
</div>
</div>
<div class="paragraph">
<p>which is pretty much the same as the Monad code.</p>
</div>
<div class="paragraph">
<p>The methods would be fairly simple:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">static class LowPassFilterExtensonMethod
{
    static IWireable LowPassFilter(this IWireable instanceA, int strength)
    {
        return instanceA.WireIn(new LowPassFilter(strength));
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that IWireable is kind of analogous to IEnumerable in the monad examples we have been looking at. We give it the more abstract name <em>IWireable</em> because domain abstractions can have more than one output port, and we could be wiring any one of them, whereas monads generally only have one output such as IEnumerable.</p>
</div>
<div class="paragraph">
<p>In ALA we use the explicit WireIn and new operators for the following reasons.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>In ALA, domain abstractions are written much more frequently than new monads are written. They are extremely simple to write. The only difference from plain classes is that you have to know that input ports must use implemented interfaces from the programming paradigms layer, and output ports must be plain private fields of the types of these same interfaces in the programming paradigms layer. We don&#8217;t really want the extra burden of adding a corresponding extension method in a separate static class, and adding the IWireable interface.</p>
</li>
<li>
<p>In ALA we can choose between WireIn and WireTo depending on whether we want to chain instances of abstractions or do fanout wiring.</p>
</li>
<li>
<p>Monads tend to be used only for <em>amplified types</em> and for composing functions that use them that have one parameter and one return value. You are composing functions. In ALA you are composing instances of abstractions, which is more general. Also composing monad functions is primarily using a dataflow programming paradigm. In ALA different programming paradigms can be used for what it means when composing instances of abstractions, so again it is more general. Also in ALA, you can mix different programming paradigms in the same solution, so that requirements can be fully expressed.</p>
</li>
<li>
<p>Monad functions look like operations on data, but hide the fact they really just instantiate objects and wire them together for the operation to occur later. Although confusing at first, it is readable once you are used to it. But imagine if it were used for all programming paradigms. Take for example the UI layout programming paradigm. The code below puts a TextBox and Grid inside a window.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">ALA wiring code</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">    window.WireTo(new TextBox())
          .WireTo(new Grid());</code></pre>
</div>
</div>
<div class="paragraph">
<p>The equivalent monad style code would be confusing:</p>
</div>
<div class="listingblock">
<div class="title">Monad style wiring code</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">    window.TextBox();
    window.Grid();</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>ALA wiring handles arbitrarily complex objects with multiple input and output ports. Using explicit WireTo and WireIn operators directly reflects this mental model. Monads are at first quite difficult to understand because of what happens under the covers. For most people it is quite a learning curve. By using explicit <em>WireTo</em> and <em>new</em>, ALA code is fairly obvious.</p>
</li>
<li>
<p>Domain abstractions can have multiple ports. WireIn allows us to specify which ports we want to wire when it could be ambiguous.</p>
</li>
<li>
<p>Inherent in the requirements of a typical application is really a network of relationships, which we can often represent with a diagram. Explicit WireIn and WireTo operators allow us to more easily see the one-to-one correspondence between the diagram and the code. Also, it is very easy for a diagramming tool to automatically generate wiring code containing .WireTo and new.</p>
</li>
<li>
<p>Monads based on IEnumerable or IObservable can handle a finite sequence. The IEnumerator interface tells you when it is finished. ALA dataflow interfaces may or may not be written to handle a finite sequences. If they do handle finite sequences, such as for a database query, they are not unwired and rewired every time they are used, They stay permanently wired up, and are reset for each query.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="trueunderstanding-monads"><a class="anchor" href="#trueunderstanding-monads"></a>6.20.2. Understanding monads</h4>
<div class="paragraph">
<p>Monads are notoriously hard to learn, but they are nice simple insight once you get there. Monads actually seem to have this property that you cannot understand any explanation of them until you first understand them. Thus it is a bootstrapping problem. Here is my experience of going through that bootstrapping process in case it is useful. I am not going to try to explain monads myself, because, even it was possible, others would do that far better than I would.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>First understand that Monads are like physics. Physicists explain that you never really understand physics, you just get used it. Unless you are a mathematician or otherwise gifted, the same is true for monads.</p>
</li>
<li>
<p>The way to get used to new concepts is to read multiple web-sites on the topic. Read each one until you get lost then swap to another one. Keep going like this. For average concepts like design patterns I use this technique and it requires maybe five websites. For monads it took me maybe ten. You will need to return to some of them iteratively to get further each time.</p>
</li>
<li>
<p>If you don&#8217;t know Haskell, prefer the web sites that explain them in the language you already know.</p>
</li>
<li>
<p>The common essential ideas in those websites will start to embed themselves in your brain.</p>
</li>
<li>
<p>Eventually, and fairly suddenly, the simple insight that is monads will happen.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>I thought few of the web-sites that I used adequately emphasised the monad property of separation (in time) of composition and execution. They did use examples of it such as IEnumerable and Task. They represent what they can do in the future, without actually doing it now. That&#8217;s why the binding functions are called bind in the functional world, because it doesn&#8217;t (necessarily) do anything except build a structure that can later be executed to actually do the work.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="truereactive-extensions"><a class="anchor" href="#truereactive-extensions"></a>6.21. Reactive Extensions</h3>
<div class="paragraph">
<p>In ALA, when you wire together</p>
</div>
</div>
<div class="sect2">
<h3 id="truewpf-xaml"><a class="anchor" href="#truewpf-xaml"></a>6.22. WPF &amp; XAML</h3>
<div class="paragraph">
<p>TBD</p>
</div>
</div>
<div class="sect2">
<h3 id="truefunctional-programming"><a class="anchor" href="#truefunctional-programming"></a>6.23. Functional programming</h3>
<div class="paragraph">
<p>TBD</p>
</div>
</div>
<div class="sect2">
<h3 id="truefunctional-programming-with-monads"><a class="anchor" href="#truefunctional-programming-with-monads"></a>6.24. Functional programming with monads</h3>
<div class="paragraph">
<p>TBD</p>
</div>
</div>
<div class="sect2">
<h3 id="truefunctional-reactive-programming"><a class="anchor" href="#truefunctional-reactive-programming"></a>6.25. Functional Reactive Programming</h3>
<div class="paragraph">
<p>TBD</p>
</div>
</div>
<div class="sect2">
<h3 id="trueexample-project-game-scoreboard"><a class="anchor" href="#trueexample-project-game-scoreboard"></a>6.26. Example project - Game scoreboard</h3>
<div class="paragraph">
<p>For the example project for this chapter, we return to the ten-pin bowling and tennis scoring engines that we used in Chapter two, and add a scoreboard feature (well a simple ASCII scoreboard in a console application rather than real hardware).</p>
</div>
<div class="paragraph">
<p>As the requirement, say we want a console application that displays ASCII scoreboards that look like these examples:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Ten-pin

 -----+-----+-----+-----+-----+-----+-----+-----+-----+--------
|   1 |   2 |   3 |   4 |   5 |   6 |   7 |   8 |   9 |    10  |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
| 1| 4| 4| 5| 6| /| 5| /|  | X| -| 1| 7| /| 6| /|  | X| 2| /| 6|
+  +--+  +--+  +--+  +--+  +--+  +--+  +--+  +--+  +--+  +--+--+
|   5 |  14 |  29 |  49 |  60 |  61 |  77 |  97 | 117 |   133  |
 -----+-----+-----+-----+-----+-----+-----+-----+-----+--------</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>Tennis

 -----++----+----+----+----+----++--------
|   1 ||  4 |  6 |  5 |    |    ||    30  |
|   2 ||  6 |  4 |  7 |    |    ||  love  |
 -----++----+----+----+----+----++--------</pre>
</div>
</div>
<div class="paragraph">
<p>As usual in ALA, our methodology begins with expressing those requirements directly, and inventing abstractions to do so. So, we invent a 'Scorecard' abstraction. It will take a configuration which is an ASCII template. Here are the ascii templates that would be used for ten-pin and tennis:</p>
</div>
<div class="literalblock">
<div class="content">
<pre> -------+-------+-------+-------+-------+-------+-------+-------+-------+-----------
|   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |     10    |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
|F00|F01|F10|F11|F20|F21|F30|F31|F40|F41|F50|F51|F60|F61|F70|F71|F80|F81|F90|F91|F92|
+   +---+   +---+   +---+   +---+   +---+   +---+   +---+   +---+   +---+   +---+---+
|  T0-  |  T1-  |  T2-  |  T3-  |  T4-  |  T5-  |  T6-  |  T7-  |  T8-  |    T9-    |
 -------+-------+-------+-------+-------+-------+-------+-------+-------+-------------</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre> -----++----+----+----+----+----++--------
| M0  ||S00 |S10 |S20 |S30 |S40 || G0---  |
| M1  ||S01 |S11 |S21 |S31 |S41 || G1---  |
 -----++----+----+----+----+----++--------</pre>
</div>
</div>
<div class="paragraph">
<p>The scorecard ASCII template has letter place-holders for the scores. (A single letter is used so it doesn&#8217;t take up much space on the template design.) Different letters are used for different types of scores. Digits are used to specify where multiple scores of the same type are arranged on the scoreboard. They are like indexes. Either 1-dimensional or 2-dimensional indexes can be used in the scoreboard template. For example, the frame scores in ten-pin bowling have scores for each ball for each frame, F00, F01 etc, as shown in the example above.</p>
</div>
<div class="paragraph">
<p>The scorecard abstraction needs functions it can use to get the actual scores. The functions are configured into little 'binding' objects that we then wire to the scoreboard. The binding objects are configured with the letter that they return the score for.</p>
</div>
<div class="sect3">
<h4 id="trueten-pin"><a class="anchor" href="#trueten-pin"></a>6.26.1. Ten-pin</h4>
<div class="paragraph">
<p>Having invented the Scorecard and Binding abstractions, we can now do the ten-pin application diagram:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/diagram-bowling-3.png" alt="diagram bowling 3">
</div>
</div>
<div class="paragraph">
<p>An abstraction we didn&#8217;t mention yet is the ConsoleGameRunner. Its job is to prompt for a score from each play, display the ASCII scoreboard, and repeat until the game completes.</p>
</div>
<div class="paragraph">
<p>The 'game' instance of the Frame abstraction on the right of the diagrams is the scoring engine we developed in Chapter Two. Together with this engine, we now have a complete application.</p>
</div>
<div class="paragraph">
<p>The rounded boxes in the diagram are instances of domain abstractions as usual for ALA diagrams. The sharp corner boxes are instances of Application layer abstractions. They are the mentioned functions for the Bindings. That code is application specific so goes in the application layer. They just do a simple query on the scoring engine.</p>
</div>
<div class="paragraph">
<p>Now tranlate the diagram into code. Here is the entire application layer code for ten-pin:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>consolerunner = new ConsoleGameRunner("Enter number pins:", (pins, engine) =&gt; engine.Ball(0, pins))
.WireTo(game)
.WireTo(new Scorecard(
"-------------------------------------------------------------------------------------\n" +
"|F00|F01|F10|F11|F20|F21|F30|F31|F40|F41|F50|F51|F60|F61|F70|F71|F80|F81|F90|F91|F92|\n" +
"|    ---+    ---+    ---+    ---+    ---+    ---+    ---+    ---+    ---+    ---+----\n" +
"|  T0-  |  T1-  |  T2-  |  T3-  |  T4-  |  T5-  |  T6-  |  T7-  |  T8-  |    T9-    |\n" +
"-------------------------------------------------------------------------------------\n")
.WireTo(new ScoreBinding&lt;List&lt;List&lt;string&gt;&gt;&gt;("F",
    () =&gt; TranslateFrameScores(
        game.GetSubFrames().Select(f =&gt; f.GetSubFrames().Select(b =&gt; b.GetScore()[0]).ToList()).ToList())))
.WireTo(new ScoreBinding&lt;List&lt;int&gt;&gt;("T",
    () =&gt; game.GetSubFrames().Select(sf =&gt; sf.GetScore()[0]).Accumulate().ToList()))
);</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre></pre>
</div>
</div>
<div class="paragraph">
<p>If you compare this code with the diagram, you will see a pretty direct correspondence.
Remember 'game' is the reference to the scoring engine project in the previous chapter.</p>
</div>
<div class="paragraph">
<p>That&#8217;s pretty much all the code in the application. Oh there is the 'translate' function, but it is pretty straight forward once you know the way a ten-pin scorecard works. For completeness here it is.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/// &lt;summary&gt;
/// Translate a ten-pin frame score such as 0,10 to X, / and - e.g. "-","X".
/// &lt;/summary&gt;
/// &lt;example&gt;
/// 7,2 -&gt; "7","2"
/// 7,0 -&gt; "7","-"
/// -,3 -&gt; "-","7"
/// 7,3 -&gt; "7","/"
/// 10,0 -&gt; "",X
/// 0,10 -&gt; "-","/"
/// additional ninth frame translations:
/// 10,0 -&gt; "X","-"
/// 7,3,2 -&gt; "7","/","2"
/// 10,7,3 -&gt; "X","7","/"
/// 0,10,10 -&gt; "-","/","X"
/// 10,10,10 -&gt; "X","X","X"
/// &lt;/example&gt;
/// &lt;param name="frames"&gt;
/// The parameter, frames, is a list of frames, each with a list of integers between 0 and 10 for the numbers of pins.
/// &lt;/param&gt;
/// &lt;returns&gt;
/// return value will be exactly the same structure as the parameter but with strings instead of ints
/// &lt;/returns&gt;
/// &lt;remarks&gt;
/// This function is an abstraction  (does not refer to local variables or have side effects)
/// &lt;/remarks&gt;
private List&lt;List&lt;string&gt;&gt; TranslateFrameScores(List&lt;List&lt;int&gt;&gt; frames)
{
    // This function looks a bit daunting but actually it just methodically makes the above example tranlations of the frame pin scores
    List&lt;List&lt;string&gt;&gt; rv = new List&lt;List&lt;string&gt;&gt;();
    int frameNumber = 0;
    foreach (List&lt;int&gt; frame in frames)
    {
        var frameScoring = new List&lt;string&gt;();
        if (frame.Count &gt; 0)
        {
            // The first 9 frames position the X in the second box on a real scorecard - handle this case separately
            if (frameNumber&lt;9 &amp;&amp; frame[0] == 10)
            {
                frameScoring.Add("");
                frameScoring.Add("X");
            }
            else
            {
                int ballNumber = 0;
                foreach (int pins in frame)
                {
                    if (pins == 0)
                    {
                        frameScoring.Add("-");
                    }
                    else
                    if (ballNumber&gt;0 &amp;&amp; frame[ballNumber]+frame[ballNumber-1] == 10)
                    {
                        frameScoring.Add(@"/");
                    }
                    else
                    if (pins == 10)
                    {
                        frameScoring.Add("X");
                    }
                    else
                    {
                        frameScoring.Add(pins.ToString());
                    }
                    ballNumber++;
                }

            }
        }
        rv.Add(frameScoring);
        frameNumber++;
    }
    return rv;
}</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="truetennis"><a class="anchor" href="#truetennis"></a>6.26.2. Tennis</h4>
<div class="paragraph">
<p>So now that we have these domain abstractions for doing console game scoring applications, let&#8217;s do tennis:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/diagram-tennis-3.png" alt="diagram tennis 3">
</div>
</div>
<div class="paragraph">
<p>I left the code out of the GetGameOrTieBreakScore box as it is a little big for the diagram here. It is similar to the other queries but it must first determine if a tie break is in progress and get that if so. Also it translates game scores from like 1,0 to "15","love".</p>
</div>
<div class="paragraph">
<p>And here is the code for the Tennis diagram:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>consolerunner = new ConsoleGameRunner("Enter winner 0 or 1", (winner, engine) =&gt; engine.Ball(winner, 1))
.WireTo(match)
.WireTo(new Scorecard(
        "--------------------------------------------\n" +
        "| M0  |S00|S10|S20|S30|S40|S50|S60|  G0--- |\n" +
        "| M1  |S01|S11|S21|S31|S41|S51|S61|  G1--- |\n" +
        "--------------------------------------------\n")
    .WireTo(new ScoreBinding&lt;int[]&gt;("M", () =&gt; match.GetScore()))
    .WireTo(new ScoreBinding&lt;List&lt;int[]&gt;&gt;("S", () =&gt;
        match.GetSubFrames()
            .Select(sf =&gt; sf.GetSubFrames().First())
            .Select(s =&gt; s.GetScore())
            .ToList())
    .WireTo(new ScoreBinding&lt;string[]&gt;("G", () =&gt; GetGameOrTiebreakScore(match)))
);</pre>
</div>
</div>
<div class="paragraph">
<p>If you compare this code with the diagram, you can see a pretty direct correspondence. match comes from the scoring engine project in Chapter two.</p>
</div>
</div>
<div class="sect3">
<h4 id="trueconcluding-notes"><a class="anchor" href="#trueconcluding-notes"></a>6.26.3. Concluding notes</h4>
<div class="paragraph">
<p>Although the diagrams must be turned into text code to actually execute, it is important in ALA to do these architecture design diagrams first. They not only give you the application, they give you the architectural design by giving you the domain abstractions and programming paradigms as well. If you try to design an ALA structure in your head while you write it directly in code, you will get terribly confused and make a mess. Using UML class diagrams will make it even worse. Code at different abstraction levels will end up everywhere, and run-time dependencies will abound. Our programming languages, and the UML Class diagram, are just not designed to support abstraction layered thinking - it is too easy to add bad dependencies (function calls or 'new' keywords) into code in the wrong places.</p>
</div>
<div class="paragraph">
<p>Note that at run-time, not all dataflows have to go directly between wired up instances of domain abstractions. The data can come up into the application layer code, and then back down. This was the case when we did the functional composition example in Chapter One. In this application we are doing that with the code in the square boxes that get the score from the engine. The important thing is that all the code in the application is specific to the application requirements.</p>
</div>
<div class="paragraph">
<p>That completes our discussion of the console applications for ten-pin and tennis. The full project code can be viewed or downloaded here:</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/johnspray74/GameScoring">GameScoring code</a></p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="truechapter-seven-the-philosophy-behind-ala"><a class="anchor" href="#truechapter-seven-the-philosophy-behind-ala"></a>7. Chapter seven - The philosophy behind ALA</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="truethe-human-brain"><a class="anchor" href="#truethe-human-brain"></a>7.1. The human brain</h3>
<div class="paragraph">
<p>In this perspective of ALA, we look at the problem of complexity in software in the context of how the human brain works.</p>
</div>
<div class="paragraph">
<p>Software design involves our intelligence or brain power. Understandability, readability, complexity are all things very closely related to the brain. Yet in the field of software engineering we pay little attention to how the brain understands our complicated world in order to understand how we should do our software.</p>
</div>
<div class="paragraph">
<p>Our brains do it primarily through one mechanism which we have come to call 'abstraction'. We learn abstractions from the commonality of multiple examples, and we then use abstractions without those examples cluttering up the common notion that was learned.</p>
</div>
<div class="imageblock right">
<div class="content">
<img src="images/Paintings_from_the_Chauvet_cave.jpg" alt="Paintings_from_the_Chauvet_cave.jpg" width="400">
</div>
<div class="title">Figure 48. Paintings in the Chauvet cave</div>
</div>
<div class="paragraph">
<p>Our ancestors could use a word like 'bring your spear' and it had a simple meaning to them only because all the detail and knowledge that went into building a spear was replaced with the abstraction 'spear'. Without the abstraction, the sentence would have had to be more like "bring the object that we made by joining the object we made by applying blows to the hard material we found at the place&#8230;&#8203;, with the long material we cut in the place with the tall&#8230;&#8203;, by tying it with the long grass material using the gooey stuff we found at the&#8230;&#8203;". Even this sentence was only made possible by other abstractions: joining, material, blows, hard, long (twice), cut, tall, tying, gooey, and found. If we expanded all of them until we were only using a few basic concepts like 'object' and 'place', we would have a sentence so long that we could never communicate at all. That&#8217;s what abstractions do, and how our brains make use of them. The word spear, in turn can be used to create a new abstraction, a hunting plan, while all of that other detail remains hidden from that new context.</p>
</div>
<div class="paragraph">
<p>The problem with software engineering is we are not making use of this way that the brain works. Simply put, we are not creating good abstractions. This lets the complexity inside one 'module' spill out into other modules. Abstractions, not modules, are the only mechanism that allows us to hide details at design-time.</p>
</div>
<div class="imageblock left">
<div class="content">
<img src="images/neuron.svg" alt="neuron.svg" width="300">
</div>
<div class="title">Figure 49. </div>
</div>
<div class="paragraph">
<p>As software engineers we do learn and use many abstractions. For example if we want to protect simultaneous access to the resource, our brain should conjure up 'mutex'.</p>
</div>
<div class="paragraph">
<p>If the brain already 'knows about' an abstraction, the abstraction is like any other single line of code, such as a mutex. We can make use of a mutex without having to deal with the details and complexities of how it works. We don&#8217;t have to think about the fact that we may have to wait for the resource. Nor that another thread may start running if we have to wait. Nor that if a higher priority thread preempts us while we have the resource, we may have it for a long time. Nor that if a still higher priority thread needs it during that long time, we will be given temporary priority to finish our use of it. We can just simply use the abstraction for protecting a resource.</p>
</div>
<div class="paragraph">
<p>Abstractions like mutex, regex, SQL are already invented by the 'culture' of software engineering, much like memes in the real world have been passed down to us. Where we fall down is when we get into a particular domain where the abstractions have not yet been invented, and we need to invent them. It is not easy to invent new abstractions, but invent them we must, at a rate far higher than is normal for cultural evolution.</p>
</div>
<div class="paragraph">
<p>Good domain abstractions, introduced and learned by new developers in the domain, then appear to them as normal program elements - things they can use with extraordinary convenience like any other line of code.</p>
</div>
</div>
<div class="sect2">
<h3 id="trueabstraction"><a class="anchor" href="#trueabstraction"></a>7.2. Abstraction</h3>
<div class="paragraph">
<p>Of the overwhelming list of engineering topics that we listed in Chapter One, this topic that is the most fundamental to ALA, and the one most needed for explaining it. It&#8217;s also probably the vaguest and most misunderstood topic in software engineering, so we will spend some time understanding it.</p>
</div>
<div class="paragraph">
<p>Abstraction will be the king. The short reason why we start with abstraction is that our quality attributes, complexity and understandability are very much to do with how our brains work, and for 100,000 years at least, our brains have worked with abstractions to understand our world. Abstractions are the only mechanism our brains use for dealing with otherwise complex things.</p>
</div>
<div class="paragraph">
<p>As in a chess game, winning is only about protecting the king. But this Abstraction king is benevolent. If he is destroyed, you do not lose the game immediately. It will take time, but you will lose.</p>
</div>
<div class="paragraph">
<p>There are other contenders to be king in the engineering topics list. For example, it is said that the best thing about TDD is not the testing but the emergence of better abstractions. TDD is like a lord that serves the king. It usually serves the king, causing you to make better abstractions. But sometimes it just serves its own purpose and makes the abstraction worse. It just produces code that works where it passes and no more.</p>
</div>
<div class="paragraph">
<p>Another contender is microservices. It is popular because it improves your abstractions by making them harder to destroy with cross coupling. But it too is just a lord. Because it provides physical boundaries that in normal software would be crossed, it serves the king. But by serving the abstraction king directly we can have logical boundaries, and all their benefits, even in 'monolithic' code.</p>
</div>
<div class="paragraph">
<p>Another contender to be king is 'no side effects' used by the functional mathematical purity guys. There are those who talk as if disobeying this king is absolute treason. But again, this lord is only effective because he usually serves the abstraction king. But, again, there are times when he doesn&#8217;t, and 'no side effects' is not enough to make a good abstraction.</p>
</div>
<div class="paragraph">
<p>ALA always follows the one true king.</p>
</div>
<div class="sect3">
<h4 id="trueclasses-modules-functions-and-encapsulation"><a class="anchor" href="#trueclasses-modules-functions-and-encapsulation"></a>7.2.1. Classes, Modules, functions and encapsulation.</h4>
<div class="paragraph">
<p>Classes, Modules, functions and encapsulation are artefacts of the language and do their thing at compile-time. They are not necessarily abstractions. They have been around for about 60 years, not enough time for our brains to see them in the same way as the compiler does. Although abstractions are implemented using these artefacts, ALA needs them to also be abstractions. In ALA "abstraction" is the term we use for the artefacts of our design instead of classes, modules, functions, or components, all of which are extremely fragile as abstractions.</p>
</div>
<div class="paragraph">
<p>In ALA, classes can still be used inside an abstraction, but they are just a language construct to allow operations given a reference to an object, not to so much to associated data and methods, or to encapsulate data representation. Inside an abstraction everything is considered cohesive, not structured in any way. Classes don&#8217;t make the abstractions in themselves, although in ALA many abstractions are implemented using a single class with ports.</p>
</div>
</div>
<div class="sect3">
<h4 id="truewikipedia-on-abstraction"><a class="anchor" href="#truewikipedia-on-abstraction"></a>7.2.2. Wikipedia on abstraction</h4>
<div class="paragraph">
<p>"Thinking in abstractions is considered by anthropologists, archaeologists, and sociologists to be one of the key traits in modern human behaviour, which is believed to have developed between 50 000 and 100 000 years ago. Its development is likely to have been closely connected with the development of human language, which (whether spoken or written) appears to both involve and facilitate abstract thinking."</p>
</div>
<div class="paragraph">
<p>In the real world, new abstractions come along infrequently, and are conceived of by few. People quickly begin using them to understand new insights or compose new things. They become so natural to us that we forget that they are abstractions. In no other field do we need to create them as fast as in software engineering. It is the most important skill a developer needs to have.</p>
</div>
</div>
<div class="sect3">
<h4 id="truedefining-abstraction"><a class="anchor" href="#truedefining-abstraction"></a>7.2.3. Defining abstraction</h4>
<div class="paragraph">
<p>The term abstraction is arguably one of software engineering&#8217;s vaguest or most overloaded terms. Because it is the most fundamental concept in ALA, we try to provide a definition. I find the easiest way to define it is to provide a set of 'statements about', 'properties of', or 'what it is nots':</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Etymology: 'to draw out commonality'</p>
</li>
<li>
<p>The concept or notion drawn out of what is common in multiple instances</p>
</li>
<li>
<p>Because it is a 'commonality', it is inherently reusable. Kruger says that  abstraction and reuse are two sides of the same coin.</p>
</li>
<li>
<p>Has inherent stability - as stable as the concept itself</p>
</li>
<li>
<p>The only mechanism that separates and hides <em>design-time</em> knowledge</p>
</li>
<li>
<p>Its concept or notion is easier to remember than its implementation. For a good abstraction, it is much, much simpler.</p>
</li>
<li>
<p>Abstractness increases with scope of reuse</p>
</li>
<li>
<p>Knows nothing about peer abstractions</p>
</li>
<li>
<p>use ports (instances or interfaces) for IO instead of directly calling other abstractions.</p>
</li>
<li>
<p>Abstractness decreases with more ports</p>
</li>
<li>
<p>Abstractness decreases as you get closer to your specific application</p>
</li>
<li>
<p>Abstractness is not how far you are above physical hardware</p>
</li>
<li>
<p>An ability our brains evolved understand the world</p>
</li>
<li>
<p>The only way we have of dealing with complexity</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="trueleaky-abstractions"><a class="anchor" href="#trueleaky-abstractions"></a>7.2.4. Leaky abstractions</h4>
<div class="paragraph">
<p>The code inside abstraction A could potentially tell how long B takes to execute. If it is sensitive to that, this is not a problem with ALA, but with the leaky abstraction. The design needs to be changed to eliminate the dependency on that leakage, or, if that is not possible, the coupling managed. But for the vast majority of code, the coupling between the insides of any two abstractions really is zero.</p>
</div>
</div>
<div class="sect3">
<h4 id="truethe-three-stages-of-creativity"><a class="anchor" href="#truethe-three-stages-of-creativity"></a>7.2.5. The three stages of creativity</h4>
<div class="imageblock text-center">
<div class="content">
<img src="images/creativity.jpg" alt="creativity.jpg" width="80%">
</div>
<div class="title">Figure 50. The creativity cycle</div>
</div>
<div class="paragraph">
<p>A good abstraction separates the knowledge of different worlds. A clock is a good abstraction. On one side is the world of cog wheels. On the other side is someone trying to be on time in their busy daily schedule. Neither knows anything about the details of the other. SQL is another good abstraction. On one side is the world of fast indexing algorithms. On the other is finding all the orders for a particular customer. Let us consider a domain abstraction - the calculation of loan repayments. On one side is the world of mathematics with the derivation and implementation of a formula. On the other, the code is about a person wanting to know if they can afford to buy a house. If your abstractions don&#8217;t separate knowledge of different worlds like this, then you are probably just factoring common code. Find the abstraction in that common code. Make it hide something complicated that&#8217;s really easy to use and really useful, like a clock.</p>
</div>
<div class="paragraph">
<p>The creativity cycle starts with abstractions, such as cogs and hands, instantiates them, configures them for a particular use, then composes them into a new abstraction. In ALA we usually go around the creativity cycle three times, creating three layers on top of our base programming language.</p>
</div>
</div>
<div class="sect3">
<h4 id="trueabstractions-need-ports"><a class="anchor" href="#trueabstractions-need-ports"></a>7.2.6. Abstractions need ports</h4>
<div class="paragraph">
<p>In traditional programs, inputs (or at least incoming function calls) are typically part of the module or class&#8217;s interface but outputs (or at least outgoing function calls) are typically just buried in the code.</p>
</div>
<div class="paragraph">
<p>This is fine if calling functions or methods in a lower abstraction layer. However, it is absolutely not fine if calling functions or methods of a peer in the same abstraction layer.</p>
</div>
<div class="paragraph">
<p>In ALA all inputs and outputs to or from peers in the same layer must be 'ports'.
There should be one port for each peer that can be wired. This is the Interface Segregation Principle. A port is a logical wirable connection point. A port either implements or accepts an interface. Outgoing function calls buried in the code that at run-time will go to a peer must only go to the port, which has an indirection mechanism of some kind.</p>
</div>
<div class="paragraph">
<p>Programming languages encourage all outgoing function or method calls to refer directly to the destination, or the destination&#8217;s interface, so you have to make an effort to avoid doing this.</p>
</div>
<div class="paragraph">
<p>A port is not an artefact of programming languages (yet) so they must be implemented logically somehow as normal code. To code a logical port, you need to do two things.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The interface type of the port must not be owned by another peer abstraction. The interface type must be from a lower abstraction layer.</p>
</li>
<li>
<p>The name of the port is the name of the field that accepts the interface.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>A port can have multiple interfaces. In this case I make the names of the multiple fields contain the port name.</p>
</div>
<div class="paragraph">
<p>If you are using an asynchronous event driven design, the equivalent of a conventional outgoing function call is typically written something like this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Send(Event, Receiver, Priority);</pre>
</div>
</div>
<div class="paragraph">
<p>where the Event is something the receiver defines.</p>
</div>
<div class="paragraph">
<p>Again, we are sending the event directly to a peer abstraction using the peer abstraction&#8217;s interface (its event).</p>
</div>
<div class="paragraph">
<p>In ALA, sending an event should be self-oriented, so written something like this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Send(Sender, SenderPort)</pre>
</div>
</div>
<div class="paragraph">
<p>The sender just sends the event out, not knowing where it goes, and the port identifies the event (or you could have both port and event). This just tells the event framework who the sender and sender&#8217;s port was. The event framework gets information from the application in the top layer to know what to do with the event. The application has the specific knowledge to know what an event from a given sender on a given port means, and therefore where it should go, and what the priority should be.</p>
</div>
<div class="paragraph">
<p>In general, classes, modules, components, functions should all have ports for both input and output. They should not own the interface types for these ports, whether they are incoming or outgoing.</p>
</div>
<div class="paragraph">
<p>An output port from an abstraction may say 'This has happened' or 'Here is my result', not 'do this next', or 'here is your input'.</p>
</div>
<div class="paragraph">
<p>There are multiple ways to implement the indirection inherent in ports for outgoing calls. They can be callbacks, signals &amp; slots, dependency injection, or calls to a framework send function.</p>
</div>
<div class="paragraph">
<p>Note that inputs and outputs are not necessarily on different ports. We may want to wire both inputs and outputs between two instances or two abstractions with a single wiring operation. The general case is that a single wiring operation wires multiple interfaces that are logically one port. One contains methods going in one direction and the other contains methods going in the other.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="truecomplexity-2"><a class="anchor" href="#truecomplexity-2"></a>7.3. Complexity</h3>
<div class="sect3">
<h4 id="truephilosophy-of-complexity"><a class="anchor" href="#truephilosophy-of-complexity"></a>7.3.1. Philosophy of complexity</h4>

</div>
<div class="sect3">
<h4 id="truedijkstra-on-complexity"><a class="anchor" href="#truedijkstra-on-complexity"></a>7.3.2. Dijkstra on complexity</h4>
<div class="paragraph">
<p><a id="Dijkstra1"></a></p>
</div>
<div class="paragraph">
<p>"It has been suggested that there is some kind of law of nature telling us that the amount of intellectual effort needed grows with the square of program length. But, thank goodness, no one has been able to prove this law. And this is because it need not be true. We all know that the only mental tool by means of which a very finite piece of reasoning can cover a myriad cases is called “abstraction”; as a result the effective exploitation of his powers of abstraction must be regarded as one of the most vital activities of a competent programmer. In this connection it might be worth-while to point out that the purpose of abstracting is not to be vague, but to create a new semantic level in which one can be absolutely precise. Of course I have tried to find a fundamental cause that would prevent our abstraction mechanisms from being sufficiently effective. But no matter how hard I tried, I did not find such a cause. As a result I tend to the assumption —up till now not disproved by experience— that by suitable application of our powers of abstraction, the intellectual effort needed to conceive or to understand a program need not grow more than proportional to program length."</p>
</div>
<div class="paragraph">
<p>The "conceive" part I agree with, if by that we mean the development. However, the "intellectual effort to understand" part needs further insight. We shouldn&#8217;t have to read an entire program to understand a part of it. We ought to be able to understand any one part of it in isolation. The effort to read any one part should be approximately constant. In Chapter One of this article there was a quality graph of complexity <a href="#ComplexityGraph1">here</a>.</p>
</div>
<div class="paragraph">
<p><a id="ComplexityGraph2"></a></p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/complexity_curve.png" alt="complexity curve">
</div>
</div>
<div class="paragraph">
<p>These graphs are qualitative in nature, based on experience. But now that we have a better understanding of ALA structure, we can explain how it manages to keep complexity from increasing.</p>
</div>
<div class="paragraph">
<p>In ALA, the design-time view of the system is nothing more than a static view of instances of abstractions composed together. In a typical application, there will be of the order of fifty different domain abstractions - not a difficult number to familiarize yourself with in a new domain.</p>
</div>
<div class="paragraph">
<p>Abstractions have no relationship with one another. Each is a standalone entity like a standalone program. If every abstraction contains say 500 lines of code, and the system itself contains 500 lines (instances of abstractions wired together) then the most complex the software gets is that of 500 lines of code.</p>
</div>
<div class="paragraph">
<p>Even if one abstraction is overly complex internally, say it conceals a piece of legacy code using a facade pattern, that doesn&#8217;t affect the complexity of any other part of the system.</p>
</div>
<div class="paragraph">
<p>ALA is based on the realization that abstraction is fundamentally the only mechanism available to us to achieve this constant complexity.</p>
</div>
<div class="paragraph">
<p>When doing this for the first time in a domain, it&#8217;s not easy to invent the abstractions. but the alternative is always runaway complexity.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The goal of software architecture should be to keep complexity constant.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="truezero-coupling-not-loose-coupling"><a class="anchor" href="#truezero-coupling-not-loose-coupling"></a>7.4. Zero coupling, not loose Coupling</h3>
<div class="paragraph">
<p>Here we meet the first meme from our list of software engineering topics that we must throw out. To many, this will seem a surprising one. Yes, I am saying 'loose coupling' is undesirable.</p>
</div>
<div class="sect3">
<h4 id="truea-common-argument"><a class="anchor" href="#truea-common-argument"></a>7.4.1. A common argument</h4>
<div class="paragraph">
<p>An argument is sometimes stated along these lines: "There must be at least some coupling, otherwise the system wouldn&#8217;t do anything." Hence we have the common meme about "loose coupling and high cohesion". In this section we show how this argument is false and resolve the apparent dilemma. We will eliminate all forms of design-time coupling except one. That one remaining one is anything but loose and very desirable.</p>
</div>
</div>
<div class="sect3">
<h4 id="trueclassifying-coupling"><a class="anchor" href="#trueclassifying-coupling"></a>7.4.2. Classifying coupling</h4>
<div class="paragraph">
<p>Think of some instances of dependencies you know of in a system and try to classify them into these three types by asking when the system would fail without it.</p>
</div>
<div class="paragraph">
<p>For example, let&#8217;s say that dataflows from an ADC (analog to digital converter) to a display as part of a digital thermometer. At run-time, both must exist. At compile-time both must have the same method signature:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/diagram-01.png" alt="diagram 01">
</div>
</div>
<div class="paragraph">
<p>Or the display may tell the ADC when to do the conversion. At run-time there is temporal coupling.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/diagram-02.png" alt="diagram 02">
</div>
</div>
<div class="paragraph">
<p>In this one there is an association from a Customer class to an Account class to facilitate communication between them. At run-time there is coupling. At compile-time there is coupling too - the type of the Account class must be exactly the same as expected by the Customer class:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/diagram-04.png" alt="diagram 04">
</div>
</div>
<div class="paragraph">
<p>In all the above diagrams, relationships shown in red indicate they are disallowed by the ALA constraints. Green is for desirable relationships, of which there is only one. When we disallow all these types of coupling, the modules, components, functions and classes can now be abstractions.</p>
</div>
</div>
<div class="sect3">
<h4 id="truerun-time-compile-time-and-design-time"><a class="anchor" href="#truerun-time-compile-time-and-design-time"></a>7.4.3. Run-time, Compile-time and Design-time</h4>
<div class="paragraph">
<p>A few times already in the article, I have sneaked in a magic qualifier, 'design-time'. You know how we sometimes talk about run-time and compile-time with reference to binding. In ALA we recognise that understandability, complexity, etc, are all happening at design-time. By design-time I mean any time you are reading code, writing code, or changing code.</p>
</div>
<div class="paragraph">
<p>At run-time, the CPU processes data. At compile-time, the compiler processes code. At design-time the brain is processing abstractions.</p>
</div>
<div class="paragraph">
<p>In conventional code, it is common for all forms of coupling, run-time, compile-time, and design-time, to appear as coupling between modules or classes.</p>
</div>
<div class="paragraph">
<p>You can work out what type of dependency you have by when it first breaks. A run-time dependency doesn&#8217;t break until the program runs. The program can still be compiled and it can still be understood.</p>
</div>
<div class="paragraph">
<p>A compile-time dependency first breaks at compile-time. At design-time the code can still be understandable.</p>
</div>
<div class="paragraph">
<p>A design-time dependency prevents code from even being understood. The code loses its meaning.</p>
</div>
</div>
<div class="sect3">
<h4 id="truelayers"><a class="anchor" href="#truelayers"></a>7.4.4. Layers</h4>
<div class="paragraph">
<p>In everyday design, knowledge dependencies are not normally shown as lines. You simply use the abstraction by its name. But in this article, just so we can explain the meta-architecture, we will sometimes draw knowledge dependencies like this (always downward).</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/diagram-05.png" alt="diagram 05">
</div>
</div>
<div class="paragraph">
<p>This represents that the implementation of abstraction C knows about abstraction A. A is more abstract than C. C and A cannot therefore be peers, as was the case with the components above. Peer abstractions cannot have any coupling with one another.</p>
</div>
</div>
<div class="sect3">
<h4 id="truewhole-part-pattern"><a class="anchor" href="#truewhole-part-pattern"></a>7.4.5. Whole-Part pattern</h4>
<div class="paragraph">
<p>If you are familiar with the Whole-Part pattern, ALA uses it extensively. But there is a constraint. The Whole-Part pattern is only used with knowledge dependencies (since that is the only relationship you are allowed). It may of course be used in other forms inside an abstraction, provided it is completely contained in a single abstraction.</p>
</div>
<div class="paragraph">
<p>A real world example of the Whole-Part Pattern with knowledge dependencies is Molecules and Atoms. A water molecule, for example, is the whole.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/diagram-06.png" alt="diagram 06">
</div>
</div>
<div class="paragraph">
<p>Oxygen and hydrogen are the parts. Note that oxygen and hydrogen are abstractions, and they are more abstract than water because they are more ubiquitous, more reusable and more stable (as a concept) than any specific molecule. We could make a different molecule but still use exactly the same oxygen and hydrogen as parts to compose the new molecule.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When we use the word 'ubiquitous', it refers to the number of times the abstraction is used in a Whole-Part pattern to make other abstractions. It doesn&#8217;t refer to the number of abstractions that are instantiated. So just because there is a lot of water, that doesn&#8217;t make the abstraction ubiquitous. In comparing the abstraction levels of Oxygen and Hydrogen with water, Oxygen and Hydrogen are more ubiquitous because they are used to make more abstractions than water is.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The molecules and atoms analogy with ALA is very close, and we will return to it when we come to explain in more detail how run-time and compiler-time dependencies are moved inside a single abstraction.</p>
</div>
<div class="paragraph">
<p>For now we just need to remember that we are using the whole-part pattern with knowledge dependencies only. At design-time, the whole is explained and reasoned about in terms of the parts, just as the water molecule is in terms of the oxygen and hydrogen.</p>
</div>
</div>
<div class="sect3">
<h4 id="truerun-timedesign-time-congruence"><a class="anchor" href="#truerun-timedesign-time-congruence"></a>7.4.6. Run-time/design-time congruence</h4>
<div class="paragraph">
<p>A software program can be temporally confusing. Everything that happens at design-time is in preparation for what will happen at run-time. Our low-level imperative languages tend to keep the two congruent. The statements in the program at design-time follow in the same order as they will execute at run-time. The only difference between the two is a time shift and the speeding up of the clock.</p>
</div>
<div class="paragraph">
<p>When we want the knowledge of run-time dependencies to be moved inside another abstraction, this congruence between design-time and run-time must be broken. Unfortunately, developers start out by learning a low-level imperative language, so it becomes unnatural to them to architect their programs without this congruence. Indeed, breaking this congruence needs a pattern to be learned, and then carefully protected from the temptations of our imperative languages. I call it the Ẃiring pattern'.</p>
</div>
<div class="paragraph">
<p>Before going into the pattern, we need to round out the most important aspects of ALA.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="truewiring-pattern-part-one"><a class="anchor" href="#truewiring-pattern-part-one"></a>7.5. Wiring pattern - Part one</h3>
<div class="paragraph">
<p>We now introduce the pattern that both solves the congruence problem just discussed in the previous section, and provides the alternative to all those disallowed coupling types discussed earlier. This pattern is usually an important part of ALA.</p>
</div>
<div class="paragraph">
<p>Note: The wiring pattern is not necessarily a part of an ALA architecture. For example, if your whole problem is just an algorithm, and therefore suits a functional programming style, then you can still compose abstractions with function abstractions, provided all function calls are knowledge dependencies, and not say, just passing data or events.</p>
</div>
<div class="paragraph">
<p>If you are using monads, especially I/O monads, or RX (reactive extensions), especially with hot observables, you are already using the wiring pattern. The pipes and filter pattern is also an example of the wiring pattern. Labview or Node-Red can use the wiring pattern. There are many other examples of the wiring pattern. Most support a dataflow programming paradigm. Here we generalise the pattern to support any programming paradigm.</p>
</div>
<div class="paragraph">
<p>The wiring pattern may be the same as the "Component Pattern" in some literature if used with what is referred to as 'configurable modularity' or 'abstracted interactions'.</p>
</div>
<div class="paragraph">
<p>The wiring pattern allows lines on your application diagram to mean any programming paradigm you want that express your requirements. It also allows you to implement multiple programming paradigms together in the same diagram.</p>
</div>
<div class="paragraph">
<p>If you are using dependency injection with explicit code for the wiring (not auto-wiring), then you are half way there.</p>
</div>
<div class="paragraph">
<p>The wiring pattern separates design-time/run-time congruence. It works by having a 'wiring-time' that is separated from run-time. 'Wiring-time' can happen any time before run-time. It can happen immediately before it, as for instance in LINQ statements or RX with a cold observable. It becomes powerful when we make wiring-time congruent with design-time. Usually the wiring code will actually run at initialization time, when the program first starts running. That initialization code becomes the architectural design.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s suppose you have designed your system with two modules, A and B. There will be one of each in your system.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/diagram-07.png" alt="diagram 07">
</div>
</div>
<div class="paragraph">
<p>At run-time we know that A will talk to B. So we design A to have an association with B. The association may first appear on a UML model, or it may go straight into the code something like this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>static component A
{
   B_method();
}</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>static component B
{
   public B_method() { }
}</pre>
</div>
</div>
<div class="paragraph">
<p>A and B may be implemented as non-static, with only one instance of each. The association is still there.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>component A
{
   private var b = new B();
   b.method();
}</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>component B
{
   public method() { }
}</pre>
</div>
</div>
<div class="paragraph">
<p>A may create B itself, which is a composition relationship, as above. Or A may have a local variable of type B passed in by some kind of dependency injection, which is still an association relationship.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>component A
{
   B b;
   public setter(B _b) {b = _b}
   b.method();
}</pre>
</div>
</div>
<div class="paragraph">
<p>Note that although dependency injection was used, it only eliminated part of the dependency, that of which particular subtype of B it is going to talk to, but A still knows the general type B, which is not allowed in ALA. (Part of the problem here is that A and B were probably arrived at by decomposition, and so they have subtle knowledge of each other, for example of how they collaborate.)</p>
</div>
<div class="paragraph">
<p>If A and B are collaborating, they are not abstractions. Their knowledge of each other at design-time (to enable their relationship at run-time) binds them to each other so that neither can be reused in any other way. And if they can&#8217;t be reused, they can&#8217;t be abstract.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s revisit the water molecule analogy we discussed earlier for the Whole-Part pattern, and develop it further to be clearer how these dependencies affect abstractions. Let&#8217;s say we have decomposed water into two components, Oxygen and Hydrogen. Oxygen will talk to Hydrogen to get an electron, so we write:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>component Oxygen
{
   var h1 = new Hydrogen();
   var h2 = new Hydrogen();
   h1.getElectron();
   h2.getElectron();
}</pre>
</div>
</div>
<div class="paragraph">
<p>The diagram for that looks like this:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/diagram-08.png" alt="diagram 08">
</div>
</div>
<div class="paragraph">
<p>In the real world, oxygen is a very useful abstraction for making other molecules. In writing code this way to make water, we have tied it to hydrogen. Oxygen can&#8217;t be used anywhere else, at least not without bringing with it two hydrogens, rendering it useless. By implementing the Oxygen-Hydrogen relationship needed to make water in oxygen, we have destroyed the oxygen abstraction. We never even made the water abstraction. To understand water, we would have to read the code inside oxygen, where the parts about water have become entangled with the inner workings of oxygen, protons and neutrons and all that stuff. Oxygen is also used to make caffeine. We could never make coffee!</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/caffeine%20molecule.png" alt="Caffeine molecule.png" width="300">
</div>
<div class="title">Figure 51. caffeine - oxygen atoms are red</div>
</div>
<div class="paragraph">
<p>Abstractions are fragile and get destroyed easily, so we have to take care to protect them. What we needed to do was to put the knowledge about the relationship between oxygen and hydrogen to make water in a new abstraction called Water.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/diagram-09.png" alt="diagram 09">
</div>
</div>
<div class="paragraph">
<p>In general, to break coupling between peer modules A and B, we move the knowledge of the coupling to a higher level abstraction (less abstract level) where it belongs. Let&#8217;s call it C. C is a more specific abstraction. The knowledge is encapsulated there - it never appears as a dependency of any kind. And it is cohesive with other knowledge that may be contained inside abstraction C.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/diagram-10.png" alt="diagram 10">
</div>
</div>
<div class="paragraph">
<p>becomes</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/diagram-11.png" alt="diagram 11">
</div>
</div>
<div class="paragraph">
<p>The diagram above is only to show the ALA knowledge dependency relationships between the three abstractions. It doesn&#8217;t yet show explicitly that an instance of Abstraction A will be wired to an instance of Abstraction B. In practice we never actually draw knowledge dependencies. We are just doing so here to show how ALA works. We would draw it in this way instead:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/diagram-12.png" alt="diagram 12">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/diagram-13.png" alt="diagram 13">
</div>
</div>
<div class="paragraph">
<p>Now we have the explicit wiring. It looks a lot like the original diagram where we had no C. But where the knowledge is coded is very different. Because it is C and not A that has the knowledge of the relationship between A and B, Abstractions A and B do not change. They continue to know nothing of the connection. They remain abstractions. They remain re-usable.</p>
</div>
<div class="paragraph">
<p>It may seem at first that adding the extra entity C is a cost, but in fact C is an asset. It shows the structure of the system. It shows it explicitly. It shows it in one small understandable place. And it is executable - it is not a model.</p>
</div>
<div class="paragraph">
<p>The original abstractions were left below C to show that they still exist as free abstractions to be used elsewhere. They are not contained by C in any way as modules from a decomposition process would be. The A and B inside C are only instances. We wouldn&#8217;t normally bother to draw the abstractions below. So we just draw this:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/diagram-14.png" alt="diagram 14">
</div>
</div>
<div class="paragraph">
<p>C must achieve the connection between A and B either at compile-time or run-time. With current languages, the easiest time to do this is at initialization time, when the program first starts running. This is similar to dependency injection, except that we are not going to inject the instance of B into A.</p>
</div>
<div class="paragraph">
<p>This is what the code inside C might look like:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Abstraction C
{
   var a = new A();
   var b = new B();
   a.wireTo(b);
}</pre>
</div>
</div>
<div class="paragraph">
<p>Typically we will write the code using the fluent pattern, with the wireTo method always returning the object on which it is called, or the wireIn method always returning the object wired to. The constructor already returns the created object by default.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Abstraction C
{
   new A().wireTo(new B());
}</pre>
</div>
</div>
<div class="paragraph">
<p>If A and B are static modules, this produces something like:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Abstraction C
{
   A_setcallback(B_method);
}</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="truewiring-pattern-part-two"><a class="anchor" href="#truewiring-pattern-part-two"></a>7.6. Wiring pattern - part two</h3>
<div class="paragraph">
<p>We are half-way through explaining the wiring pattern. Now we turn our attention to how A and B can communicate without knowing anything about each other.</p>
</div>
<div class="paragraph">
<p>This part of the pattern is also called "Abstract Interactions"</p>
</div>
<div class="paragraph">
<p>Of course, one way is that C acts as the intermediary. This way is less preferred because it adds to C&#8217;s responsibilities. But it is sometimes necessary if there are some abstractions brought in from outside. Such abstractions will 'own' their own interfaces or may come with a contract which C will have to know about. C will usually have to wire in an adapter, or handle the communications between the two abstractions itself.</p>
</div>
<div class="paragraph">
<p>A better way, because it leads to an architectural property of composability, is that A and B know about a 4th abstraction that is more abstract than either of them. This is legal because it is a design-time knowledge dependency.  Let&#8217;s call it I.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/diagram-15.png" alt="diagram 15">
</div>
</div>
<div class="paragraph">
<p>I is an interface of some kind. It may or may not be an actual artefact. What it must be is knowledge that is more abstract than A and B and therefore knows nothing of A and B. It is more ubiquitous and more reusable than A and B are. In other words we can&#8217;t just design I to meet the particular communication needs of A and B. That would cause A and B to have some form of coupling or collaboration with each other, and again destroy them as abstractions.</p>
</div>
<div class="paragraph">
<p>I is so abstract, ubiquitous and reusable, that it corresponds to the concept of a programming paradigm. We will cover programming paradigm abstractions in following sections because they are a critically important part of ALA. We will see that ALA is polyglot with respect to programming paradigms.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/circuit%20diagram.gif" alt="circuit diagram.gif">
</div>
<div class="title">Figure 52. In an electronic schematic, the components are abstractions that are composed using two paradigm interfaces - live analog signals and live digital signals</div>
</div>
<div class="paragraph">
<p>Returning to a software example, let&#8217;s choose a single simple programming paradigm: activity flow. This programming paradigm is the same as the UML Activity diagram. When we wire A to B and they use this paradigm, it means that B starts after A finishes. If A and B accept and provide this interface respectively, then wiring them together by drawing an arrow will have that meaning, and cause that to happen at run-time.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/diagram-16.png" alt="diagram 16">
</div>
</div>
<div class="paragraph">
<p>It is easy to create an interface for the activity-flow programming paradigm. It has a single method, let&#8217;s call it 'start'. Many abstractions at the level of A and B can either provide or accept this paradigm interface. Then instances of them can be wired up in any order and they will follow in sequence just like an Activity diagram.</p>
</div>
<div class="paragraph">
<p>Note that the Activity Diagram is not necessarily imperative in that any Activity can take an amount of time to complete that is not congruent with the actual CPU execution of code. In other words activities can be asynchronous with the underlying code execution, and for example, delay themselves during their execution, or wait for something else to finish, etc.</p>
</div>
<div class="paragraph">
<p>The code in Abstraction A could look something like this. Don&#8217;t take too much notice of the exact method used to accomplish the wiring. There are many ways to do this using only knowledge dependencies. The important thing is that A continues to know nothing about its peers, continues to be an abstraction, and yet can be wired with its peers to take part in any specific activity flow sequence:</p>
</div>
<div class="literalblock">
<div class="content">
<pre> Abstraction A : IActivity
 {
    private IActivity next = null;

    public IActivity wireTo(IActivity _next)
    {
        next = _next;
        return _next;
    }

    IActivty.start()
    {
        // start work
    }

    // code that runs when work is finished.
    // may be called from the end of start, or any time later
    private finishedWork()
    {
        if (next!=null) next.start();
    }
 }</pre>
</div>
</div>
<div class="paragraph">
<p>Abstraction A both <em>provides</em> and <em>accepts</em> the interface. This allows it to be wired before or after any of its peer abstractions. In ALA we use the word 'accepts' rather than 'requires' because there is often an end to a chain of abstraction instances wired together. If no next interface is wired in, the activity flow ends.</p>
</div>
<div class="paragraph">
<p>Abstraction B would be written in the same way, as it also knows about the Activity flow interface:</p>
</div>
<div class="literalblock">
<div class="content">
<pre> Abstraction B : IActivity
 {
    private IActivity next = null;

    public IActivity wireTo(IActivity _next)
    {
        next = _next;
        return _next;
    }

    IActivty.start()
    {
        // start work
    }

    // code that runs when work is finished.
    // may be called from the end of start, or asychronously later
    private finishedWork()
    {
        if (next!=null) next.start();
    }
 }</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
As an aside, in C# projects, we wrote wireTo as an extension method for all objects. It used reflection to look at the private interface variables in the source class and the interfaces provided by the destination class. It would then match up the interface types and do the wiring automatically. It could even use port names to explicitly wire ports of the same types.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Now let&#8217;s revisit the molecule analogy. By now we would know to put the knowledge that Oxygen is bonded to two Hydrogens inside the water abstraction where it belongs.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/diagram-17.png" alt="diagram 17">
</div>
</div>
<div class="paragraph">
<p>In terms of knowledge dependencies it means this:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/diagram-18.png" alt="diagram 18">
</div>
</div>
<div class="paragraph">
<p>The programming paradigm here is a polar bond. It is more abstract (more ubiquitous and reusable) than any particular atom.  We could have a second programming paradigm, a covalent bond, as well. Again, the important thing here is not what the code does - that is arbitrary (and not actually correct chemistry) but how the atoms can be made to interact while retaining their abstract properties with only design-time knowledge dependencies:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Abstraction PolarBond
{
   GiveElectron();
}</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre> Abstraction Oxygen
 {
    private PolarBond hole1 = null;
    private PolarBond hole2 = null;

    public Oxygen wireIn(PolarBond _pb)
    {
        if (hole1==null) hole1 = _pb; else
        if (hole2==null) hole2 = _pb;
        return this;
    }

    public Initialize()
    {
        if (hole1!=null) { hole1.getElectron(); BecomeNegativelyCharged(); }
        if (hole2!=null) { hole2.getElectron(); BecomeNegativelyCharged(); }
    }
 }</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre> Abstraction Hydrogen : PolarBond
 {
    PolarBond.getElectron()
    {
        BecomePositivelyCharged();
    }
 }</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre> Abstraction Water
 {
    new Oxygen()
        .wireTo(new Hydrogen())
        .wireTo(new Hydrogen())
        .Initialize();
 }</pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s do one more example, this time with a dataflow programming paradigm. I have found that dataflow is the most useful programming paradigm in practice. It is useful in a a large range of problems.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s construct a thermometer. Assume we already have in our domain several useful abstractions: an ADC (Analog Digital Converter) that knows how to read data from the outside world, a Thermistor abstraction that knows how to linearise a thermistor, a Scale abstraction that knows how to offset and scale data, a filter abstraction that knows how to smooth data, and a display abstraction that knows how to display data.</p>
</div>
<div class="paragraph">
<p>All these domain abstractions will use the dataflow programming paradigm. Note that none of them know anything about a Thermometer, nor the meaning of the data they process.</p>
</div>
<div class="paragraph">
<p>So we can go ahead and create a Thermometer application just by doing this:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/diagram-19.png" alt="diagram 19">
</div>
</div>
<div class="paragraph">
<p>Note that we configure all the abstraction instances for use in the Thermometer by adding configuration information into rows on the instances.</p>
</div>
<div class="paragraph">
<p>When we manually compile the diagram (assuming we don&#8217;t have automated code generation), it might look something like this (again using fluent coding style):</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Abstraction Thermometer
{
   new ADC(Port2, Pin3)
       .setFrequency(1000)
       .wireTo(new Thermister().setType('K').setInputRange(20,1023)
           .wireTo(new Scale(32,0.013)
               .wireTo(newDisplay().setDigits(4).setDecimals(1))
           )
       );
}</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The configuration setters and the WireTo extension method return the object on which the call is made to support the fluent coding style.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The diagram is the requirements, the solution and the architecture of the application, and is executable. The diagram has all the cohesive knowledge that is a thermometer, and no other knowledge.</p>
</div>
<div class="paragraph">
<p>The diagram can be read stand-alone, because all the dependencies in it are knowledge dependencies on abstractions we would already know in the domain.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s say when the Thermometer runs, there is a performance issue in that the ADC is producing data at 1kHz, and we don&#8217;t need the display to be showing Temperatures at that rate. Also the temperature readings are noisy (jumping around). Let&#8217;s make a modification to the Thermometer by adding a filter to reduce the rate and the noise:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/diagram-20.png" alt="diagram 20">
</div>
</div>
<div class="paragraph">
<p>If the domain abstractions are not already implemented, we have got the architecture to the point where we can ask any developer to implement them, provided we first give them knowledge of ALA and of the programming paradigm(s) being used.</p>
</div>
<div class="paragraph">
<p>But let&#8217;s look how the dataflow paradigm might work.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If you are familiar with RX (Reactive extensions) with a hot observable source (which is an example of the wiring pattern), this is similar in concept although RX tries to have duality with for-loops iterating through the data. The dataflow paradigm we set up here will just be a stream of data. The IDataFlow interface corresponds to IObserver, and the wireTo method corresponds to the Subscribe method.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The ideal would be a language where we don&#8217;t have to decide if the dataflow will be push or pull, synchronous or asynchronous, buffered or unbuffered or other characteristics of communications. The abstractions would not need to know these things - they would just have logical I/O ports, and the type of communications could be binded in at compile-time as part of the performance configuration of the system.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Later we will introduce an asynchronous (event driven) execution model. It is preferable to do the dataflow paradigm interface using that because it allows better performance of other parts of the system without resorting to threads.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For simplicity, we will just implement a synchronous push system. Again, don&#8217;t worry about the filter itself. The code is just there to see how the LowPassFilter fits in with the dataflow programming paradigm, and how simple doing that can be.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Interface IDataFlow&lt;T&gt;
{
   push(T data);
}</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre> /// LowPassFilter is a DataFlow paradigm decorator to be used in an ALA archtecture.
 /// 1. Decimates the incoming data rate down by the setCutoff configuration
 /// 2. Smooths the data with a single pole filter with cutoff frequency equall to the input frequency divided by the cutoff. T must be a numeric type.
 /// Normal checks and exceptions removed to simplify
 Class LowPassFilter&lt;T&gt; : IDataFlow&lt;T&gt;
 {
    private Dataflow next;

    // This is normally done by a general extension method
    public IDataflow wireTo(IDataflow _next)
    {
        next = _next;
        return _next;
    }

    integer cutoff;

    setCutoff(integer _cutoff)
    {
        cutoff = _cutoff;
    }

    int count = 0;
    T filterState = NAN;

    IDataFlow.push(T newData)
    {
        if (filterState==NAN) filterState = newData * cutoff;
        filterState = filterState - filterState/cutoff + newData;
        count++;
        if (count==cutoff)
        {
            count = 0;
            if (next!=null) next.push(filterState/cutoff);
        }
    }
 }</pre>
</div>
</div>
<div class="paragraph">
<p>You will notice that both the Domain abstraction, Filter, and the Programming Paradigm abstract interface, IDataFlow, use a parameterised type. This makes sense because only the application, the Thermometer, knows the actual types it needs to use.</p>
</div>
</div>
<div class="sect2">
<h3 id="trueexpression-of-requirements"><a class="anchor" href="#trueexpression-of-requirements"></a>7.7. Expression of requirements</h3>
<div class="paragraph">
<p>One of the fundamental aspects of ALA is that the abstraction level of the application is fixed and defined by:</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The succinct <span class="green"><strong>description</strong></span> of <span class="green"><strong>requirements</strong></span></p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This is a similar concept to a DSL (but not quite the same). If the abstraction level were more specific, we wouldn&#8217;t have the versatility to describe changing requirements or new applications in the domain (too expressive). If it were were more general, we would have to write more code to describe the requirements (not expressive enough).</p>
</div>
<div class="paragraph">
<p>I noticed during 40 years of code bases written at our company, two did not deteriorate under maintenance. They always remained as easy to maintain as they were in the beginning, if not easier. All others deteriorated badly. Some deteriorated so badly that they could no longer be maintained at all. At the time we din&#8217;t know why and could not predict which way it would go. It seemed as if you just got lucky or unlucky.</p>
</div>
<div class="paragraph">
<p>Perhaps it was the type of changes that came along? But the two code bases that were easy to maintain seemed to be easy for any kinds of change. And the ones that were hard were hard for any change. This continued to hold for years on end. Of course, most changes were changes to requirements, but often enough, changes would be for performance or other reasons. These also seemed easy in these two code bases, but hard everywhere else.</p>
</div>
<div class="paragraph">
<p>I began to look at the structure and style of the easy and hard code. The easy code was not complicated while the hard code had degenerated well into the complex. The two easy code bases were doing very different things in very different ways, so there was apparently not a common structure or style. But they did have one thing in common. The code that represented the knowledge of the requirements was separated out. That code <em>only</em> described requirements, and it was expressed in terms of other things that were relatively independent, reusable and easy to understand (what we call abstractions).</p>
</div>
<div class="paragraph">
<p>This is what first gave rise to one of the core tenets in ALA. The first separation is not along the lines of functional or physical parts of the system, such as UI, Business logic, and Data model. The first separation is code that just describes requirements.</p>
</div>
<div class="paragraph">
<p>Of course this has a strong parallel with how DSLs work. Is ALA just DSLs? There are several differences. Firstly in ALA we don&#8217;t try to create a sandbox language for a domain expert to maintain applications. We don&#8217;t go as far as an external DSL. It&#8217;s for the developer and we don&#8217;t want to cut him off from the power he already has when it is needed. We just give him a way to organise the code and a process to get him there - describe the requirements knowledge in terms of abstractions and then trust that those abstractions, when written, will make it work.</p>
</div>
</div>
<div class="sect2">
<h3 id="trueno-two-modules-know-the-meaning-of-data-or-a-message"><a class="anchor" href="#trueno-two-modules-know-the-meaning-of-data-or-a-message"></a>7.8. No two modules know the meaning of data or a message.</h3>
<div class="paragraph">
<p>The two modules will have collaborative knowledge. We reason that the sender must know the meaning to formulate the message, and the receiver must know the meaning to interpret the message. So how can it be avoided? The answer is to make the sender and receiver in same abstraction. They both know the same knowledge, so they are cohesive, so they should be together. In the logical view of the system, they are two instances of the one abstraction. We let the physical view fact that the sender and receiver will be deployed in different places drive them to be different modules.</p>
</div>
</div>
<div class="sect2">
<h3 id="trueexpressiveness"><a class="anchor" href="#trueexpressiveness"></a>7.9. Expressiveness</h3>
<div class="paragraph">
<p>Requirements are usually understated initially in terms of abnormal conditions. However, they are usually communicated quite quickly relative to the time to write the code. In ALA, they are separately represented. The precise expression of the requirements using the right programming paradigms should take about the same amount of information as the English explanation of them.</p>
</div>
<div class="paragraph">
<p>In general, ALA probably requires about the same amount of total code. But once the requirements are represented, the domain abstractions are known and they are independent small programs with dependencies only on the programming paradigm interfaces used. This independence should make them much easier to write. As the system matures, the effort to modify gets less as more domain abstractions come on line as tested, mature and useful building blocks. The final cost of maintenance should be much less than an equivalent ball of mud architecture.</p>
</div>
</div>
<div class="sect2">
<h3 id="trueno-models"><a class="anchor" href="#trueno-models"></a>7.10. No models</h3>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Leave out details only inside abstractions</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>It is generally accepted that a software architecture must, by necessity, leave out some details. Somehow we need to find a satisfactory architecture without considering all the details. Often models are used to represent the architecture. Like its metaphor in the real world, a model leaves out details. The problem is they can leave out arbitrary details. We can&#8217;t be sure that some omitted detail won&#8217;t turn out to be important to the architectural design.</p>
</div>
<div class="paragraph">
<p>ALA therefore does not use the model metaphor. Instead, it uses diagrams (if not plain old text). Of course, this distinction comes down to semantics. I define a diagram as different from a model in that it does not leave out details arbitrarily. The only way to leave out details in an ALA diagram is inside the boxes, in other words inside abstractions. Because abstractions already have the required meaning when used in the diagram, the details omitted can&#8217;t be important to the diagram, and can&#8217;t affect the architectural design.</p>
</div>
<div class="sect3">
<h4 id="trueexecutable-architecture"><a class="anchor" href="#trueexecutable-architecture"></a>7.10.1. Executable architecture</h4>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Your architecture should be executable</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The distinction between diagrams and models explained in the previous section gives rise to an interesting property of the ALA architecture. Diagrams are executable. Therefore the architecture itself will be executable. When the implementation of the abstractions is complete, there will be no work left to do to make the architecture execute (apart from practical considerations of bugs, misinterpretations of the requirements, performance issues, improvements to the initially conceived set of domain abstractions, and the like).</p>
</div>
<div class="paragraph">
<p>There should be two aspects of an architecture, the meta-architecture and the specific architecture. If using ALA, ALA itself is the meta-architecture and the top level application diagram is the specific architecture.</p>
</div>
<div class="paragraph">
<p>If your specific architecture is executable, it is also code. There is no separate documentation or model trying to act as a second source of truth.</p>
</div>
</div>
<div class="sect3">
<h4 id="truegranularity"><a class="anchor" href="#truegranularity"></a>7.10.2. Granularity</h4>
<div class="paragraph">
<p>The final architecture of your software will consist only of abstractions. These abstractions will need to be independently readable and understandable. To meet this need, all of the abstractions will be small, even the 'system level' ones.</p>
</div>
<div class="paragraph">
<p>Conversely, none should be too small. We want them small enough to allow the human brain to understand them, but there is no need for them to be smaller, or we will just end up with an inordinate number of them. This inordinate number will tax the brain in a different way, by causing it to have to learn more abstractions than necessary in a given domain.</p>
</div>
<div class="paragraph">
<p>The ideal abstraction size is probably in the range of 50 to 500 lines of code.</p>
</div>
</div>
<div class="sect3">
<h4 id="truemodules-components-layers"><a class="anchor" href="#truemodules-components-layers"></a>7.10.3. Modules, Components, Layers</h4>
<div class="paragraph">
<p>The common terms, modules, components, or layers often result from a decomposition process and therefore are parts of a specific system. The system may have only one of each type. The parts have a lower abstraction level than the system because they are just specific parts of it. In ALA we want to reverse this so that parts are more abstract than the system.</p>
</div>
<div class="paragraph">
<p>But say you do end up with some single use abstractions and implement it in a static way, it is important to still see these entities as two aspects in one: an abstraction and an instance.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="trueabstraction-layers-2"><a class="anchor" href="#trueabstraction-layers-2"></a>7.11. Abstraction Layers</h3>
<div class="sect3">
<h4 id="truelayers-pattern"><a class="anchor" href="#truelayers-pattern"></a>7.11.1. Layers pattern</h4>
<div class="paragraph">
<p>With only design-time knowledge dependencies to deal with, layers are used for organising these dependencies so that there are no circular dependencies, and that they all go toward more abstract, more stable abstractions. As the name "Abstraction Layered Architecture" suggests, layers are crucially important to ALA.</p>
</div>
<div class="paragraph">
<p>In the section on the wiring pattern we ended with three layers:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/diagram-21.png" alt="diagram 21">
</div>
</div>
<div class="paragraph">
<p>There is a Layers pattern that also controls dependencies, but since most systems have numerous run-time dependencies between elements represented as design-time dependencies, these layers are used for the run-time dependencies. It is usually explained that each layer is built on services provided by the layer below it.</p>
</div>
<div class="paragraph">
<p>One example is the UI/Business Logic/Data model. Another example is the OSI communications model, where the layers are Application, Presentation, Session, Transport, Network, Data link, and Physical. In ALA, each of these ends up being turned 90 degrees. Metaphorically they become chains. In ALA each component wouldn&#8217;t know about the components next to it. That applies symmetrically, to the left and to the right. Data goes in both directions. At run-time, everything must exist for the system to work. It doesn&#8217;t really make sense to use a asymmetrical layers metaphor.</p>
</div>
<div class="paragraph">
<p>The design pattern for layers does have one or two examples of layering used by knowledge dependencies. The term ‘layer’ is therefore an overloaded term in software engineering. When used for knowledge dependencies, the English term 'layer' is a better metaphor. If a lower layer of a wall were to be removed, the layers above would literally collapse, and that&#8217;s exactly what would happen in knowledge dependency layering. The layers above literally need the knowledge of abstractions in lower layers to make any sense.</p>
</div>
<div class="paragraph">
<p>ALA&#8217;s ripple effects are already under control because the only dependencies are on abstractions, which are inherently stable, and furthermore, those abstraction must be more abstract. However, to make these dependencies even less likely to cause an issue during maintenance, we try to make the abstraction layers discrete, and separated by approximately an order of magnitude. In other words each layer is approximately an order of magnitude more abstract than the one above it. More abstract means more ubiquitous, so the layers contain abstractions which have greater scope, and greater potential reuse as you go down the layers.</p>
</div>
<div class="paragraph">
<p>We won&#8217;t need many layers. If you think about abstraction layers in the real world, we can get from atoms to the human brain in four layers. Remember the creativity cycle early in this article. We only need to go around the cycle four times to make a brain: Atoms, Molecules such as proteins, Cells such as neurons, neural nets, and finally the brain itself.</p>
</div>
</div>
<div class="sect3">
<h4 id="truethe-four-layers"><a class="anchor" href="#truethe-four-layers"></a>7.11.2. The four layers</h4>
<div class="paragraph">
<p>We start with four layers. They have increasing scope as you go down. This type of layering was described by Meiler Page-Jones. Meiler Page-Jones’ names for the four layers are: "Application domain", "Business domain", "Architecture domain", and "Foundation domain".</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/Layers.png" alt="Layers.png" width="75%">
</div>
<div class="title">Figure 53. Four ALA layers</div>
</div>
<div class="paragraph">
<p>ALA uses slightly different names: Application layer, Domain Abstractions layer, Programming Paradigms layer, and Language layer.</p>
</div>
<div class="sect4">
<h5 id="trueapplication-layer-4"><a class="anchor" href="#trueapplication-layer-4"></a>Application layer</h5>
<div class="paragraph">
<p>The top layer has knowledge specific to the application, and nothing but knowledge specific to the application, i.e. representing your requirements.</p>
</div>
<div class="paragraph">
<p>A simple Application might wire a grid directly to a table. When Business logic is needed, any number of decorators (that do validation, constraints, calculations, filtering, sorting, etc.) can be inserted in between the grid and the table by changing the wiring of the application.</p>
</div>
</div>
<div class="sect4">
<h5 id="truedomain-abstractions-layer-3"><a class="anchor" href="#truedomain-abstractions-layer-3"></a>Domain abstractions layer</h5>
<div class="paragraph">
<p>Knowledge specific to the domain goes in this layer. A domain might correspond to a company or a department. As such, teams can collaborate on the set of abstractions to be provided there.</p>
</div>
<div class="paragraph">
<p>Applications have knowledge dependencies reaching into this layer.</p>
</div>
</div>
<div class="sect4">
<h5 id="trueprogramming-paradigms-layer-3"><a class="anchor" href="#trueprogramming-paradigms-layer-3"></a>Programming Paradigms layer</h5>
<div class="paragraph">
<p>All knowledge specific to the types of computing problems you are solving, such as execution models, programming paradigm interfaces and any frameworks to support these, is in this layer.</p>
</div>
<div class="paragraph">
<p>The Programming Paradigms layer will abstract away how the processor is managed to execute different pieces of code at the right time. Execution models are covered in detail in chapter four.</p>
</div>
<div class="paragraph">
<p>This layer is also where we arrange for our domain abstractions to have common simple connections instead of having a specific language for each pair of modules that communicate. The Programming Paradigms layer abstracts away ubiquitous communications languages (which we have been referring to as programming paradigms in this article.)</p>
</div>
<div class="paragraph">
<p>Let&#8217;s use the clock as a real world example. (This is the same clock example we used in section 2.9 when introducing the role abstractions play in the creative process.) One of the the domain abstractions for clocks is a cog wheel. Cog wheels communicate with one another. But they don&#8217;t do it with communications languages specific to each pair, even though each pair must have the correct diameters and tooth sizes to mesh correctly. The cog abstraction just knows about the common paradigm of meshing teeth, a more abstract language in this lower layer. This language is analogous to a programming paradigm. With it, the clock abstraction (which is in the highest layer) can then instantiate two cogs and configure them to mesh. The concept of cog thus remains an abstraction and instances of it are composable. The clock, which already knows that two instances of cogs are needed, also knows where they will be fitted and what their diameters must be. The knowledge in the clock abstraction is cohesive.</p>
</div>
</div>
<div class="sect4">
<h5 id="truelanguage-layer"><a class="anchor" href="#truelanguage-layer"></a>Language layer</h5>
<div class="paragraph">
<p>The language layer is included to show what is below the other three layers. It is not hardware as you would find in many other layering schemes, nor is it a database, because it is not run-time dependencies we are layering. The lowest layer has the remaining knowledge you need to understand your code, that of the languages, libraries and any very generic APIs you may use.</p>
</div>
<div class="paragraph">
<p>The hardware and database do have a place, but we will cover it later. Being a run-time dependency, it will be well off to one side and slightly higher up.</p>
</div>
</div>
<div class="sect4">
<h5 id="truedomain-abstractions-api"><a class="anchor" href="#truedomain-abstractions-api"></a>Domain Abstractions API</h5>
<div class="paragraph">
<p>The boundary between the application layer and the domain abstractions layer is an API that supports the solution space of your requirements (within the constraints of your domain).</p>
</div>
<div class="paragraph">
<p>The scope of the Domain Abstractions layer defines the expressiveness available to the application. The greater the scope (or bigger the domain), the more applications are able to do. The cost is expressiveness. The applications will have to be longer to specify what is to be done. Conversely, a smaller domain allows less versatility in the applications, but there is greater expressiveness, which means you write less code.</p>
</div>
</div>
<div class="sect4">
<h5 id="truepossible-extra-layers"><a class="anchor" href="#truepossible-extra-layers"></a>Possible extra layers</h5>
<div class="paragraph">
<p>The domain is an approximation of all the potential applications and all the modifications you are likely to make. If the domain is large because it is enterprise wide, you could have an additional layer for small domains. The enterprise domain would include enterprise wide abstractions such as a person identity, and the smaller domains would add additional, more specific abstractions, such as a customer (by composition).</p>
</div>
<div class="paragraph">
<p>If the applications are large and themselves need to be composed of features, an additional layer that supports plug-in style abstractions may work well. Plug-in abstractions may actually be instances of domain abstractions, such as a settings Menu, or a customer Table. A feature can then add settings to the menu, or columns to the table that remain unknown to any other features.</p>
</div>
</div>
<div class="sect4">
<h5 id="trueprogramming-paradigms-api"><a class="anchor" href="#trueprogramming-paradigms-api"></a>Programming Paradigms API</h5>
<div class="paragraph">
<p>The boundary between all higher layers and the Programming Paradigms layer is another API. It separates the domain knowledge from the programming paradigm implementation knowledge. It almost always takes care of the ‘execution flow’, the way the computer CPU itself will be controlled to execute all the various parts of the code and when, often using a framework. On the other hand, the Programming Paradigms layer doesn’t necessarily have any code at all. Remember that the layers are ‘knowledge dependencies’, not run-time dependencies, so the paradigm could be a ‘computational model’ that just provides the knowledge of patterns of how to constracut the code in higher layers. The decisions about use of the patterns and about the way the code is executed have already been made and exist in the Programming Paradigms layer.</p>
</div>
</div>
<div class="sect4">
<h5 id="truerate-of-change-of-knowledge"><a class="anchor" href="#truerate-of-change-of-knowledge"></a>Rate of change of knowledge</h5>
<div class="paragraph">
<p>The knowledge in each of the four layers has different change rates.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The Language layer contains knowledge that will likely change only a few times in your career.</p>
</li>
<li>
<p>The Programming Paradigms layer knowledge changes when you move to different computing problems types, or discover different approaches to solving a broad range of problems. For example, if you have not yet used an event driven execution model or state machines in your career, and you move into the embedded systems space, you will very likely need to have those skills.</p>
</li>
<li>
<p>The Domain Abstractions layer has knowledge that changes when you change the company you work for. It will change at the rate that the company&#8217;s domain is changing, or is becoming better understood. If your company uses lean principles, one of the things you want to do is capture knowledge for reuse. This is the whole point of the Domain Abstractions layer, it is a set of artefacts that capture the company&#8217;s reusable knowledge.</p>
</li>
<li>
<p>The Application layer has the fastest changing knowledge, the knowledge that changes at the rate that an application gets maintained.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="truecomposition-versus-decomposition"><a class="anchor" href="#truecomposition-versus-decomposition"></a>7.12. Composition versus decomposition</h3>
<div class="paragraph">
<p>Here we revisit the important idea introduced in chapter 3 to do with the pitfalls of thinking in terms of hierarchical decomposition.</p>
</div>
<div class="paragraph">
<p>In decomposition methods, we are taught to decomposes the system into smaller elements or components with relations between them. Then decompose those into still smaller ones. The process continues until the pieces are simple enough to understand and implement. Each decomposition artefact is completely contained inside its parent artefact, so it forms a hierarchical encapsulation structure.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p><span class="red"><strong>Decomposition</strong></span> of the <span class="red"><strong>system</strong></span> into <span class="red"><strong>elements</strong></span> and their <span class="red"><strong>interactions</strong></span>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The decomposition approach is often the de facto or informal method used by developers because it is encouraged by many architecture styles and patterns, for example components or MVC. It is the method used in ADD (Attribute Driven Design). Indeed some definitions of software architecture sound like this meme:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>From Wikipedia quoting from Clements, Paul; Felix Bachmann; Len Bass; David Garlan; James Ivers; Reed Little; Paulo Merson; Robert Nord; Judith Stafford (2010:</p>
<div class="literalblock">
<div class="content">
<pre>"Each structure comprises software elements, relations among them, and properties of both elements and relations."</pre>
</div>
</div>
</li>
<li>
<p>IBM.com</p>
<div class="literalblock">
<div class="content">
<pre>"Architecture is the fundamental organization of a system embodied in its components, their relationships to each other, and to the environment, and the principles guiding its design and evolution. [IEEE 1471]</pre>
</div>
</div>
</li>
<li>
<p>synopsys.com</p>
<div class="literalblock">
<div class="content">
<pre>"Architecture also focuses on how the elements and components within a system interact with one another."</pre>
</div>
</div>
</li>
<li>
<p>From an article on coupling by Martin Fowler  <a href="https://www.martinfowler.com/ieeeSoftware/coupling.pdf" class="bare">https://www.martinfowler.com/ieeeSoftware/coupling.pdf</a></p>
<div class="literalblock">
<div class="content">
<pre>"You can break a program into modules, but these modules will need to communicate in some way—otherwise, you’d just have multiple programs."</pre>
</div>
</div>
</li>
<li>
<p>Loose coupling and high cohesion</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The "loose coupling and high cohesion" meme suggests that loose coupling is the best we can do. We are told that modules or components must collaborate in some way. It seems reasonable and even self-evident. So why is it completely wrong? It&#8217;s because we are thinking in terms of decomposition. There is another way - composition.</p>
</div>
<div class="paragraph">
<p>To be fair, some of the examples above are vague enough to be interpreted in either way. But all are misleading in that they are suggestive of the idea of decomposition.</p>
</div>
<div class="paragraph">
<p>To fix the problem, we should re-word the meme:</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p><span class="green"><strong>Expression</strong></span> of the <span class="green"><strong>requirements</strong></span> by <span class="green"><strong>composition</strong></span> of <span class="green"><strong>abstractions</strong></span>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>All four big words are changed and some are exact opposites. Indeed, the architecture that comes out of this method is "inside out" when compared to the decomposition method.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s contrast two pseudo-structures: one that results from the decomposition approach and one that results from the composition approach.</p>
</div>
<div class="sect3">
<h4 id="truedecomposition-of-the-system-into-elements-and-their-interactions"><a class="anchor" href="#truedecomposition-of-the-system-into-elements-and-their-interactions"></a>7.12.1. Decomposition of the system into elements and their interactions</h4>
<div class="paragraph">
<p>This diagram shows a decomposition structure. The outer box is the system. It shows decomposition into four elements, and then those in turn are decomposed into four elements each.</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="images/Slide11.jpg" alt="Slide11.jpg">
</div>
<div class="title">Figure 54. Decomposition Structure</div>
</div>
<div class="paragraph">
<p>The outer elements correctly only refer to the outer interface of the components - their package or namespace interface, facade, or aggregate root - however you want to think of it. Encapsulation is used at every level of the structure to hide implementation details.</p>
</div>
<div class="paragraph">
<p>The elements are labelled with numbers to emphasise that they are not good abstractions. Of course, in practice these elements have a name.</p>
</div>
<div class="paragraph">
<p>The next diagram shows the same structure but with parts relevant to a user story marked in red. This is the "their interactions" part of the "The decomposition of your system into elements and their interactions".</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="images/Slide13.jpg" alt="Slide13.jpg">
</div>
<div class="title">Figure 55. Tracing a User story</div>
</div>
<div class="paragraph">
<p>The diagram shows both decomposition relationships (boxes inside boxes) and interaction relationships (lines).</p>
</div>
</div>
<div class="sect3">
<h4 id="trueexpression-of-the-requirements-by-composition-of-abstractions"><a class="anchor" href="#trueexpression-of-the-requirements-by-composition-of-abstractions"></a>7.12.2. Expression of the requirements by composition of abstractions</h4>
<div class="paragraph">
<p>This diagram shows a composition structure.</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="images/Slide14.jpg" alt="Slide14.jpg">
</div>
<div class="title">Figure 56. Composition Structure</div>
</div>
<div class="paragraph">
<p>Only 'composition' relationships are present. We have shown some of them as lines even though you wouldn&#8217;t normally draw them. For example, the one from <span class="underline">c</span> to C. In practice we wouldn&#8217;t normally draw a diagram like this at all - the abstractions would be just referred to by name. But here we are trying to make a combined diagram of the meta-architecture and the specific architecture. The meta-architecture is the three layers, and the knowledge dependencies that go from the higher layers to the lower layers. The specific architecture consists of the diagrams inside the user stories in the top layer, the specific composition of instances.</p>
</div>
<div class="paragraph">
<p>Note that although we use lines in the diagrams in the top layer, those lines do not represent dependencies.</p>
</div>
</div>
<div class="sect3">
<h4 id="truecomparison-of-the-two-approaches"><a class="anchor" href="#truecomparison-of-the-two-approaches"></a>7.12.3. Comparison of the two approaches</h4>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 2. Comparison of Decomposition vs Composition approaches</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Decomposition</th>
<th class="tableblock halign-left valign-top">Composition</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="image"><img src="images/Slide13.jpg" alt="Decomposition structure" title="Tracing a User story"></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="image"><img src="images/Slide14.jpg" alt="Decomposition structure" title="Composition Structure"></span></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Hierarchical (fractal) structure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Layered structure</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Elements become less abstract as you zoom in. They are specific parts of specific parts. They have no use in another part of the decomposition.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Parts become more abstract as you go down the layers. They are reusable in many parts of the application.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Elements have no use in another part of the application.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Elements are reusable in many parts of the application.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Hides details through encapsulation, which works at compile-time.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Hides details through abstraction, which works at design-time.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Encapsulates abstractions</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Encapsulates instances of abstractions.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Inner parts are increasingly private. They are encapsulated in increasingly smaller scopes. These private parts still need to be known about at design-time to understand the system  (unless they happen to also be good abstractions).</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Lower layers are increasing public. Only the abstractions themselves are needed to understand the system.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Dependencies go in the direction from the outermost element to the innermost. This is the direction of less abstract and therefore less stable.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Dependencies go down the layers. This is the direction of more abstract, and therefore more stable.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Dependencies also exist between parts at the same hierarchical level</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">There are no dependencies between abstractions at the same layer.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Encourages the same element to be used for both abstraction and instance - often called a module or component.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Clearly has two distinct types of elements - abstractions and instances.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Elements are loosely coupled.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Abstractions are zero coupled.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Discourages reuse. 16 elements all different from each other.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Encourages reuse. Only 5 abstractions. 16 instances of those five abstractions.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SMITA - Structure missing in the action. If you are interested in a particular user story, you will typically have to trace it through multiple elements, multiple interfaces, and their interactions across the structure. An example of this is shown by the diagram with the red lines.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Eliminates this problem. The structure is explicit and in one place.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Coupling increases during maintenance. This is because details are not hidden inside abstractions, only encapsulations. Any of them can be needed at any time by an outer part of the structure. So as maintenance proceeds, more of them will need to be brought into the interfaces, increasing the coupling as time goes on.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Coupling remains at zero during maintenenace. Abstractions represent ideas, and ideas are relatively stable even during maintenance. All the dependencies are relatively unaffected.  An operation called generalizing an abstraction is sometimes done. This increases the versatility, reuse and ubiquity of abstractions over time.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Complexity increases as the system gets larger.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The complexity stays constant as the system gets larger. Each abstraction is its own stand-alone program. If we choose an ideal granularity of say 200 lines of code, the complexity in any one part of the program is that of 200 lines of code.</p></td>
</tr>
</tbody>
<tfoot>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">The maintenance cost (effort per user story or effort per change) increases over time. This is because complexity is increasing. Changes will tend to have ripple effects, but that isn&#8217;t the biggest problem. Even if a change ends up being in one place, reasoning about the system to determine where that change should be can require reasoning across the system.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The maintenance cost reduces as the system grows. This is because as the domain abstractions mature, the user stories become less and less work to do - they simply compose, configure and wire together instances of existing domain abstractions.</p></td>
</tr>
</tfoot>
</table>
</div>
<div class="sect3">
<h4 id="truetransforming-a-decomposition-structure-into-a-composition-structure"><a class="anchor" href="#truetransforming-a-decomposition-structure-into-a-composition-structure"></a>7.12.4. Transforming a decomposition structure into a composition structure</h4>
<div class="ulist">
<ul>
<li>
<p>The structure turns inside out. Abstractions are found in the inner-most encapsulations. These are brought out to be made public, reusable, ubiquitous and stable at the domain abstractions layer.</p>
</li>
<li>
<p>The parts of the inner encapsulations that are specific to the application are factored out to become configuration information in the application layer, which it uses when instatiating abstractions.</p>
</li>
<li>
<p>Dependencies that existed between encapsulated elements for run-time communications are eliminated. They become simple wiring up of instances inside the application.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="truesmells-of-decomposition"><a class="anchor" href="#truesmells-of-decomposition"></a>7.12.5. Smells of decomposition</h4>
<div class="ulist">
<ul>
<li>
<p>Hierarchical diagrams</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The tell-tale sign that this is happening is when we draw hierarchical diagrams. Boxes contained inside boxes. Even if we don&#8217;t draw them that way, the 'containment' or encapsulation is still implied. This is what package and component diagrams do. ALA has no use for package diagrams in the logical view. (However, they are still relevant in other views. There are several good reasons to have separately deployable binary code units such as exes or dlls.)</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The dependency graph has many levels</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If you have avoided circular dependencies, your application can be viewed as a (compile-time) dependency graph. Because it has run-time dependencies, it will have many 'levels'. These are not the hierarchical encapsulation levels, but just the strings of run-time dependencies within each level. In a composition system, the dependency graph will have a low number of layers.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Encapsulation without abstraction</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Encapsulating details without an abstraction causes module or component boundaries to look relatively transparent at design-time. Their interfaces will tend to be specific to pairs of modules, and will tend to get increasingly wide as the software life cycle proceeds.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Modules have responsibility for who they communicate with</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Either the sender knows who to send messages to, or, if using publish/subscribe, the receiver knows who to receive messages from. Understanding the system requires reading inside the parts to get the interconnection knowledge.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Compile-time indirection</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If you find yourself doing many 'all files' searches to trace the flow of data or execution, this is a decomposition smell. The connections between the decomposed elements are mostly in the form of direct function calls or new keywords, and the name of another module. You have to find all these symbolic connections to trace through the system. In a composed structure, these connections are just adjacent elements in the text, or lines on a diagram. In both cases they are annonymous.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Run-time indirection</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To avoid circular dependencies, many of the Compile-time indirections would have been changed to run-time indirections. This is often done using observer pattern of automatic dependency injection.</p>
</div>
<div class="paragraph">
<p>There is a meme that says something to the effect that such indirection is a two edged sword. On one hand it reduces coupling but on the it makes the structure even harder to see than it was when you has 'all files' searches. You may have to resot to a run-time debugger to see where the bugger goes next. At first this seems reasonable. It seems that you must always have this compromise between explicit structure and loose coupling. However it is just a result of decomposition., and unnecessary.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>In ALA, there is no conflict between indirection and an explicit structure.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In a composition structure, at the top layer, all the structure is explicit in the form of the wiring. This is where all the design-time knowledge about the interactions between instances belongs, and where you can trace messages through the system at design-time with neither 'all files' searches, nor a debugger. When a message is processed by an instance of an abstraction, you know what that abstraction is supposed to do. You can tell if an issue is in the application or if an abstraction is not doing what is expected of it.</p>
</div>
<div class="paragraph">
<p>When you drop down inside an abstraction, you are now in a different program, bordered by its inputs and outputs. You don&#8217;t need to know where the execution flow goes outside its I/O ports to understand how it works because an abstraction has no knowledge of anything outside. If the abstraction calculates the squareroot and doesn&#8217;t do it correctly, you only need to debug to its interfaces.</p>
</div>
<div class="paragraph">
<p>ALA overturns the conventional meme about <em>decomposition into elements and their relations</em>. It is unnecessary to write software that way. The only relationship that remains is the 'use of an abstraction'. This is, of course, a dependency but it is a good dependency. We will discuss from the point of view of good and bad dependencies in a later section. For now, dependencies are good if we want more of them. The more of them the better. For example if you have a library function or class, say squareroot, the more it is used the better, because the more useful the library function must have been. This type of dependency, the 'use of an abstraction', is the only one you need to build a system.</p>
</div>
<div class="paragraph">
<p>If the domain were for building model toys, the non-ALA method would start with the imagined toy and decompose it into parts specific to that one toy. The solution would be brittle and hard to change and no other toys would be possible without the same huge effort all over again. The ALA method is Lego. You invent a finite set of abstract building blocks and the mechanisms by which they connect. Then the initial toy can be easily changed, and other toys are possible with the same abstractions.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="true41-views"><a class="anchor" href="#true41-views"></a>7.13. 4+1 views</h3>
<div class="sect3">
<h4 id="truelogical-view"><a class="anchor" href="#truelogical-view"></a>7.13.1. Logical view</h4>

</div>
<div class="sect3">
<h4 id="truedevelopment-view"><a class="anchor" href="#truedevelopment-view"></a>7.13.2. Development view</h4>

</div>
<div class="sect3">
<h4 id="trueprocess-view"><a class="anchor" href="#trueprocess-view"></a>7.13.3. Process view</h4>

</div>
<div class="sect3">
<h4 id="truephysical-view"><a class="anchor" href="#truephysical-view"></a>7.13.4. Physical view</h4>
<div class="paragraph">
<p>If the system is deployed on multiple machines (this is the subject of the physical view), the ALA abstractions, layers and diagrams all remain identical.</p>
</div>
<div class="paragraph">
<p>Ideally, the performance view also does not affect the ALA logical view. This is a many faceted problem that we will return to later.</p>
</div>
<div class="paragraph">
<p>ALA usually works very well with aspects of the development view as discussed elsewhere. For example, the fact that domain abstractions have zero coupling greatly helps the allocation of teams. The teams need only cooperate on a common understanding of the programming paradigms used.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="trueno-separation-of-ui"><a class="anchor" href="#trueno-separation-of-ui"></a>7.14. No separation of UI</h3>
<div class="paragraph">
<p>In ALA we don&#8217;t separate the UI unless there is a reason to do so. The amount of knowledge in the UI that comes from a particular application&#8217;s requirements is usually quite small and that knowledge is usually quite cohesive and coupled with the business logic of the feature it belongs with. For example, the layout of the UI is a small amount of information, and the bindings of the UI elements to data are a small amount of information. So all that cohesive knowledge is kept together, encapsulated inside a feature. Instead, the UI is composed from Domain UI abstractions. Being domain specific, these abstractions have a little more knowledge to them than generic widgets. For example, their domain knowledge may include style, functionality and suitability to their domain context. For example, a softkey or menu item will have an appearance, functionality and suitability to the way UIs are designed in the domain. Using one in a specific application only requires a label and a binding to an action. They will also provide consistency in the domain.</p>
</div>
<div class="paragraph">
<p>If there is an actual requirement to have different UIs, say a command based UI and a GUI based UI, then you just abstract the UI abstractions further until they can be used either way. The UI abstractions still remain an integral part of the application.</p>
</div>
<div class="paragraph">
<p>In the example project for this chapter, we will for the first time use multiple programming paradigms, a usual thing in real ALA projects.</p>
</div>
</div>
<div class="sect2">
<h3 id="truefeatures"><a class="anchor" href="#truefeatures"></a>7.15. Features</h3>
<div class="paragraph">
<p>You may have noticed throughout this article the word 'features' being used quite often instead of 'Application'. When the application is large, we can think of it as a composition of feature abstractions. This is exactly what happens in natural language in the domain when describing requirements. 'Features' is just the word we give the natural abstractions in the requirements, without even realizing it. Just go with this in the software itself.</p>
</div>
</div>
<div class="sect2">
<h3 id="trueinheritance"><a class="anchor" href="#trueinheritance"></a>7.16. Inheritance</h3>
<div class="paragraph">
<p>ALA doesn&#8217;t use inheritance because in the real world things are composed of other things. The only place inheritance occurs is in the tree of life. The down sides of inheritance are well documented. The indirect (virtual) method calls (polymorphism) when indirection is not required makes programs hard to follow. ALA of course uses polymorphism in the extreme (by its use of abstract interfaces as programming paradigms), but its always used when going up an abstraction level and never used to replace what should be explicit wiring.</p>
</div>
<div class="paragraph">
<p>I get the impression that most inheritance is lazy coding of what is really  composition. For example, several abstractions, B, C, D are using another abstraction A. A client using say B makes a method call. The execution of the method is not overridden by B. Using inheritance, the call goes directly to A even though the call was made on object B. B doesn&#8217;t need any code that effectively says it has nothing to add. Using composition, B must handle the call first, and then pass the call through to A. This is extra code in B, C and D if none of them have any differences to add. In ALA we add this extra code in B, C and D, so no virtual methods  (indirections) are involved and everything is explicit.</p>
</div>
<div class="paragraph">
<p>There is a potential use for inheritance in ALA. Abstractions can change over time and have versions. The open-closed principle asks us to allow for these changes without changing old code.</p>
</div>
<div class="paragraph">
<p>This is analogous to the case of inheritance that occurs in nature. We like to see modern species as differences with older common ancestors. We may want to represent code in the same way as old form + differences.</p>
</div>
<div class="paragraph">
<p>This is a highly dubious concept in my opinion because it is not sustainable. As the number of subclasses pile on top of each other over time, the old form + differences way of looking at it will seem less and less relevant. It&#8217;s a bit like the eventual mess that results from always using #ifdefs for modifications to C code. The #ifdefs are great at the time when the focus is on the differences, but those differences become unimportant later.</p>
</div>
<div class="paragraph">
<p>That said, we could invent a <em>view</em> to add to the 4+1 views that specifies the versions of every abstraction used in each application. Newer versions of every abstraction may become available, and this view can be changed when it is time to update a particular application to use the latest abstractions (when there is time to test it). The application itself doesn&#8217;t change, but the new view causes it to instantiate specified new versions. Since there may be a long period of deprecation of old abstractions, we may want to represent new versions as differences. Eventually when the old version is fully deprecated, it would be integrated into the next version up.</p>
</div>
<div class="paragraph">
<p>To achieve this the application code would not use <em>new</em> itself. Instead every abstraction would include a factory. The factory would read information from the new view and return the correct version. Note that even this scenario doesn&#8217;t require inheritance. The difference abstraction may just be composed of the older unchanged abstraction.</p>
</div>
<div class="paragraph">
<p>This is a topic for future research.</p>
</div>
</div>
<div class="sect2">
<h3 id="truehorizontal-domain-partitions"><a class="anchor" href="#truehorizontal-domain-partitions"></a>7.17. Horizontal domain partitions</h3>
<div class="paragraph">
<p>Say you are implementing a particularly large domain abstraction such as a 'Table', or are implementing a complicated programming paradigm. We would like to break these up into smaller components. Do we introduce a fractal type of structure to deal with this? Should we have hierarchical layers within layers contained completely inside the Table abstraction?</p>
</div>
<div class="paragraph">
<p>The astute reader will have noticed the non-ALA thinking in the statement "break these up into smaller components". In ALA we don&#8217;t decompose a large abstraction into components, we compose it from abstractions, which if necessary we invent as we go. These new abstractions will have a scope or level of ubiquity, stability and reuse that corresponds to one of the existing layers. So there should be no hierarchical or fractal structures in ALA.</p>
</div>
<div class="paragraph">
<p>However, the domain that these new abstractions are in won&#8217;t be the same domain as the one that provides for the writing of Application requirements. For example, the implementation of the Table abstraction will need to be connected to another abstraction in the domain of databases. One of the abstractions in that domain will know about a particular database, say SQL Lite. A polymorphic interface should exist between the two. That interface, being more abstract than either the Table or the SQL Lite abstractions, will be in the next layer down, where both the Table and the MySQL abstractions can have a knowledge dependency on it. Of course the SQL abstraction will actually be further composed of an adapter and a real database.</p>
</div>
<div class="paragraph">
<p>Some application domain abstractions are complicated. Examples of these are abstractions requiring a connection to an actual database, actual hardware, the Internet, etc. Implementing these will typically wire out horizontally into other technical domains. You can visualise them going in multiple directions, which is exactly the idea of Alistair Cockburn&#8217;s hexagonal architecture.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/diagram-22.png" alt="diagram 22">
</div>
</div>
<div class="paragraph">
<p>A communications domain using a OSI model may end up with a whole chain of communications domain abstractions going sideways:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/diagram-23.png" alt="diagram 23">
</div>
</div>
<div class="paragraph">
<p>The technicalities may be incorrect but the diagram gives the idea of how the OSI 'layers', which are just run-time dependencies, would fit into the ALA layers.</p>
</div>
</div>
<div class="sect2">
<h3 id="trueno-hierarchical-design"><a class="anchor" href="#trueno-hierarchical-design"></a>7.18. No hierarchical design</h3>
<div class="paragraph">
<p>ALA does not use any form of hierarchical structure. Instead it uses abstraction layers, together with "Horizontal domain partitions" discussed earlier.</p>
</div>
</div>
<div class="sect2">
<h3 id="truedomain-oriented"><a class="anchor" href="#truedomain-oriented"></a>7.19. Domain oriented</h3>
<div class="paragraph">
<p>As has been found useful in other methodologies such as Domain Specific Languages, Domain Driven Design, Model Driven Software Development and Language Oriented Programming, ALA provides a way to be 'domain oriented'.</p>
</div>
<div class="paragraph">
<p>But unlike most of the other domain oriented methodologies, ALA provides a way to be domain oriented with ordinary code, and with the same development environment. It is just a way to organise ordinary code to be domain oriented.</p>
</div>
</div>
<div class="sect2">
<h3 id="trueproduct-owner-perspective"><a class="anchor" href="#trueproduct-owner-perspective"></a>7.20. Product owner perspective</h3>
<div class="paragraph">
<p>TBD</p>
</div>
</div>
<div class="sect2">
<h3 id="truereuse"><a class="anchor" href="#truereuse"></a>7.21. Reuse</h3>
<div class="paragraph">
<p>TBD</p>
</div>
</div>
<div class="sect2">
<h3 id="truedocumentation"><a class="anchor" href="#truedocumentation"></a>7.22. Documentation</h3>
<div class="paragraph">
<p>TBD</p>
</div>
</div>
<div class="sect2">
<h3 id="truesymbolic-indirection"><a class="anchor" href="#truesymbolic-indirection"></a>7.23. Symbolic indirection</h3>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Avoid use of symbolic indirection without abstraction
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>When we start assembling requirements from abstractions, a topic that we will cover in coming sections, we will be using symbolic indirection, such as function calls or the new keyword with a class name. Unless a symbolic indirection is to an abstraction, they are for the compiler to follow at compile-time, not for the code reader to follow at design-time. Understanding the code relies on allowing the reader to read a small cohesive block of code. The reader should never have to follow the indirection somewhere else. If you don&#8217;t achieve this, and abstraction is the only way you can, then any decoupled architecture will be <em>more</em> difficult to read.</p>
</div>
<div class="paragraph">
<p>Abstraction allows indirection while allowing the reader to continue reading on to the next line. The importance of this property cannot be overstated. As soon as we start thinking in mere programming language terms of modules, components, interfaces, classes, or functions, the abstraction will start to be lost. These other artefacts may have benefits at compile-time (the compiler can understand them), but that is not useful at design-time unless they are also good abstractions.</p>
</div>
<div class="paragraph">
<p>It would be nice if your compiler could tell you that you have a missing abstraction, just as it does for a missing semicolon, but alas, they are not capable of understanding abstractions yet. So it is still entirely up to you.</p>
</div>
<div class="paragraph">
<p>Abstraction is almost a black and white type of property. It&#8217;s either there or it isn&#8217;t. If the reader of your code does not have to follow the indirection, you have it.</p>
</div>
<div class="paragraph">
<p>Footnote: When the reader of your code meets your abstraction for the first time (usually a domain abstraction in a domain they have recently come into), ideally their IDE will give them the meaning in a little pop-up paragraph as their mouse hovers over any of its uses. Depending on the quality of the abstraction, after a single exposure, their brain will have the insight, like a light coming on, illuminating a meaning. The brain will form a new neuron to represent the concept. Since the reader will hopefully remain in the domain for some time, this overhead to readability shouldn&#8217;t be large.</p>
</div>
</div>
<div class="sect2">
<h3 id="trueeverything-through-interfaces"><a class="anchor" href="#trueeverything-through-interfaces"></a>7.24. Everything through interfaces</h3>
<div class="paragraph">
<p>A class, in contrast to an abstraction, has an interface comprising all the public members. In ALA we only want this interface to be used by the application when it instantiates and configures an instance of an abstraction. All other inputs and outputs that are used at run-time are done through interfaces (abstract interfaces).</p>
</div>
</div>
<div class="sect2">
<h3 id="truewhat-do-you-know-about"><a class="anchor" href="#truewhat-do-you-know-about"></a>7.25. What do you know about?</h3>
<div class="paragraph">
<p>Whenever I have only two minutes to give advice on software architecture, I use this quick tip. The tip is ALA reduced to its most basic driving principle.</p>
</div>
<div class="paragraph">
<p>Ask your modules, classes and functions:</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p><span class="green"><strong>What do you <em>know</em> about?</strong></span></p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The answer should always be "I just know about&#8230;&#8203;".</p>
</div>
<div class="paragraph">
<p>The anthropomorphization helps the brain to see them as abstractions. The word 'knows' is carefully chosen to imply a 'design-time' perspective.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>It&#8217;s a restatement of the SRP (Single Responsibility Principle). Every element should know about one thing, one coherent thing. Furthermore, no other elements should know about this one thing.</p>
</li>
<li>
<p>An element may know about a single hardware device.</p>
</li>
<li>
<p>An element may know about a user story.</p>
</li>
<li>
<p>An element may know about a protocol.</p>
</li>
<li>
<p>An element may know an algorithm.</p>
</li>
<li>
<p>An element may know how to do an operation on some data, or the meaning of some data, but not both.</p>
</li>
<li>
<p>An element may know a composition of other elements.</p>
</li>
<li>
<p>An element may know where dataflows between other elements.</p>
</li>
<li>
<p>No element should know the source or destination of its inputs and outputs.</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="trueexample-project-a-real-device"><a class="anchor" href="#trueexample-project-a-real-device"></a>7.26. Example project - a real device</h3>
<div class="paragraph">
<p>Unlike our previous example projects, this project is a real device and had previously been implemented without any knowledge of ALA. So this example serves to make comparisons between ALA and conventional software development. The original software was around 200 KLOC and took 3 people 4 years to write.</p>
</div>
<div class="paragraph">
<p>The actual device is used by farmers all over the world. It can weigh livestock and keeps a database about them for use in the field. It connects to many other devices and has a large number of features:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/Tru%20Test%20XR5000%20Weigh%20Scale%20Indicator.jpg" alt="Tru Test XR5000 Weigh Scale Indicator.jpg" width="75%">
</div>
<div class="title">Figure 57. Livestock weighing indicator</div>
</div>
<div class="paragraph">
<p>The architecture in the original software, was somewhat typically organised into modules and patterns by its developers. Also somewhat typically, it had ended up with a high cost of modifiability - a big ball of mud. After the first release, the first incremental requirement was a 'Treatments' feature, which involved several new tables, new columns in existing tables, new data pages, new settings pages and some new business logic. This feature took a further 3 months to complete (actually 6 calendar months), which seemed out of proportion for the size of the feature. Somehow the Product Owner and managers seemed to have a sort of intuition that if similar things had been done before, such as menus or database tables, those things were already done, and the only new work was in the specific details of the new requirements. Those requirements could be communicated in a relatively short time, say of the order of one hour or one day if you include follow up discussions of abnormal scenarios.  So 6 months did not go down well. ALA, of course, works in exactly this intuitive way that managers hope for. All the things already done are sitting there in the domain abstractions, waiting to be reused, configured and composed into new requirements.</p>
</div>
<div class="sect3">
<h4 id="trueiteration-zero-2"><a class="anchor" href="#trueiteration-zero-2"></a>7.26.1. Iteration zero</h4>
<div class="paragraph">
<p>During the development, there had a been a high number of changes required to the UI. It occurred to me at the time that the underlying elements of the UI were not changing. It was mainly the details of layout and navigation around the device&#8217;s many pages that were changing. The same could be said about the data and business logic. Only details were changing.</p>
</div>
<div class="paragraph">
<p>I took to representing the new designs using box and line drawings representing both the UI layouts and the navigation flows. I realized these diagrams were potentially executable, and wondered how far I could go representing the data and business logic in the same way. I decided to try to represent all of the functionality of the indicator in just one  diagram.</p>
</div>
<div class="paragraph">
<p>It took two weeks to complete the diagram. I used Xmind because it laid itself out. I found that any drawing package that needed you to stop and do housekeeping such as rearranging the layout got in the way so much that you would lose your flow. Xmind allowed me to just enter in the nodes and it would automatically wire them in as either peers or chains and lay them out. The one disadvantage was that Xmind only does trees, so any cross tree relations had to be done manually, but this was also very quick in Xmind once you were used to it. I just let the cross wiring form arcs across parts of the tree.</p>
</div>
<div class="paragraph">
<p>Progress was extremely rapid once you had the abstractions and paradigms you needed. And many of them were obvious: softkeys, pages, grids, menus, actions, navigate-action, tables. etc. The programming paradigms would pop into play as needed. After the obvious UI-layout and navigation-flow ones came dataflow and dataflow of table types, events, and schema. The user of this device could set up custom fields, so the schema itself partially came from another  table. At times I would get stuck not knowing how to proceed. The longest of these blocks was half a day. But every time the required abstractions or programming paradigms would firm up, and in the end anything seemed possible.</p>
</div>
<div class="paragraph">
<p>The diagram itself took shape on the right hand side of the Xmind tree. On the left side I had the invented domain abstractions and paradigm interfaces, with notes to explain them. The right side was mostly just a set of relatively independent features, but there was the odd coupling between them such as UI-navigation lines that were also present in the requirements.</p>
</div>
<div class="paragraph">
<p>The diagram contained around 2000 nodes (instances of the abstractions), which is about 1% of the size of the total original code. There were about 50 abstractions, and several paradigm interfaces.</p>
</div>
<div class="paragraph">
<p>Part of the diagram is shown below (laid out more nicely in Visio)</p>
</div>
<div class="imageblock">
<div class="content">
<a class="image" href="images/All%20Animals%20Screen%20V3.png"><img src="images/All%20Animals%20Screen%20V3.png" alt="All Animals Screen V3.png"></a>
</div>
<div class="title">Figure 58. Application diagram for the All Animals View feature</div>
</div>
<div class="paragraph">
<p>As I did the diagram, I deliberately left out anything to do with the aforementioned Treatments feature, so that I could see how easy it might have been to implement once the domain abstractions for the rest of the requirements had matured. So after the diagram was completed, I added the Treatments feature. This involved adding tables, columns to existing tables, a settings screen, a data screen, and some behaviours.  No further abstractions needed to be invented. The incremental time for the diagram additions was of the order of one hour. Obviously testing would be needed on top of that, and the 'Table' abstraction would need additional work so it could migrate itself, a function it had not needed up until this point. Although somewhat theoretical, the evidence was that we could get at least an order of magnitude improvement in incremental maintenance effort.</p>
</div>
<div class="paragraph">
<p>At first the diagram seemed too good to be true. It had an elegance all of its own. It apparently captured all of the requirements, without any implementation at all, and yet seemed potentially executable. And if it worked, application modifications of all the kinds we had been doing were going to be almost trivial.</p>
</div>
<div class="paragraph">
<p>The burning question on my mind was, is it simply a matter now of writing a class for each of these abstractions and the whole job is done?</p>
</div>
</div>
<div class="sect3">
<h4 id="truetranslating-the-diagram-to-code"><a class="anchor" href="#truetranslating-the-diagram-to-code"></a>7.26.2. Translating the diagram to code</h4>
<div class="paragraph">
<p>We hired a C++ student and proceeded with a 3-month experiment to answer this question.</p>
</div>
<div class="paragraph">
<p>It was a simple matter to translate the diagram into C++ code that instantiated the abstractions (classes), wired them together using dependency injection setters, configured the instances using some more setters, and used the fluent interface pattern to make all this straightforward and elegant. Part of the code for the diagram sample above is shown below to give you a feel for what it looked like.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>m_animalListScreen
	-&gt;wiredTo((new Softkeys())
		-&gt;wiredTo((new Softkey())
			-&gt;setTitle("History")
			-&gt;wiredTo(new Navigate(m_animalHistoryScreen))
		)
		-&gt;wiredTo((skeyOptions = new Softkey())
			-&gt;setTitle("Options")
			-&gt;wiredTo(new Menu()
				-&gt;wiredTo(new Navigate("Session...", m_sessionSummaryScreen))
				-&gt;wiredTo(new Navigate("Settings...", m_settingScreen1))
			)
		)
	)
	-&gt;wiredTo((searchField = new TextDisplayField())
		-&gt;setLabel("Search")
		-&gt;setField(VIDField = new Field(COLUMN_VID))
	)
	-&gt;wiredTo(new Grid()
		-&gt;wiredTo(columnOrder = new ColumnOrder())
		-&gt;setRowMenus((new EventHandler())
			-&gt;setEvent(EVT_KEY_ENTER)
			-&gt;wiredTo(new Menu()
				-&gt;wiredTo(new Navigate("View information for this animal", m_animalSummaryScreen))
				-&gt;wiredTo((new Action("Delete Record", AnimalsTable::DeleteRow))-&gt;wiredTo(AnimalsTable))
			)
		)
	);</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="truewriting-the-classes"><a class="anchor" href="#truewriting-the-classes"></a>7.26.3. Writing the classes</h4>
<div class="paragraph">
<p>We knew we wouldn&#8217;t have time to write all 50 classes, so we chose to implement the single feature shown below as a screen shot.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/XR5000ScreenShot.jpg" alt="XR5000ScreenShot.jpg" width="75%">
</div>
<div class="title">Figure 59. All Animals view in the weighing indicator</div>
</div>
<div class="paragraph">
<p>The student&#8217;s job was to write 12 abstractions out of the 50. These 12 were the ones used by that feature. The initial brief was to make the new code work alongside the old code (as would be needed for an incremental legacy rewrite), but the old code was consuming too much time to integrate with, so this part was abandoned.</p>
</div>
<div class="paragraph">
<p>The learning curve for the student was done as daily code inspections, explaining to him where it violated the ALA constraints, and asking him to rework that code for the next day. It was his job to invent the methods he needed in the paradigm interfaces to make the system work, but at the same time keep them abstract by not writing methods or protocols for particular class pairs to communicate. It took about one month for him to fully 'get' ALA and no longer need the inspections.</p>
</div>
<div class="paragraph">
<p>The student completed the 12 classes and got the feature working in the device. The feature included showing data from one database table in a grid, sorting, searching, softkeys, and a menu.</p>
</div>
<div class="paragraph">
<p>Interestingly, as the student completed certain abstractions that allowed parts of other features to be done, he would quickly go and write the wiring code and have the other features working as well. For example, after the softkeys, actions, navigate, and page abstractions were done, he went through and added all the softkey navigations in the entire product as this only took minutes to do.</p>
</div>
<div class="paragraph">
<p>We wanted more funding to retain the student until we had enough to do the treatments feature, and indeed all 50 abstractions with the hope of making this implementation the production code and improving our ongoing maintenance effort. But that was not to be, despite the promising result.</p>
</div>
<div class="paragraph">
<p>We have about a quarter of a data point. Some of the abstractions done were among the most difficult, for example the Table abstraction, which had to use SQL and a real database to actually work. So it is not unreasonable to use extrapolation to estimate that the total time to do all 50 abstractions would be about one person-year. That compares with the original 12 person-years.</p>
</div>
<div class="paragraph">
<p>It seems that classes that are abstractions are faster to write. This seems intuitive because you don&#8217;t have any coupling to worry about. More importantly, the two phase design-then-code methodology of ALA allows the developer not to have to deal with large scale structure at the same time as writing code. This frees the developer to go ahead and write the code for the local problem.</p>
</div>
<div class="paragraph">
<p>I believe it is beneficial for each developer to be trained to be both an architect and a developer, but just don&#8217;t ask them to do both at the same time.</p>
</div>
<div class="paragraph">
<p>This practical result combined with the theory outlined earlier in this article suggests there ought to be a large improvement in incremental maintenance effort over a big-ball-of-mud architecture.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="truechapter-eight-surrounding-topics"><a class="anchor" href="#truechapter-eight-surrounding-topics"></a>8. Chapter eight - Surrounding Topics</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="truerecursive-abstractions"><a class="anchor" href="#truerecursive-abstractions"></a>8.1. Recursive abstractions</h3>
<div class="paragraph">
<p>ALA enforces a strictly layered (non-circular) knowledge dependency structure. It encourages a small number of  abstraction layers at discrete well separated levels of ubiquity as a framework for the knowledge dependencies. This would appear to exclude the possibility of the powerful abstraction composition technique of recursion, where the meaning of an abstraction is defined in terms of itself. (Or an abstraction implementation may need knowledge of another abstraction, which in its turn has an implementation that needs knowledge of the first abstraction. This appears to require circular knowledge dependencies.</p>
</div>
<div class="paragraph">
<p>Circular knowledge dependencies happen all the time in functional programming where recursion replaces iteration. This is generally when a function needs to call itself or a class needs to use 'new' on itself. For example, a recursive descent compiler will have a function, 'statement', which will implement specific statements such as 'compound statement', 'if statement' and so on, and in those there will be a recursive call to the function, 'statement'. The following Syntax diagram represents part of the implementation of function 'statement'.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/diagram-24.png" alt="diagram 24">
</div>
<div class="title">Figure 60. Syntax Diagram showing implementation of statement using recursion</div>
</div>
<div class="paragraph">
<p>In ALA, we want to preserve the idea of clear layers defining what knowledge is needed to understand what. Resolving this dilemma could get a bit philosophical. Since abstractions are the first class artefacts of the human brain, it may be best to think about how the brain does it. The brain must actually have two abstractions with the same name but at different levels. The first is analogous to a 'forward declaration' in a language to allow a compiler to know about something that will be referred to in a more abstract way before it finds out about it in a more specific way.</p>
</div>
<div class="paragraph">
<p>By this analogy, ALA sometimes requires the concept of a forward-declared-abstraction, something that is clearly more abstract than the concrete implementations. Therefore, we can put this forward declaration in the next layer down, just as we would a paradigm interface. In the recursive descent compiler example, we would first have the abstract concept of a statement, meaning a unit of executable code as an interface in a lower layer. Then the specific abstractions, compound statement, if statement and so on are in a higher layer. They both provide and accept the interface.</p>
</div>
<div class="paragraph">
<p>Another language example is that an expression is composed of terms, a term is composed of factors, and a factor can be composed of expressions (enclosed in round brackets). If we model these compositions as direct knowledge dependencies, we would have too many layers - and they would not be becoming more abstract as we go down. The existence of the recursion at the end reinforces that. It seems that all three, expressions, terms and factors, should have abstract interface versions at a lower level.</p>
</div>
<div class="paragraph">
<p>Not all cases of recursion would require these interfaces. If, for example, in your old way of doing things there is a long chain of function calls, with the last one calling the first one, all of them are probably run-time dependencies, not knowledge dependencies at all. So in ALA, they should all be changed to be wirable, and wired together by an abstraction in a higher layer. The paradigm interface that is used to allow them to be wired  may be,for example, dataflow. So recursion does not necessarily require different interfaces for each different abstraction involved in the circular dependency.</p>
</div>
</div>
<div class="sect2">
<h3 id="trueabstraction-of-port-io-properties"><a class="anchor" href="#trueabstraction-of-port-io-properties"></a>8.2. Abstraction of Port I/O properties</h3>
<div class="paragraph">
<p>This is an advanced topic that allows abstractions to be written without knowing details of the implementation of the communications. The idea is for the language to support logical or abstracted I/O ports that work for any type of technical communication properties such as described in the sections below. If we allow these properties to be binded late, say at compile-time, they can be changed independently of the domain abstractions. This allows tuning of performance or physical deployment of the abstractions to different processes or hardware.</p>
</div>
<div class="paragraph">
<p>I have been looking into how this could be accomplished using a conventional language, but it seems quite hard.</p>
</div>
<div class="sect3">
<h4 id="truepush-or-pull"><a class="anchor" href="#truepush-or-pull"></a>8.2.1. Push or Pull</h4>
<div class="paragraph">
<p>Say an abstraction has a single logical input that can be wired to and a single logical output that can be wired from. Both the input and the output could be used in either a push or a pull manner.</p>
</div>
<div class="paragraph">
<p>For the input, push means we will be called with the data.  Pull means we will call out to get the data.</p>
</div>
<div class="paragraph">
<p>For the output, push means we will call out with the data, and pull means that something will call us to get the data.</p>
</div>
<div class="paragraph">
<p>There are four combinations possible:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>push push : push through</p>
</li>
<li>
<p>pull pull : pull through</p>
</li>
<li>
<p>push pull : internally buffer the input or output</p>
</li>
<li>
<p>pull push : active object</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Let&#8217;s imagine we have a function that processes the data inside the abstraction.</p>
</div>
<div class="paragraph">
<p>The four combinations would require the function to run as a result of a function call from the input, or a function call from the output. The function result may be put into an internal buffered or be pushed out. The function may need to receive its input from an input buffer or by pulling. The function may need to run via a 3rd input that is polled or called by a timer.</p>
</div>
<div class="paragraph">
<p>We could conceivably write an abstract I/O class with an output interface and an input interface and a configuration interface that allows it to be configured late on how to do the I/O. This abstract I/O object would call the function to do the work at the right time according to its configuration.</p>
</div>
</div>
<div class="sect3">
<h4 id="truesynchronous-or-asynchronous"><a class="anchor" href="#truesynchronous-or-asynchronous"></a>8.2.2. Synchronous or Asynchronous</h4>

</div>
<div class="sect3">
<h4 id="truebuffered-or-unbuffered"><a class="anchor" href="#truebuffered-or-unbuffered"></a>8.2.3. Buffered or unbuffered</h4>

</div>
<div class="sect3">
<h4 id="trueshared-memory-or-messaging"><a class="anchor" href="#trueshared-memory-or-messaging"></a>8.2.4. Shared memory or messaging</h4>

</div>
<div class="sect3">
<h4 id="trueexposed-state-plus-notification"><a class="anchor" href="#trueexposed-state-plus-notification"></a>8.2.5. Exposed state plus notification</h4>

</div>
<div class="sect3">
<h4 id="truesynchronous-requestresponse"><a class="anchor" href="#truesynchronous-requestresponse"></a>8.2.6. Synchronous Request/Response</h4>

</div>
</div>
<div class="sect2">
<h3 id="trueworking-with-legacy-code"><a class="anchor" href="#trueworking-with-legacy-code"></a>8.3. Working with legacy code</h3>
<div class="paragraph">
<p>In old (non-ALA) legacy code, abstractions, if they ever existed, have usually been destroyed by coupling. If there is no model left by the original designer, or it is out of date, I first create one. I usually have to 'reverse engineer' the model by doing many 'all files searches' and trying to build a mental picture of how everything fits together. It can quickly become mentally taxing if the user story is non-trivial. So I build a UML class diagram from the searches (their one useful application) as the background (using light lines), and a tree of method calls for the specific user story on top of it (using heavier lines). These diagrams can end up looking pretty horrific, because the knowledge of the user-story has become so scattered, especially when inheritance is involved. The tree of method calls will come into the base class but leave from a subclass method.</p>
</div>
<div class="paragraph">
<p>This process can take several hours to a day for a single user story.
Once the code for the single user story is understood, some acceptance tests are put in place for it, by putting in insertion points as close as practical to the inputs and outputs for the user story.</p>
</div>
<div class="paragraph">
<p>The next step is to factor out the method call tree for the user story into a new abstraction. This typically contains a sequence of new abstract activities or data transformations. These new abstractions are pitched at the domain level. Sometimes, if in C#, I will use Reactive Extensions. The user story may become a single RX sequence. The abstractions are then implemented, with tests, by copying and pasting useful code snippets from the original classes into the new abstractions. The old classes are marked for deprecation.</p>
</div>
<div class="paragraph">
<p>Conversion of user stories takes place iteratively.</p>
</div>
</div>
<div class="sect2">
<h3 id="truewriting-tests-architected-in-ala"><a class="anchor" href="#truewriting-tests-architected-in-ala"></a>8.4. Writing tests architected in ALA</h3>
<div class="paragraph">
<p>TBD</p>
</div>
</div>
<div class="sect2">
<h3 id="truedebugging-ala-programs"><a class="anchor" href="#truedebugging-ala-programs"></a>8.5. Debugging ALA programs</h3>
<div class="paragraph">
<p>Because in ALA you can get multiple instances of the same class used in multiple places, and multiple implementations of the same interface used in different places, debugging is easier if the instances are able to identify themselves. For this reason I tend to have a local property in every class called Name. The property is immutable and set by the constructor.</p>
</div>
</div>
<div class="sect2">
<h3 id="trueala-language-features"><a class="anchor" href="#trueala-language-features"></a>8.6. ALA language features</h3>
<div class="paragraph">
<p>One of my first hobby programming projects was a compiler for a C-like high level language for embedded systems. At the time I had lots of energy to write the compiler and optimize the object code (written in itself, the performance of both compiling and of object code execution beat the first C compilers to later appear by around a factor of ten) but I lacked a lifetime of experience to design a language. Forty years later, I feel as if it&#8217;s partially the other way around, at least for language feature that would support good architecture. The language I should have implemented way back then should have been an ALA language - one that supported ALA architecture by having the needed constraints.</p>
</div>
<div class="paragraph">
<p>It would have had Abstractions and Instances as first class elements. The name Abstraction is to reinforce the obvious use of the only type of element that the brain uses at design-time for any kind of separation of concerns.</p>
</div>
<div class="paragraph">
<p>It would support a single type of relationship - a knowledge dependency. You would have to define your four layers, and keep them in separate folders so you would be forced to decide at what abstraction level any given piece of design-time knowledge would go. Of course, it would only allow knowledge dependency relationships from one layer to a lower layer. If you wanted to add an extra layer to the chain of dependencies, that would be a bad design decision. For example, if your application is getting too large, you could create a layer between it and the domain abstractions layer called 'plug-ins'.</p>
</div>
<div class="paragraph">
<p>Instances would work like components in that they would have ports for I/O. Like interfaces, ports are defined in a lower layer. The only way of instantiating abstractions and connecting them together is inside an abstraction in a higher layer.</p>
</div>
<div class="paragraph">
<p>Abstractions would support multiple ports of the same interface. Current languages have the difficulty that you can only implement one interface of a given type, which we had to workaround by having connector objects.</p>
</div>
<div class="paragraph">
<p>Ports would support late configuration of all communication properties such as push, pull, asynchronous, synchronous (explained above) without changing the Abstraction.</p>
</div>
<div class="paragraph">
<p>Such a language would overcome many of the problems of current languages that encourage non-ALA compliant practices. But the invention of good abstractions in the first sprint of any green-field project would still be a skilled phase requiring an innate ability to abstract.</p>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2022-03-30 16:07:06 01300
</div>
</div>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/styles/Docco.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/highlight.min.js"></script>
<script>hljs.initHighlighting()</script>
</body>
</html>