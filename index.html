<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.8.dev">
<title>Chapter three - Why the structure works</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment @import statement to use as custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*::before,*::after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:600;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#914f0f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite::before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed;word-wrap:break-word}
:not(pre)>code.nobreak{word-wrap:normal}
:not(pre)>code.nowrap{white-space:nowrap}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details>summary:first-of-type{cursor:pointer;display:list-item;outline:none;margin-bottom:.75em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class~="highlight"]{background:#fefced}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos{border-right:1px solid currentColor;opacity:.35;padding-right:.5em}
pre.pygments .lineno{border-right:1px solid currentColor;opacity:.35;display:inline-block;margin-right:.75em}
pre.pygments .lineno::before{content:"";margin-right:-.125em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt,.quoteblock .quoteblock{margin:0 0 1.25em;padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;text-align:left;margin-right:0}
table.tableblock{max-width:100%;border-collapse:separate}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
td.tableblock>.content>:last-child.sidebarblock{margin-bottom:0}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>thead>tr>.tableblock,table.grid-all>tbody>tr>.tableblock{border-width:0 1px 1px 0}
table.grid-all>tfoot>tr>.tableblock{border-width:1px 1px 0 0}
table.grid-cols>*>tr>.tableblock{border-width:0 1px 0 0}
table.grid-rows>thead>tr>.tableblock,table.grid-rows>tbody>tr>.tableblock{border-width:0 0 1px}
table.grid-rows>tfoot>tr>.tableblock{border-width:1px 0 0}
table.grid-all>*>tr>.tableblock:last-child,table.grid-cols>*>tr>.tableblock:last-child{border-right-width:0}
table.grid-all>tbody>tr:last-child>.tableblock,table.grid-all>thead:last-child>tr>.tableblock,table.grid-rows>tbody>tr:last-child>.tableblock,table.grid-rows>thead:last-child>tr>.tableblock{border-bottom-width:0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot,table.frame-ends{border-width:1px 0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd),table.stripes-even tr:nth-of-type(even),table.stripes-hover tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{display:-ms-flexbox;display:-webkit-box;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media print,amzn-kf8{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
</head>
<body class="article">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="truechapter-three-why-the-structure-works"><a class="anchor" href="#truechapter-three-why-the-structure-works"></a>Chapter three - Why the structure works</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In the previous chapter we described what the structure, the anatomy, of ALA looks like as if we were dissecting a dead body. We see where things are but we don&#8217;t yet understand why they are there. In this chapter we explain why that structure works. Why does this way of organising code result in software that meets those non-functional requirements we listed in Chapter one?</p>
</div>
<div class="paragraph">
<p>The organisation of this chapter (and all chapters) is to use different perspectives. We all have different prior knowledge on which we build new knowledge, so we will each have a different best way to understand things. Use the perspective that makes the most sense to you. Because of the use of perspectives, there will often be some repetition of ideas between the major sections.</p>
</div>
<div class="sect2">
<h3 id="truea-thought-experiment"><a class="anchor" href="#truea-thought-experiment"></a>A thought experiment</h3>
<div class="paragraph">
<p>Imagine you are reading the following function, abc123, and trying to understand it:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>float abc123(float[])
{
    ...
    b = xyz789(a)
    ...
}</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>float xyz789(float)
{
    ....
    // complicated code
    ....
}</pre>
</div>
</div>
<div class="paragraph">
<p>You don&#8217;t know what abc123 nor xyz789 do. They may as well be called fubar (fubar stands for <strong>*</strong>***ed up beyond all recognition), so you follow the indirection, an inconvenience at the least because you are really just wanting to understand abc123. You have to mentally stack where you were in the code of abc123, including everything you understand about it so far.</p>
</div>
<div class="paragraph">
<p>You begin reading the code in xyz789. It only has about 20 lines but it is complicated. You need to use the code in abc123 to try to unravel what xyz789 might be providing to it. A comment mentions that it uses a CORDIC algorithm and gives a reference. But before following that indirection as well, you note that both abc123 and xyz789 have the following properties:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>they are modules</p>
</li>
<li>
<p>apparently loosely coupled</p>
</li>
<li>
<p>have a simple interface</p>
</li>
<li>
<p>use encapsulation of internals</p>
</li>
<li>
<p>use no external variables</p>
</li>
<li>
<p>have no side effects</p>
</li>
<li>
<p>hide information</p>
</li>
<li>
<p>probably separate two concerns</p>
</li>
<li>
<p>are small</p>
</li>
<li>
<p>follow coding guidelines</p>
</li>
<li>
<p>have comments</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Despite having all these great properties, still we are forced to read both functions to understand the code in either of them. They are effectively fully coupled - understanding any of the code involves understanding all of the code.</p>
</div>
<div class="paragraph">
<p>Now we make a small change:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>float StandardDeviation(float[])
{
    ...
    b = Sqrt(a)
    ...
}</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>float Sqrt(float)
{
    // complicated code
}</pre>
</div>
</div>
<div class="paragraph">
<p>Suddenly understandability is absolutely transformed. All we did was make the two functions abstractions. Now we don&#8217;t have to read the complicated code inside xyz123 at all. The code inside each of the two functions goes from highly mutually coupled to zero coupled.</p>
</div>
<div class="paragraph">
<p>All those other attributes that we listed above seemingly made no difference. The quality attribute that really mattered was abstraction. The others are still good to have, but they are completely insufficient. The abstraction property is <em>the</em> one that our brains have evolved to use.</p>
</div>
<div class="paragraph">
<p>The quality of abstraction is subjective. Software engineers must invent good quality abstractions. No compiler or tool can yet check that quality.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>In the downward direction, coupling goes to zero because the standard deviation function need only know the concept of the squareroot abstraction.</p>
</li>
<li>
<p>In the upward direction, coupling goes to zero because squareroot is more abstract and therefore can&#8217;t know anything about the more specific Standard deviation abstraction that happens to use it.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>There are other benefits too:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Abstraction and stability go hand in hand. The Sqrt abstraction is as stable as the concept of squareroot. That&#8217;s a concept that&#8217;s been stable for thousands of years. All dependencies in an ALA program go in the direction of the more stable.</p>
</li>
<li>
<p>Abstraction and reuse go hand in hand (as pointed out by Krueger). The more abstract an abstraction is the more reusable. Code reuse in ALA programs increases markedly.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The complicated code inside SQRT no longer matters. It is completely isolated by the abstraction. If your brain already knows the SQRT concept (I had to choose one that everyone knows), there is no need to follow the indirection when reading the code inside StandardDeviation. The reader just continues reading the next line of code after the Sqrt invocation as if Sqrt is just like any other line of code in their base language. That&#8217;s what abstraction is.</p>
</div>
<div class="paragraph">
<p>With this new understanding, we will now define the word dependency to be compile-time relationships, and coupling to be the design-time. One is what the compiler sees, the other is what our brain sees.</p>
</div>
<div class="paragraph">
<p>Using these definitions, you can have coupling without dependencies (sometimes called implicit coupling). The reverse is also true - it is possible to have dependencies without coupling. ALA makes use of this by simply making a constraint that all dependencies must be on abstractions. When you do that, every artefact (abstraction) in the program is zero-coupled with every other.</p>
</div>
<div class="paragraph">
<p>Doing this isn&#8217;t always easy because unfortunately there are many established architectural methods, patterns and styles that break this constraint. On the other hand, applying this constrain emerges some patterns that we will immediately recognise. DSLs and dependency injection are two examples. We will also emerge some less well known ones that are none-the-less not novel. There already exists an "abstract interactions" pattern, for example, which uses interfaces that are more abstract than the modules using it.</p>
</div>
<div class="paragraph">
<p>There are two situations that commonly cause coupling in conventional code:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>In the above example, imagine that def456 is just a source or destination for messages (in the same abstraction layer as abc123) such as a display. Then abc123 cannot be an abstraction because it cannot be reused without dragging def456 with it. If abc123 is an abstraction, it cannot know (or care) where the data comes from or goes to. To fix this, def456 must be passed into abc123 by something else above both of them. In other words, they must be composed. This can be passing in a function, passing in an object (dependency injection), or other mechanism such as function composition, monad composition, or the WireTo operator that we will use a lot in our ALA example projects.</p>
<div class="paragraph">
<p>In conventional code, if abc123 calls directly def456, then the connection relationship between abc123 and def456 is hidden inside abc123. In ALA that relationship has to be an explicit line of code (inside another abstraction) in the layer above that composes the two instances. There, it will be cohesive with other similar relationships that work together in a collaborative way to make the application.</p>
</div>
<div class="paragraph">
<p>Often these collected together wirings form a graph, making diagrams rather than code an even better way to describe the application.</p>
</div>
</li>
<li>
<p>In conventional code, if xyz789 provides a part of the implementation of abc123, it will be more specific than abc123. Sometimes such a function or class is called a helper or submodule because xyz789 could only ever be used by abc123. In ALA xyz789 needs to be significantly more abstract than abc123 or it will be highly coupled to it. If xyz789 is put inside abc123 the complexity inside abc123 is still that of both of abc123 and xyz789 together.</p>
<div class="paragraph">
<p>This is contrary to what we are taught. We are taught to "divide and conquer" or to separate out the responsibilities. If we do this arbitrarily, we will end up with specific pieces (such as UI and business logic) which are highly coupled with each other, and with the specific application. We need to work hard to separate only by finding abstractions - potentially reusable artefacts. Then we configure instances of those abstractions for each specific use by passing the application specific details into them.</p>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>In summary, ALA&#8217;s starting premise is a constraint. The constraint is that you can only use one type of dependency - a dependency on an abstraction that is significantly more abstract than the one using it. This results in zero coupling throughout the abstractions of the entire program.</p>
</div>
</div>
<div class="sect2">
<h3 id="trueabstractions"><a class="anchor" href="#trueabstractions"></a>Abstractions</h3>
<div class="sect3">
<h4 id="truedesign-time-encapsulation"><a class="anchor" href="#truedesign-time-encapsulation"></a>Design-time encapsulation</h4>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p><span class="green"><strong>Abstractions</strong></span> are the human brain&#8217;s version of <span class="green"><strong>encapsulation</strong></span>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The maintainability quality attribute is often thought of in terms of ripple effects of change. I don&#8217;t think that is quite the right way to look at it. I have often had to make changes across a number of modules in poorly written code. The changes themselves just don&#8217;t take that long. The problem I see is the time you have to spend understanding enough of the system to know where to make a change, even if it ends up being just one line of code in one place. To make that small change with confidence that it wont break anything can take a long time understanding the collaboration between modules. You may have had to understand a lot of code to figure that out. You have to understand all the code that is potentially coupled to that one line of code, which is essentially the complexity.</p>
</div>
<div class="paragraph">
<p>Unlike encapsulation which works at compile-time, abstractions hide complexity at design-time. They give boundaries to how far you have to read code to understand it.</p>
</div>
</div>
<div class="sect3">
<h4 id="trueabstractions-and-instances"><a class="anchor" href="#trueabstractions-and-instances"></a>Abstractions and Instances</h4>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p><span class="green"><strong>Software architecture</strong></span> should contain <span class="green"><strong>two concepts</strong></span> for its <span class="green"><strong>elements</strong></span>  equivalent to <span class="green"><strong>abstractions</strong></span> and <span class="green"><strong>instances</strong></span>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you are going to have abstraction, it makes sense that you would have instances.
An instance is nothing more than the use of an abstraction by referring to its name. If your abstraction is a pure function, then an instance is just using the function, or getting a reference to it.</p>
</div>
<div class="paragraph">
<p>If your abstraction is a class, and if that class contains data, then you need to instantiate the class so that each instance has its own data. Object oriented languages of course already have these two concepts as classes and objects.</p>
</div>
<div class="paragraph">
<p>Many discussions on software architecture seem to combine them into one term, such as modules or components. These terms may implicitly contain the separate concepts of abstractions and instances, or they may be intended to only one instance. Not having explicit terms, like class and object, will inevitably lead to confusion. In ALA the terms we use are abstractions and instances.</p>
</div>
<div class="paragraph">
<p>The problem is that when we become vague about the difference between abstraction and instance, we will then create dependencies between abstractions, such as to get or put data. If you create dependencies between peer abstractions, they are no longer abstractions. Instead you need to wire the instances. If we don&#8217;t have two separate and clear terms for abstractions and instances, we will end up with no abstractions. Many architectural styles appear to have this problem.</p>
</div>
<div class="paragraph">
<p>A common example of the problem is the UML, which already has the separate concepts of classes and objects. The UML class diagram encourages us to create associations between classes, destroying them as abstractions. The most important potential idea that OOP brought us was the idea of classes as reusable abstractions, and objects as their instances. It never happened in part because of the UML class diagram, and the very harmful habit of putting dependencies between abstractions instead of wiring instances.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>The quality of an abstraction&#8217;s <em>concept</em> or <em>idea</em> is important. It is the existence of the concept that allows the brain to learn it and not have to know how it&#8217;s implemented each time it comes across it. It is the concept of the abstraction that blocks coupling. ALA sometimes requires effort over several days to conceive good abstractions, especially for the first application in a new domain.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="truezero-coupling-and-higher-cohesion"><a class="anchor" href="#truezero-coupling-and-higher-cohesion"></a>Zero coupling and higher cohesion</h3>
<div class="sect3">
<h4 id="truezero-coupling"><a class="anchor" href="#truezero-coupling"></a>Zero coupling</h4>
<div class="paragraph">
<p>ALA has mutual zero coupling between the code inside (or the code that implements) all abstractions. This is the case both horizontally between peers in the same layer, and vertically up or down the layers.</p>
</div>
<div class="paragraph">
<p>In software design we are only interested in design-time coupling. This means that to understand one piece of code, how much do we need to understand other pieces of code? This is the coupling that matters. We will use the word coupling to refer to design-time coupling. A lot of esign-time coupling is what I call <em>collaboration coupling</em>. Interfaces may hide some details, but they don&#8217;t stop collaboration. When modules have a fixed arrangement with each other, they are highly likely to be collaborating, and this collaboration will tend to increase during maintenance.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>Wikipedia defines coupling as "the degree of interdependence between software modules". It doesn&#8217;t really distinguish between design-time, compile-time or run-time coupling, and the given formula for coupling seems to reflect compile-time. I prefer to think of coupling as a design-time property. The use of abstractions instead of modules changes the way we should think about coupling.</p>
</div>
<div class="paragraph">
<p>Consider the principle of compositionality. As stated in Wikipedia, "In semantics, mathematical logic and related disciplines, the principle of compositionality is the principle that the meaning of a complex expression is determined by the meanings of its constituent expressions and the rules used to combine them." In ALA we use domain abstractions as the 'constituent expressions', and programming paradigms as the 'rules used to combine them'. We have the objective that all code conforms to the principle of compositionality. We can then define coupling as anything that compromises this principle.</p>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p><span class="green"><strong>To understand any one part of the code should involve understanding only that one part of the code, and the abstractions it uses.</strong></span></p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Unfortunately there is a meme in the software engineering industry that there must be some coupling between 'modules'. The argument goes that if the system is to do anything it must have some coupling between its parts. We therefore hear of "loose coupling" as being the ideal. Using the definition of coupling given above, this is completely incorrect. Because of this meme, in conventional code we have developed a habit of using dependencies to implement communications. We settling for design-time coupling to achieve communication connections between different parts of a system. This is not necessary. Part of the problem is that the same word, <em>coupling</em>, is being used for both design-time coupling and <em>connections</em> or <em>wiring</em> used for communications.</p>
</div>
<div class="paragraph">
<p>In our A &amp; B example above, the code inside B knows nothing of A. The code inside A, while it knows about the concept of the abstraction B, knows nothing about the code that is inside B. So it&#8217;s not like we don&#8217;t know how to do zero-coupling. ALA is basically a constraint to force us to <em>always</em> do zero coupling.</p>
</div>
<div class="paragraph">
<p>For example, in conventional code, if function Switch calls function Light, the code inside Switch is coupled with Light. If the light&#8217;s abstraction level is about the same as that of the Switch, then the abstraction of Switch is destroyed. When you reuse it you have to know the internal code brings in a Light. To understand the <em>system</em> (a Switch connected to a light), you have to go inside the Switch:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/switch-light-bad.png" alt="switch light bad">
</div>
</div>
<div class="paragraph">
<p>If instead, an abstraction, System, has code inside it like Light(Switch()), then Switch remains a good abstraction whose internal code is now only concerned with how a switch works. The code inside all three abstractions is now zero coupled. Understanding the system no longer requires looking inside Switch.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/diagram-collaboration-A-B-C.png" alt="diagram collaboration A B C">
</div>
</div>
<div class="paragraph">
<p><br></p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/diagram-collaboration-B-C-invis.png" alt="diagram collaboration B C invis">
</div>
</div>
<div class="paragraph">
<p>A similar argument applies if Switch and Light are classes. In conventional code they will commonly have an association relationship. Even if Light is injected into Switch by a higher entity called System, Switch still knows the specific interface of a light (LightOn(), LightOff()). This interface is not abstract enough to prevent Switch knowing about Light, and Switch knowing about the System. If you instead have a class System that has code like new Switch().WireTo(new Light()) using a generic interface then all three abstractions are zero coupled.</p>
</div>
<div class="paragraph">
<p>ALA <em>never</em> uses coupling for connections or wiring between parts of a system. A larger system typically consists of many  connections. These connection are typically cohesive, and belong in one place. In conventional code they tend to be distributed and buried inside the modules. A smell is that you are doing 'all files' searches to unravel them</p>
</div>
</div>
<div class="sect3">
<h4 id="truecohesion"><a class="anchor" href="#truecohesion"></a>Cohesion</h4>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>"<span class="red"><strong>Collaboration</strong></span> becomes <span class="green"><strong>cohesion</strong></span>".</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In ALA, collaboration between modules becomes cohesion inside a new abstraction. A call from one module to another becomes a line of code. Calloboration between a group of modules for a single purpose, such as a user story, becomes several cohesive lines of code.</p>
</div>
<div class="paragraph">
<p>Cohesion also increases in a different way. An abstraction is closely aligned with the single responsibility principle. We can think of abstraction as a single concept principle. Using abstractions increases the cohesion of the code that implements the abstraction.</p>
</div>
<div class="paragraph">
<p>ALA provides no structure for the internals of an abstraction because the code is cohesive. The internals of an abstraction could be described as a small ball of mud, which is why they should be small. There is no such thing as a sub-abstraction. Instead the code is composed of instances of abstractions from lower layers. So layers replace hierarchical encapsulation.
Zero coupling and high cohesion limits ripple effects of change, whether in higher layers or lower ones. A ripple stops at an abstraction concept because of the inherent stability of the concept itself.</p>
</div>
<div class="paragraph">
<p>What does happen though is that abstractions can be improved as abstractions. Often you can generalize an abstraction to make it more reusable by adding a configuration that has a default behaviour, so it doesn&#8217;t affect other uses of the abstraction (convention over configuration).</p>
</div>
<div class="paragraph">
<p>In our experience, the most common type of change that still affects multiple abstractions are changes to conventions. Conventions in the ways abstractions are commented, and their code laid out are effectively abstractions in themselves that live in the bottom layer. So when they change, it makes sense that all abstractions that depend on them change. These conventions will mature in time. Besides, while these types of changes may require a lot of editing, they don&#8217;t require simultaneous understanding of multiple modules, which is where the real problem with coupling lies.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="truegood-versus-bad-dependencies"><a class="anchor" href="#truegood-versus-bad-dependencies"></a>Good versus bad dependencies</h3>
<div class="paragraph">
<p>For the purposes of this book, a dependency is when some code symbolically refers to a class, interface or function or other artefact in a separate piece of code. This covers everything from dependencies on classes, interfaces, modules or components, to dependencies on libraries or packages.</p>
</div>
<div class="paragraph">
<p>A dependency can be on something inside a class or interface, usually a method or property. Even if using an object reference, there is still a dependency if there is a reference to something named inside the class or interface.</p>
</div>
<div class="paragraph">
<p>We can distinguish between good and bad dependencies. Good dependencies are  design-time dependencies. These are dependencies on the knowledge you must have to even understand a given piece of code. I will often refer to this type as a "knowledge dependency" or "use of an abstraction". It is also sometimes called "semantic coupling". This type of dependency effectively adds to the language you use to write code. Here is a diagram shwoing a good dependency.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/GoodDependency1.png" alt="GoodDependency1">
</div>
</div>
<div class="paragraph">
<p>A bad dependency is one that is there to facilitate run-time communications between two modules or components. Here is a diagram representation.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/BadDependency1.png" alt="BadDependency1">
</div>
</div>
<div class="paragraph">
<p>Another type of bad dependency is when a module uses a submodule that is a specific part of it. An example is a 'helper' class. The submodule is often thought of as being logically contained inside its parent module.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/BadDependency2.png" alt="BadDependency2">
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p><span class="green"><strong>Dependencies on more abstract abstractions are good</strong></span>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p><span class="red"><strong>Dependencies for communciations between peers are bad, as are dependencies on submodules</strong></span>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A simple example of a communication dependency is a module that calculates the average then calls a display module to display the result. To understand the code that calculates the average requires no knowledge about displays, nor even where the result will be sent. So it is a bad dependency.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/BadDependency3.png" alt="BadDependency3">
</div>
</div>
<div class="paragraph">
<p>The intention of the fixed arrangment between Average and Display was to measure rainfall. To do that, an instance of an Average module needs to be connected to an instance of Display module at run-time, but you don&#8217;t need a dependency to achieve that.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/GoodDependency2.png" alt="GoodDependency2">
</div>
</div>
<div class="paragraph">
<p>A simple example of knowledge dependencies occurs in an abstraction that measures rainfall. To understand the rainfall code, you must understand the concepts of average and of display. The rainfall abstraction can use the abstractions for averaging and displaying.</p>
</div>
<div class="paragraph">
<p>We typically find both good and bad dependencies in conventional code. A typical modular program is full of bad dependencies. But whether a knowledge dependency or a communication dependency, they all look syntactically the same - a function call or a 'new' keyword, etc. We are not gnerally taught how to distinguish between them. We lump them together when we talk about dependency management, loose coupling, layering, fan-in, fan-out, circular dependencies or dependency inversion. Dependency graphing tools cannot distinguish between them because identiying good dependencies would require understanding abstraction levels.</p>
</div>
<div class="paragraph">
<p>Good and bad dependencies are not just good and bad. They are really good and really bad.</p>
</div>
<div class="paragraph">
<p>A knowledge dependency is good because it&#8217;s only a dependency on an abstract concept, on something stable and learnable. We want more of them, because then we are reusing our abstractions. Then the more dependencies you have on such an abstraction, the more abstract it is.</p>
</div>
<div class="paragraph">
<p>So it&#8217;s doubly important that we are able to tell good dependencies from bad.</p>
</div>
<div class="paragraph">
<p>It&#8217;s entirely possible to build a system using only good dependencies.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p><span class="green"><strong>In ALA we eliminate ALL bad dependencies</strong></span>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Bad dependencies destroy abstractions. They cause explicit and implicit coupling. They obscure the structure of the application by distributing that structure throughout its modules.</p>
</div>
<div class="paragraph">
<p>When we remove all bad dependencies, they become normal lines of code, cohesive with one another, inside a more specific abstraction in a higher layer. Each line of code composes instances of the abstractions which would otherwise have had the bad dependency.</p>
</div>
<div class="paragraph">
<p>Consider the diagram below. It&#8217;s the conventional modular way to write a rainfall meter. An ADC reading is averaged, converted, accumulated, and displayed. The middle three modules have bad dependencies which they use to make function calls to pull data in and push data out.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/dependency-diagram.png" alt="dependency diagram">
</div>
</div>
<div class="paragraph">
<p>There are four bad dependencies, two from Conv and one each from Avg and Accu.</p>
</div>
<div class="paragraph">
<p>Now consider this diagram, which uses only good dependencies.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/dependency-diagram-1.png" alt="dependency diagram 1">
</div>
</div>
<div class="paragraph">
<p>There are five good dependencies from the Application to the five Abstractions. There are also five good dependencies from the Abstraction on Dataflow. We never draw arrows on a diagram for good dependencies. Instead we just refer to the abstractions by name.</p>
</div>
<div class="paragraph">
<p>Connections between the instances of teh abstractions are completely described inside the Application. There it is cohesive code that knows about how to build a rain meter.</p>
</div>
<div class="paragraph">
<p>The code in the application abstraction could look something like this if using functions (although you would likely use some temporary variables in practice):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">    Disp(Accu(Conv(Avg(ADC()))));</code></pre>
</div>
</div>
<div class="paragraph">
<p>It might look something like this if using classes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">    new ADC().WireIn(new Avg()).WireIn(new Conv()).WireIn(new Accu()).WireIn(new Disp());</code></pre>
</div>
</div>
<div class="paragraph">
<p>How this code is done is not what&#8217;s important. How syntactically succinct this code is is not important. What&#8217;s important is where it is. We want the code that cohesively and fully expresses a rain meter to be in one place.</p>
</div>
<div class="paragraph">
<p>The lower-case letters used in the top layer of the diagram represent instances of the respective abstractions. (In UML they would be underlined.)</p>
</div>
<div class="paragraph">
<p>You never draw arrows for knowledge dependencies - you only ever refer to abstractions by name. (Just as you would never draw an arrow to a box representing the squareroot function - you would just use Sqrt by its name.)</p>
</div>
<div class="paragraph">
<p>In common programming languages, the communication dependencies in the first diagram and the knowledge dependencies in the second diagram could both be syntactically written in the same form, either new A() or just a function call, A(). The only difference is in where those new keywords or function calls are.</p>
</div>
<div class="paragraph">
<p>The application abstraction can move the data between the instances of ADC, Avg, etc itself, as we did in the first code example, however strictly speaking that pollutes it with details of how to move data that actually belongs in the programming paradigms layer. We much prefer the application code just does the composing - just specifies who connects to whom, but is not involved with how data actually flows. That&#8217;s why in most of the examples, we compose with classes that have ports rather than functions. In the second code example, the dataflow programming paradigm would be implemented with an execution model that knows how to actually move data. The application only knows that it is composing a flow of data.</p>
</div>
<div class="paragraph">
<p>The interface used to connect the instances is called Dataflow. It&#8217;s important that this interface is abstract. It is two layers down. It is not an interface specific to any one of the domain abstractions, ADC, Avg, etc. This is the abstract interactions pattern. Other domain abstractions can either implement it or accept it, or both.</p>
</div>
<div class="sect3">
<h4 id="truecomparison-of-good-versus-bad-dependencies"><a class="anchor" href="#truecomparison-of-good-versus-bad-dependencies"></a>Comparison of good versus bad dependencies.</h4>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. Comparison of two approaches</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Run-time dependencies version</th>
<th class="tableblock halign-left valign-top">Knowledge dependencies version</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Knowledge about the specific application is spread through all modules.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Knowledge about the specific application is only in one place. The abstractions know nothing of each other or the specific application.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">The class or function names A, B, D and E will relate to what they do (which is fine). For example, they may be the specific hardware chips used in the case of drivers. The calling module must know these names, creating a fixed arrangement between the modules. The modules are only loosely coupled.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No abstractions refer to the names of peer abstractions. There is no fixed arrangement between abstractions. The abstractions are zero coupled. The code that knows that a particular hardware chip is used in this application is where it belongs, in the application abstraction.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Since there is a fixed arrangement, responsibilities can be blurred. For example, it may be unclear whether to add something to B or C.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">With no relations between abstractions, responsibilities are clear. Something to be added clearly belongs in one or other of the abstractions, or in a new abstraction that may be wired in between the two.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">The fixed dependency from C to B will encourage implicit coupling. B can make assumptions about details inside B resulting in collaborative coupling.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">C cannot make any assumptions about some details of B. It cannot have collaborative coupling with B</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Although there is no dependency, for example from B to C, the fixed arrangement is likely, over time, to make B implicitly collaborate with C (do what C requires), resulting in collaborative coupling.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No implicit coupling can develop over time because there is no fixed relationship between them. B cannot collaborate with C (do what C specifically requires).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">The arrangement between A, B, C, D and E is not obvious in the code. It is buried inside of B, C and D. All must be read to find the application&#8217;s dataflow structure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The arrangement between instances of A, B, C, D and E is explicitly coded in one place. The dataflow between them is cohesive information that belongs in one place.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Only A and E can potentially be abstractions.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">All of A, B, C, D and E are abstractions.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Arbitrarily, only the two ends of the dataflow chain can be reused independently .</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">All of A, B, C, D and E are independently reusable.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Difficult to insert another module between, say, B and C.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Easy to insert a new instance of some operator between B and C, etc.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">If the observer pattern is used (in the mistaken belief that it reduces the coupling), it only mirrors the same problems. For example B would now have a dependency on C when it registers. But because it adds indirection, the observer pattern makes the program even harder to understand.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">If the observer pattern is used (as the means to implement the wiring between the instances), the receivers do not do the registering, the application does (not strictly the observer pattern). The abstractions themselves don&#8217;t get more difficult to understand because, being abstractions, they only have knowledge as far as their interfaces anyway. The application does not get harder to understand either, because the arrangement of the instances is still explicit and in one place.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">If dependency injection is used with automatic wiring, the arrangement is still somewhat fixed, but is now even more obscure. All classes can still be collaborating with one another. A smell that this is happening is that over time the interfaces, IA, IB, ID and IE change as the requirements of the system change.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">If dependency injection is used, the application does the wiring explicitly. It is the only place that should know who will talk to whom at run-time for this specific application. There are no specific interfaces between pairs of modules to change over time, because they all just use a stable abstract interface.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Each module has its own interface. But they are all doing essentially the same thing, getting data.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Uses a single more abstract interface called Dataflow.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">The arrangement between the modules cannot easily be changed, both because the wiring code is buried inside the modules and because the interfaces are essentially specific to pairs of modules.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The composition can easily be changed. Instances of the abstractions can be re-wired in any combination. New abstraction instances can be inserted.</p></td>
</tr>
</tbody>
<tfoot>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">There is no diagram of the arrangement between A, B, C, D, E, or if there is, it is likely a high level overview, lacking in detail, and a second source of truth that gets out of date.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">There is a diagram that shows the arrangement of the instances of A, B, C, D and E. It is the one source of truth. It includes all details about the specific application. It is executable.</p></td>
</tr>
</tfoot>
</table>
<div class="paragraph">
<p>During code creation, run-time dependencies are easily introduced, and never seem too terrible at the time as they get the immediate job done. But when they accumulate to hundreds or even thousands of them, as they do in most typical applications, that&#8217;s when the system, as described on the left side of the table, just appears as a monolithic big ball of mud.</p>
</div>
</div>
<div class="sect3">
<h4 id="truefree-lunch"><a class="anchor" href="#truefree-lunch"></a>Free lunch?</h4>
<div class="paragraph">
<p>When you are comparing the left and right sides of the table above, you may be wondering, where did the free lunch come from? Where did the runtime dependencies go? Is this some kind of magic? Or how can the program work without them? Or haven&#8217;t I just moved them somewhere else? No there are no tricks. The answer is that we have been taught to do programming in a very bad way. The knowledge that ADC will talk to Avg, etc at run-time is there, but it is now contained within an abstraction, not a dependency between modules. If you really want to find a disadvantage, then it is the need for the abstractions. It only works as well as the quality of the abstractions. Effectively we have traded the need for dependency management, and all the complexity that bad dependencies cause, with the need to create good abstractions. Creating good abstractions is a skill that does take time to get used to.</p>
</div>
<div class="paragraph">
<p>Just to recap the only dependencies we have used are good design-time or knowledge dependencies:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The application should and must 'know' at design-time what domain abstractions it needs to compose to make a rain meter application.</p>
</li>
<li>
<p>The domain abstractions should and must know at design-time what programming paradigm they need - the abstract interfaces to use for their input and output ports.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="truestable-dependencies-principle"><a class="anchor" href="#truestable-dependencies-principle"></a>Stable dependencies principle</h4>
<div class="paragraph">
<p>A dependency on an abstractions is a dependency on the concept or idea of that abstraction. A concept or idea is generally stable. So dependencies are toward the more stable.</p>
</div>
<div class="paragraph">
<p>Even if the implementation details inside an abstraction are complicated or change, the abstraction concept itself be stable. The application example above is really just depending on the idea of an ADC or the idea of a Display. If the details inside change it doesn&#8217;t matter. For example, if the ADC silicon is changed, the ADC abstraction implementation can also change. But the application is still just using an ADC as it&#8217;s means to get input.</p>
</div>
<div class="paragraph">
<p>ALA therefore naturally conforms with the Stable Dependencies Principle (depend in the direction of stability). The SAP is mostly used in relation to packages, but ALA does not use hierarchical encapsulations. Here we are applying it at the level of the abstractions themselves.</p>
</div>
</div>
<div class="sect3">
<h4 id="truedependency-fan-in-and-fan-out"><a class="anchor" href="#truedependency-fan-in-and-fan-out"></a>Dependency fan-in and fan-out</h4>
<div class="paragraph">
<p>One of the guidelines sometimes used for dependencies in conventional code is that a class that has high fan-in should not have high fan-out (also called afferent and efferent coupling). Another is that modules higher in the layers should have low fan-in and those lower in the hierarchy have low fan-out.</p>
</div>
<div class="paragraph">
<p>The argument goes that a class with high fan-in should have high stability but one with high fan-out would have low stability (presumably because dependencies are thought to be things that cause changes to propagate).</p>
</div>
<div class="paragraph">
<p>In ALA, dependencies are on abstractions. Furthermore the abstractions are increasingly abstract as you go down the layers, and therefore increasingly stable. Therefore the conventional fan-in and fan-out recommendations are reversed. In ALA, it is perfectly fine, in fact really good to have both high fan-in and high fan-out. It simply means that the abstractions are useful and are getting reused.</p>
</div>
<div class="paragraph">
<p>If we are talking about dependencies in a conventional modular system that are used for communication between modules in the system, of course ALA says we want zero fan-in and zero fan-out, because such dependencies are illegal anyway.</p>
</div>
<div class="paragraph">
<p>In chapter four we will also talk about fan-in and fan-out. Note that the fan-in and fan-out discussed in chapter four is different. In this chapter fan-in and fan-out is talking about dependencies on abstractions between layers. In chapter four we are talking about fan-in and fan-out in the wiring.</p>
</div>
</div>
<div class="sect3">
<h4 id="truecircular-dependencies"><a class="anchor" href="#truecircular-dependencies"></a>Circular dependencies</h4>
<div class="paragraph">
<p>Of course in ALA, with only knowledge dependencies present in the system, and the dependencies needing to go toward more abstract abstractions, you obviously cannot have circular knowledge dependencies. Nor would that even make sense. (Recursion appears to require circular knowledge dependencies but actually doesn&#8217;t. We will visit that in the last chapter.)</p>
</div>
<div class="paragraph">
<p>Since there are no run-time dependencies, the issue of circular dependencies with them does not arise at all. What might have been circular dependencies in conventional code becomes circular wiring of instances of abstractions inside a user story abstraction in the application layer. Such circular wiring is quite valid, and very common. The potential issues with the execution models are discussed in chapter four.</p>
</div>
<div class="paragraph">
<p>In conventional software design, run-time communication channels between modules are frequently implemented with dependencies. Then we realize these dependencies are a problem and so we add a rule that we don&#8217;t like circular dependencies. This is an attempt to mitigate the problem by forcing the modules to have a sort of arbitrary layered structure. That structure does not actually exist in the nature of peer modules themselves. (Many modules will actually have a similar level of abstraction, for example views, business logic and data.) The forced arbitrary layering structure becomes its own nuisance.</p>
</div>
<div class="paragraph">
<p>So then what happens is circular dependencies are most often avoided by using pushing in one direction and pulling in the other. (Pushing means a function or method call with a parameter, pulling means a function or method call returning a value). This is sometimes actually convenient, and other times a real nuisance. Whether we push or pull should be able to depend on performance or other considerations (which end wants to initiate the communications, which depends on when the source changes, or when we want to receive new a the data, or how often the source changes, or on latency, etc), not on an arbitrary layering of modules.</p>
</div>
<div class="paragraph">
<p>So, when we do want to push or pull in the reverse direction of the allowed dependency, we end up creating an indirection, such as a callback, virtual function call, or observer pattern (publish-subscribe). This indirection further obscures the already  obscure communication flows through the system.</p>
</div>
<div class="paragraph">
<p>ALA simply eliminates all this nonsense. In ALA, communication flows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>are explicit</p>
</li>
<li>
<p>can be in both directions</p>
</li>
<li>
<p>each set of cohesive flows are contained in one place</p>
</li>
<li>
<p>allowed to be push, pull, or asynchronous on a port by port basis</p>
</li>
<li>
<p>don&#8217;t use dependencies at all</p>
</li>
<li>
<p>use indirection in the correct way, which is that when you are reading code inside an abstraction, you don&#8217;t know, and shouldn&#8217;t know, where your inputs and outputs are wired to.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>That concludes our discussion on why the ALA structure works from the point of view of good and bad dependencies.</p>
</div>
</div>
<div class="sect3">
<h4 id="trueknowledge-dependencies-are-on-all-layers-below"><a class="anchor" href="#trueknowledge-dependencies-are-on-all-layers-below"></a>Knowledge dependencies are on all layers below</h4>
<div class="paragraph">
<p>Sometimes layers are used incorrectly as partitions or really just modules. We would be better off to just tip all such layering models on their side.  Because of this mistake, there is a meme that we should only have dependencies on the immediate layer below. For ALA layers this is incorrect.</p>
</div>
<div class="paragraph">
<p>When we write our programs using only knowledge dependencies, the knowledge needed to understand a piece of code can come from all the layers below.</p>
</div>
<div class="paragraph">
<p>For example, to understand this application layer code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">    new ADC().WireIn(new Avg()).WireIn(new Conv()).WireIn(new Accu()).WireIn(new Disp());</code></pre>
</div>
</div>
<div class="paragraph">
<p>You need to know all of these things from lower layers:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Understand what the  domain abstractions, ADC, Avg, Disp, etc do.</p>
</li>
<li>
<p>Understand the dataflow programming paradigm. When you compose these particular domain abstractions, you are composing a flow of data from left to right.</p>
</li>
<li>
<p>Understand that the WireTo operator, which comes from the Libraries layer, is what you use to do composition.</p>
</li>
<li>
<p>Understand your general purpose programming language, which sits below the Libraries layer.</p>
</li>
<li>
<p>Understand ALA which is an abstraction that sits below the programming language layer.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>All of these knowledge dependencies should be explicit. This means that the application folder should contain a readme file explaining all these knowledge dependencies, and link to information about them.</p>
</div>
<div class="paragraph">
<p>It&#8217;s nt necessarily the case that all lower layer knowledge is needed to understand something. The application is itself an abstraction. There can be many instances of it being used by different users. These users don&#8217;t need to understand all the abstractions in all the layers, only the application abstraction by itself.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="trueexecutable-expression-of-requirements"><a class="anchor" href="#trueexecutable-expression-of-requirements"></a>Executable expression of requirements</h3>
<div class="paragraph">
<p>We have previously discussed this aspect of ALA in terms of structure. It is the top layer. And we have used this aspect as the starting point in the method to develop the example projects. But why does the succinct description of requirements in that top layer work?</p>
</div>
<div class="paragraph">
<p>In conventional software development, we typically break a user story (or feature or functional requirement) up into different implementation responsibilities. For example, layers like GUI, business logic and database, or a pattern such as MVC (Model, View, Controller). But a user story or feature actually starts out as cohesive knowledge n the requirements. And its not a huge amount of cohesive knowledge, so it doesn&#8217;t need breaking up. Cohesive knowledge, knowledge that is by its nature highly coupled within itself should be kept together. All we need to do to keep it together is find a way to describe it so that it is executable. Don&#8217;t try to do any implementation, just get it described in a concise and complete form. If you can do that, the chances are you will be able to find a way to make it execute.</p>
</div>
<div class="paragraph">
<p>In ALA we want to find a way to express the user story with about the same level of expressiveness as when the user story was explained in English by the product owner. The language he used would have contained domain specific terms to enable him to explain it concisely. The same thing ought to be possible in the code. Anything that does not come directly from the requirements and starts to look like implementation detail is separated out. It comes out into abstractions. These abstractions typically contain knowledge of how user stories in general are implemented - how things can be displayed, how things can be saved, how data can be processed.</p>
</div>
<div class="paragraph">
<p>Many times, abstractions that know how to implement useful things for expressing user stories are not only reusable for user stories, but can be reusable for other applications. In other words, they are domain level abstractions. A typical user story might be composed of several of them, some to implement the user story&#8217;s UI, some to implement the user story&#8217;s business, and some to implement the user story&#8217;s saving of data. A user story instantiates the abstractions, configures them with the specific knowledge from the requirement, and then wires them together.</p>
</div>
<div class="paragraph">
<p>Most maintenance is probably changing, adding or fixing user stories or features. When those features are described entirely in one place instead of distributed through a lot of modules, you have a direct understanding of how the user story is represented by code, and therefore of how to change it or fix it.</p>
</div>
<div class="paragraph">
<p>Of course application code makes heavy use, in fact is entirely composed of, instances of domain abstractions. When fixing a bug, it quickly becomes clear if the application code itself doesn&#8217;t represent the requirements as intended, or one of the abstractions is not doing its job properly. Again the maintenance is easy.</p>
</div>
<div class="sect3">
<h4 id="truethe-meaning-of-composition"><a class="anchor" href="#truethe-meaning-of-composition"></a>The meaning of composition</h4>
<div class="paragraph">
<p>Expressing user stories as a composition of domain abstractions, as discussed in the previous section, is all well and good, but it doesn&#8217;t work without defining what composion means. That&#8217;s where programming paradigm abstractions come in.</p>
</div>
<div class="paragraph">
<p>For example, many applications have displayed values or outputs that need to be updated 'live'. In conventional code, we often write imperative code to implement this live behaviour. The code repeatedly gets data from its source(s), does some manipulation on that data, and updates the output. This kind of code uses lots of bad dependencies. we really should have a programming paradigm for it. In ALA you think of it as a dataflow. Wiring together domain abstractions represents data flowing automatically. This programming paradigm is not new, of course, it appears in Unix&#8217;s pipes and filters, functional programming, binding GUI display elements to a data source, LINQ, Reactive Extensions, Labview, function blocks, ladder logic, and countless other programming systems. Dataflows are often used on distributed systems because implementation over literal wires is naturally a dataflow. But the paradigm is just as applicable inside monolithic systems. What ALA does is make it easy and natural to implement dataflow yourself every time it is the best way to express requirements. We should never be writing imperative code when dataflow is what best expresses what we want to do. ALA makes it easy wire a linear chain of data manipulations. But it also makes it easy to wire up an arbitrary network of dataflows.</p>
</div>
<div class="paragraph">
<p>The same idea applies to the event-driven programming paradigm. It is common these days for GUI elements such as buttons, menu items, etc to have event-driven output ports. But then we often just wire them to imperative methods with a dependency. In ALA you create input ports as well. For example all popup window abstractions such as file browsers, wizards, settings, navigable pages, etc have input ports. The main window has a close input port. Long running tasks that need to be told when to start have an input port. Then you can use the event-driven programming paradigm for composing instances of these types of domain abstractions.</p>
</div>
<div class="paragraph">
<p>Another programming paradigm is building the UI. Building the UI by composing abstractions is common using conventional libraries these days. The meaning of composition is containing one UI element inside another. The composed UI structure is a tree. For example XAML does this using XML. I do not like the use of XML for this. What ALA brings is doing all composition in a consistent way. Wiring for the UI is done in the same way as the composition wiring for dataflow, or event-driven, or any other programming paradigm you care to use. That way a user story is fully and cohesively expressed inside its own abstraction.</p>
</div>
</div>
<div class="sect3">
<h4 id="truerequirements-are-whats-left-when-you-factor-out-all-implementation-details"><a class="anchor" href="#truerequirements-are-whats-left-when-you-factor-out-all-implementation-details"></a>Requirements are what&#8217;s left when you factor out all implementation details</h4>
<div class="paragraph">
<p>This is another way of thinking that comes to the same solution. As we know from the previous section, ALA requires you build your entire application factoring out all pieces of computing work into domain abstractions and programming paradigm abstractions. So what does the application that&#8217;s left in the top layer look like? Well if everything abstract has been factored out, what remains must be details specific only to this application. Essentially these details equate with the requirements.</p>
</div>
<div class="paragraph">
<p>The application code becomes a formal re-expression of the requirements. There will be some information there that wasn&#8217;t explicitly stated in the requirements, but they were requirements all the same. For example, it may not have been stated in the requirements that a number displayed on the UI should not change its value too frequently - it should be slow enough for a human to read successive values. A consequence of that requirement is that it should not contain noise that has a frequency higher than the display update rate. So the application will end up with an instance of a re-sampler abstraction and an instance of a filter abstraction wired into its dataflow before the display. The application will specify the re-sampling rate, and the filter bandwidth.</p>
</div>
</div>
<div class="sect3">
<h4 id="truedsl-domain-specific-languages"><a class="anchor" href="#truedsl-domain-specific-languages"></a>DSL - Domain Specific Languages</h4>
<div class="paragraph">
<p><a id="DSL1"></a></p>
</div>
<div class="paragraph">
<p>ALA&#8217;s succinct expression of requirements discussed above is obviously a form of DSL (Domain Specific Language). Under the broader definition of a DSL, The domain abstractions and programming paradigms layers are a DSL. But ALA is not just a DSL. ALA is fundamentally about organising all code into small abstractions that are in layers that are increasing abstract. This constrains the organisation of code much more than simply implementing a DSL.</p>
</div>
<div class="paragraph">
<p>ALA does not pursue the idea of an external DSL (a new syntax), nor even the syntactic elegance of DSLs. It doesn&#8217;t try to move application development away from the developer to a requirements team as some DSLs can do. For example, you don&#8217;t get a new language such as XAML to express UI structure. In fact, expressing the UI structure in ALA moves away from XML back to code. If moving away from code, ALA uses diagrams because they are more flexible and much more readable than XML.</p>
</div>
<div class="paragraph">
<p>Seen as a DSL, in ALA you wire together plain old objects or functions while conforming to a grammar. The grammar comes from the 3rd layer programming paradigms and from which classes use which programming paradigm for ports. This grammar defines the rules for their composition.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="truediagrams-vs-text"><a class="anchor" href="#truediagrams-vs-text"></a>Diagrams vs text</h3>
<div class="paragraph">
<p>The fundamental rules of ALA don&#8217;t prescribe the use of diagrams. But diagrams often emerge. So why do we often use a diagram instead of text in the application (top) layer of an ALA application?</p>
</div>
<div class="paragraph">
<p>It&#8217;s because in any non-trivial program, there is structure inherent in the requirements that forms a graph. If you have UI that graph is a tree - still representable with indented text. But the UI must have connections. (These particular connections are often called bindings.) They need connections with data. They need connections with event handlers. These connections must be done symbolically if using text. The connections go further. There are connections to business logic and to some form of persistent data model, and from there to real databases or files. There are arbitrary connections for navigating around different pats of the UI. If text, most of these connections must be done symbolically. On the way, they may need to connect arbitrarily with things that process, reduce, or combine. There may be states involved, with arbitrary transitions needed between those states. There may be activities that have to happen in a prescribed time sequence, which by itself is representable as a linear instructions in text. But there are often loops or alternative routes through the sequence, which is representable as indented text. But then there is always some connection between the activities and some data or the outside world. If text, these connections must generally be done symbolically.</p>
</div>
<div class="paragraph">
<p>All these connections are inherent in the requirements. Like or not, they form a graph. And this graph structure is somewhere in your code.</p>
</div>
<div class="paragraph">
<p>As we said, in text from, this graph needs to use at least some symbolic connections. That is, we can represent some of the graph with indenting and judicious use of anonymous functions or classes, but in general we will need to represent many of the connections by using names of variables, functions or objects.</p>
</div>
<div class="paragraph">
<p>This is bad enough. In fact this is already really, really bad compared with how the electronics guys do things.</p>
</div>
<div class="paragraph">
<p>But it gets much worse. In most conventional code, we take all these symbolic connections and distribute them evenly through the files/modules/classes/functions. Now the graph is totally obfuscated. The graph is highly cohesive. Why do we make it harder for ourselves by breaking it up?</p>
</div>
<div class="paragraph">
<p>But it gets much worse. Graphs have circles in them. There is nothing wrong with that, it&#8217;s inherent in the connections in the requirements. But circles are at odds with dependency rules. So now what we do is break the cyclic dependencies using principles like dependency inversion or observer pattern. The connections don&#8217;t go away. We just further obfuscated them. These connections are now done at run-time by code written somewhere else. This is the so called indirection problem.</p>
</div>
<div class="paragraph">
<p>What a mess we have got into!</p>
</div>
<div class="paragraph">
<p>ALA tells us how to fix this entire mess. It&#8217;s really quite simple. ALA breaks up your application by factoring out abstractions. When you have done that to the maximum extent, what&#8217;s left behind is nothing but the specifics of the requirements, including that (highly coherent) graph.</p>
</div>
<div class="paragraph">
<p>Now you can choose to go ahead and represent that graph in text in one place, using many symbolic connections, and you would already be way, way better off than how we write conventional code. But even better is to do what the electronics guys do, and just build the tools to handle the graphs as diagrams properly.</p>
</div>
<div class="sect3">
<h4 id="truediagrams-and-text-are-not-equivalent"><a class="anchor" href="#truediagrams-and-text-are-not-equivalent"></a>Diagrams and text are not equivalent</h4>
<div class="paragraph">
<p>Diagrams and text are sometimes thought of as equivalent, as if they have a duality like waves and particles in physics. It is said to be a matter of personal preference which you use, and since graphical tools are hard to produce, why not use text? I do not agree with this. From the point of view of how our brain&#8217;s work best, they are very different, and each is powerful at its own job.</p>
</div>
<div class="paragraph">
<p>Consider an electronics engineer who uses a schematic diagram. Ask him to design a circuit using text and he will just laugh at you. Electronics naturally has a network structure that is best viewed and reasoned about as a diagram. If you turn a diagram into a textual list of nodes and connections, the brain can no longer work with it directly. It is constantly interrupted to search for symbolic references when it should be free to just reason about the design.</p>
</div>
<div class="paragraph">
<p>Most software naturally has an arbitrary network structure. Think about whenever you are working with legacy code - how often to you need to do "all files searches" or "find all references". And even those are foiled by indirections. Try designing or reasoning about a non-trivial state machine without using a diagram.</p>
</div>
<div class="paragraph">
<p>Text can readily be used to compose elements in a linear chain or sequence. It is excellent for telling stories. White space is the normal connector between the elements. Sometimes periods or other symbols are used instead. Text can also handle shallow tree structures, simply by using indenting. Compilers may use brackets, usually () or {}. Interestingly, the brackets work for the compiler, but not for the brain. The brain doesn&#8217;t see them, it just sees the indenting. So I personally don&#8217;t agree that Python&#8217;s significant indenting is a mistake as many do.</p>
</div>
<div class="paragraph">
<p>When the tree gets deep, the indenting is too deep for our brains to follow. So text is only suitable for linear structures and shallow trees. Structured programming and XAML are examples of tree structured code represented successfully in text.</p>
</div>
<div class="paragraph">
<p>Text becomes troublesome when there are arbitrary connections across the structure forming a graph. It must be done with matching names, labels or identifiers. Most imperative programs are actually not a tree structure because of the variables. They must be done with labels. Local variables in a small scope are not a problem. It only requires an editor that highlights all of them. For large scopes we end up spending too much time finding and trying to remember the connections, resorting to many all-files searches. It is a cumbersome way to try to reason about what is usually a reasonably simple structure when viewed as a diagram.</p>
</div>
<div class="paragraph">
<p>(When we talk about labels, we are talking about labels that are used for connecting two or more points. These labels are not abstractions. References to the names of abstractions are absolutely fine, and we don&#8217;t draw lines for them even if we are using a diagram. We always just use abstractions by their name.)</p>
</div>
<div class="paragraph">
<p>When we need to compose instances of abstractions in an arbitrary network structure, our brains work much better using a diagram. The brain can readily see and follow the lines between the instances of the abstractions. Unlike with text labels, the lines are anonymous, as they should be. When symbolic connections are used, the symbols themselves need an encapsulation scope. Lines don&#8217;t need encapsulation. They quietly connect two point without any other code seeing a symbol.</p>
</div>
<div class="paragraph">
<p>Generally lines connect only two points or ports, but sometimes may connect three or more. To understand all places connected by a symbolic connection requires an all files search. To understand all places connected by lines, the brain just follows the lines instead.  The spacial positioning of elements is also something the brain readily remembers. So, diagrams can qualitatively do things that text simply cannot.</p>
</div>
<div class="paragraph">
<p>If lines connect a high number of ports, it starts to smell as if a new abstraction may be waiting to be discovered.</p>
</div>
<div class="paragraph">
<p>ALA does not require a diagram per se. It only requires abstraction layering, and it&#8217;s quite possible for a user story to just consist of a linear sequence of abstracted operations. For example, a sequence of movements by a robot or a "Pipes and Filters" sequence of operations on data. However, ALA is a polyglot programming paradigm because user stories will generally combine multiple programming paradigms: UI, event-flows, dataflows, state machines, data schemas, etc. These aspects of a user story tend to be naturally interrelated (inherent in the requirements), which is what causes the resulting relationships among its instances of abstractions to be a graph. Diagrams, then, embrace the bringing together of all these different interrelationships of a user story in one cohesive place.</p>
</div>
</div>
<div class="sect3">
<h4 id="trueno-xml-as-code"><a class="anchor" href="#trueno-xml-as-code"></a>No XML as code</h4>
<div class="paragraph">
<p>If dependency injection is used to implement the wiring, I prefer not to use XML to specify the application. Firstly XML is not very readable. Secondly it only handles tree structures well, not networks, and it becomes more unreadable if the tree is deep. If you must use text for specifying wiring, use normal code. Represent the diagram as a tree as much as possible, and use indenting to represnet that tree. Any nodes that need cross connections should be saved in local variables. The cross connections can then be wired using the variables. You will see this done in many of the examples.</p>
</div>
<div class="paragraph">
<p>You are still better off with this code in one place than having it distributed inside your modules. But if a graph structure is inherent in the requirements, there is really no substitute for the readability of diagrams. In time there will be good tool support for ALA applications.</p>
</div>
</div>
<div class="sect3">
<h4 id="truediagramming-tools"><a class="anchor" href="#truediagramming-tools"></a>Diagramming tools</h4>
<div class="paragraph">
<p>The ALA design process (which is describing your requirements and inventing the needed abstractions as you go) is an intense intellectual activity, especially the first time in a new domain. As well as expressing your user stories, you are inventing abstractions. You are inventing a set of domain abstractions and programming paradigms that will allow you to express all user stories with a finite number of them. It requires all your focus. I have found that hand drawing the diagram on paper is not good. The diagram quickly gets into a mess which requires redrawing, and that interrupts your design flow. I have found that a diagramming tool that constantly needs you to control the layout, such as Visio, is also not good.</p>
</div>
<div class="paragraph">
<p>So until there is a better tool, I have been using Xmind because as a mind-mapping tool, it is designed to not get in your way as you are creating. It lays itself out as a tree structure, and then allows cross connections on the tree to be added using a key short-cut at the source and a mouse click at the destination node. It has its limitations, however I use some simple conventions to get around these. For example, I use '&lt;' and '&gt;' to represent input and output ports.</p>
</div>
<div class="paragraph">
<p>Furthermore, the tree structure allows easy hand translation of the diagram into indented, fluent style code.</p>
</div>
<div class="paragraph">
<p>While Xmind allows you to be creative in the beginning (I couldn&#8217;t imagine doing without it), it is far from ideal once the abstractions have matured, and you are just churning out user stories.</p>
</div>
<div class="paragraph">
<p>We use a simple tool that takes Xmind files and generates the code automatically.</p>
</div>
<div class="paragraph">
<p>And even more recently, we have in progress a purpose built graphical IDE for ALA. But it is not complete.</p>
</div>
<div class="paragraph">
<p>See the end of this chapter for an example project using Xmind.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Thoughts on the essentials of a diagramming tool.

It would have the low driving overhead of a mind mapping tool. As with a mind-mapping tool, you control the logical layout, and the tool does the actual spacial positioning. It would primarily use keypresses, but allow mouse clicks where it makes sense, for example, to specify the destination of a 'cross connection'. The tool would route the cross conenction for you.

A tree topology can be done with simple key presses. The tree would capture the primary relationships between instances, on their main ports.

You can make mutiple trees for different user stories that are disconnected logically, but for the purpose of automatic layout, are connected to the main tree (just an invisible line).

Abstractions are defined in a separate panel as stand-alone boxes with ports. Once a new abstraction is  defined, it can be instantiated in the diagram by its abstraction name with auto completion. Boxes represent these instances of abstractions with the ports still lablled around their boundary.

The abstractions are fully inegrated with the classes in the code. This is in both directions. So for any existing classes, the IDE shows them with their port, and fully supports the entry of constructor arguments and properties.

In the other direction, if you create a new abstraction in the tool. You can specify its ports and their types and names. You can specify the constructor arguments and properties and their default values. It will create/modify a template for that class.cs.

The tool's purpose is to aid creativity in the ALA process of representing a user story, inventing new abstractions as you go. Of course the tool would also automatically generate the wiring code.</pre>
</div>
</div>
<div class="paragraph">
<p>In my experience, a low overhead drawing tool is essential during the iteration zero design phase and during subsequent maintenance.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="truecomposition-not-decomposition"><a class="anchor" href="#truecomposition-not-decomposition"></a>Composition, not decomposition</h3>
<div class="paragraph">
<p>In this perspective, we look at ALA as the antithesis of the prevalent decomposition methodolgy.</p>
</div>
<div class="paragraph">
<p>The conventional technique for tackling system complexity is "divide and conquer".</p>
</div>
<div class="paragraph">
<p>Consider this phrase, which has been used as the definition of software architecture:</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>"<span class="red"><strong>decomposition</strong></span> of a system into <span class="red"><strong>elements</strong></span> and <span class="red"><strong><em>their</em></strong></span> <span class="red"><strong>relations</strong></span>".</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Notice the word 'their', which I have italicised to emphasis that the relations are inferred to be between the decomposed elements. It suggests that the decomposed elements know something about each other, that they collaborate to create the whole.
In ALA we think about building the system in a completely different way. Here is how to reword the meme for ALA:</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>"<span class="green"><strong>composition</strong></span> of a system using <span class="green"><strong>instances</strong></span> of <span class="green"><strong>abstractions</strong></span>".</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This seemingly subtle shift in thinking leads to a qualitative difference in the resulting structure.</p>
</div>
<div class="paragraph">
<p>First let&#8217;s understand what we mean by composition through a few examples:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>When we compose musical notes, we create a tune. The structure is linear. The execution is sequential like activity flow below.</p>
</li>
<li>
<p>When we write code in a general purpose programming language, we are composing  statements. Statements are low level (fine grained) elements and only support a single programming paradigm, which we could describe as 'imperative', but by composing enough instances of them we can create a program. The structure is a linear or a tree.</p>
</li>
<li>
<p>In functional programming, we are composing with functions, so the elements are higher level things that you create. But the programming paradigm is still imperative (unless you use monads). The structure is either linear or a tree.</p>
</li>
<li>
<p>When programming with monads, we are composing with what they call 'amplified data types'. These are usually low-level elements. But the programming paradigm has changed from imperative to dataflow. The structure is usually linear, but sometimes it is a revese tree (two flows can combine). (You don&#8217;t need to understand or use Monads to use ALA. however,
<a href="#Monads">See my method to understand Monads in Chapter Six</a></p>
</li>
<li>
<p>When programming using the UML class diagram, we are composing with classes directly (not objects). The programming paradigms are associations and inheritance.</p>
</li>
<li>
<p>When programming using the UML activity diagram, we are composing activities to be done in a set order. The structure is a graph, because you can branch, recombine and loop back arbitrarily. Activity diagrams are not imperative (like the old style flow diagrams). The CPU is not necessarily dedicated to each activity being done. Activities may take an arbitrarily long time without the system blocking.</p>
</li>
<li>
<p>When programming with XAML, we are composing UI elements. The programming paradigm is UI layout (what goes inside what and in what order). The structure is a tree.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Let&#8217;s list the different properties present in these types of composition:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Low-level or high-level - Sometimes we are composing fine-grained general elements and we need a lot of them. Sometimes we are composing 'higher level' more specific elements, and we need relatively few of them.</p>
<div class="paragraph">
<p>Note that sometimes people think of these higher level elements as more abstract. They are actually less abstract. For example, a class that handles complex numbers is less abstract than the fundamental float type. Complex numbers are a more specific case because its only useful when you need complex numbers in your solution. But when you do need complex numbers, then they are obviously more expressive than using pairs of floats everywhere. This means that you need to compose less abstractions to build your solution.</p>
</div>
</li>
<li>
<p>There is only one meaning of a composition relationship in each case. It can be one of imperative, dataflow, UI layout etc.</p>
</li>
<li>
<p>Linear/Tree/Network: The structure built by the composition relationships can be linear, a tree structure or a general graph or network.</p>
</li>
<li>
<p>Syntax: The syntax for the composition of two joined elements can be using spaces, dots, or lines on a diagram. We can use various types of bracketing or indenting for the text form of tree structures.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In ALA, we are setting up to use composition to create user stories or features. We want the composition to have the following properties:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Composing more course grained expressive elements by letting them be specialized to your domain.</p>
</li>
<li>
<p>Allow use of many programming paradigms (meaning of composition)</p>
</li>
<li>
<p>Allow linear, tree or graph structures.</p>
</li>
<li>
<p>Allow the programmer to add new programming paradigms with new meaning if that&#8217;s the best way to express typical requirements.</p>
</li>
<li>
<p>Uses the same syntax for all the different composition relationships.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>ALA can therefore be thought of as a 'generalised compose from abstractions' methodology.</p>
</div>
</div>
<div class="sect2">
<h3 id="trueno-data-coupling"><a class="anchor" href="#trueno-data-coupling"></a>No Data coupling</h3>
<div class="paragraph">
<p>The term <em>data coupling</em> here doesn&#8217;t mean that one module communicates data with another.  It means that the two modules agree on the meaning of that data.</p>
</div>
<div class="paragraph">
<p>The actual communication of data at run-time is not a problem. The sharing of knowledge on how to interpret that data is.</p>
</div>
<div class="paragraph">
<p>In conventional programming, data coupling is considered unavoidable. There is a misconception meme that two modules have to share the knowledge of the meaning of data if they are to communicate at run-time. Even if you have an understanding of ALA, you will still be trapped by this misconception unless you know about it. This will cause you to write modules in the conventional way and they will have coupling.</p>
</div>
<div class="paragraph">
<p>The misconception is especially rife if the two modules run in different locations. It seems a self-evident truth that the two modules must share some kind of language if they are to communicate, just as people do.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s use an example. There is a temperature sensor on a Mars rover. The temperature is to be displayed at a ground station on Earth.</p>
</div>
<div class="paragraph">
<p>In conventional programming, to implement this user story, one module resides in the Mars rover and one module resides in the ground station. These two modules must agree on the meaning of data. For example, it is an integer number of tenths of degrees C (Celsius).</p>
</div>
<div class="paragraph">
<p>Obviously a lot of other system parts are involved in transporting the data from the sensor module to the display module. These are referred to as middleware. It is common to <em>containerise</em> the data so that none of the middleware needs to know its meaning. But the two end points at least seemingly must have shared knowledge.</p>
</div>
<div class="paragraph">
<p>In ALA, the <em>meaning</em> of the communication is completely contained inside another abstraction. That abstraction is the only one that knows about the user story, so it&#8217;s the only one that needs to know the meaning of the data going from Mars to Earth.</p>
</div>
<div class="paragraph">
<p>Here is the user story implementation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">class AmbientTempertureUserStory {
    new TemperatureSensor()
        .WireIn(new OffsetAndScale(4.3, 712))
        .WireIn(new Display("#.#"))
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The meaning of the temperature data does not need to be known outside of this small abstraction. It does not need to be known by the sensor itself, or the display, or anything in-between. The meaning only needs to be known by the engineer who wants the sensor on the rover and wants to see what it says on the display, and so wites the above code.</p>
</div>
<div class="paragraph">
<p>Now if he were to change the units of temperature were to change, only this user story abstraction would change. Just change the OffsetAndScale configuration, and change the way the display is formatted.</p>
</div>
<div class="paragraph">
<p>It doesn&#8217;t even matter if software needs to interpret the data. For example, let&#8217;s add an alarm that goes off at 50 C:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">    new TempertureSensor()  // unit is celcius
        .WireIn(new OffsetAndScale(4.3, 712))
        .WireTo(new Display("#.#"))
        .WireTo(new Alarm(500));</code></pre>
</div>
</div>
<div class="paragraph">
<p>The interpretation of the data is still contained inside the user story abstraction. Everything about that temperature is here as cohesive code.</p>
</div>
<div class="sect3">
<h4 id="truedeployment"><a class="anchor" href="#truedeployment"></a>deployment</h4>
<div class="paragraph">
<p>The user story code spans physical locations. So how do those instances of abstractions get deployed?</p>
</div>
<div class="paragraph">
<p>Inside the user story abstraction, we can annotate the three instances with their physical locations. An abstraction that knows about the concept of <em>physical view</em> would already have been configured to know about the three physical locations. The physical view engine takes care of deploying the instances of abstractions for the user story to the correct locations, configuring them, and it takes care of actually connecting both ends through middleware. It also knows how to take care of version compatibility, and updating versions at different times at different locations.</p>
</div>
</div>
<div class="sect3">
<h4 id="truemodules-written-by-different-parties"><a class="anchor" href="#truemodules-written-by-different-parties"></a>modules written by different parties</h4>
<div class="paragraph">
<p>What happens if one end of the user story is written by a team that has no communication with the team who does the user story. They just provide an API. In this case the team responsible for the user story itself will write an adapter for the API that also knows about the common programming paradigm abstraction. We can still have a separate abstraction to repesent the whole user story, and keep the data coupling contained in the adapter.</p>
</div>
<div class="paragraph">
<p>The idea of no data coupling of course relies on the common programming paradigm. It relies on the teams who write the domain abstractions (or the adapters) all using that programming paradigm. And it relies on having a spearate team responsible for the user story, and all teams agreeing to use ALA and the common programming paradigm.</p>
</div>
<div class="paragraph">
<p>But there is an organisational problem in the form of Conway&#8217;s law.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Conway's law: Any organisation that designs a system will produce a design whose structure is a copy of the organisation's communication structure.</pre>
</div>
</div>
<div class="paragraph">
<p>It is unlikely that there would be a dedicated team in an organisation to write all the code for a specific user story if the user story spans different locations, or code written at different times. These are likely to fall to entirely different departments who both expect the two parts of the system to communicate between an agreed API and contract. In this siutaion there cannot be a separate abstraction for the user story, because there is no department for it.</p>
</div>
<div class="paragraph">
<p>So there will be collaboration in the code at each end in the form of data coupling. There will need to be be contracts. The contracts will describe all the implicit coupling. The contract will be a second source of truth, which must be kept updated.</p>
</div>
<div class="paragraph">
<p>In this situation it is still possible to mitigate the effects of coupling somewhat. Let&#8217;s say the display end has been written by the 3rd party, but is written in such a way that it accepts <em>self describing data</em> according to a standard. Effectively this is just making it more abstract. Without changing the display end, the user story can be implemented from scratch by sending to the display the self describing data. The display then knows how how to receive the label and display format (which can be sent once) as well as the numeric data. The display knows how to create a space for displaying the data. This is how browsers work.</p>
</div>
<div class="paragraph">
<p>It is common, for example, for a 3rd party to provide a sensor and publish the data on an MQTT server as self describing data. Say the other team is writing an application to use this data, not only display it, but interpret the data as well. They will subscribe to the topic. They will write code that is coupled with design knowledge provided by the 3rd party about the MQTT topic.</p>
</div>
<div class="paragraph">
<p>However, if the 3rd party is selling you abstract sensors that you install yourself and selling you the MQTT communication infrastructure, then you could be provided with a more abstract 'configuration API' from the 3rd party. You would then write a domain abstraction that knows about that configuration API. Whenever you want to do a new user story, you can use an instance of that 'device configuration' abstraction. You can fully configure the MQTT topic, and its data format, then subscribe to it and process it. Everything specific to the user story is now cohesively contained inside a single abstraction once again.</p>
</div>
</div>
<div class="sect3">
<h4 id="true3rd-party-library-abstractions"><a class="anchor" href="#true3rd-party-library-abstractions"></a>3rd party library abstractions</h4>
<div class="paragraph">
<p>All the above applies when teams are supplying peer modules for a system. The modules have a similar level of abstraction. If the 3rd party is providing something more abstract like a library, we can choose to be directly dependent on it, if it is abstract enough to be considered part of the language we want to write user stories in. The canonical example is a relational database with the abstraction being SQL.</p>
</div>
<div class="paragraph">
<p>The common problem here is that if the abstraction comes from a 3rd party, we are making ourselves dependent not only on the abstraction, which is ok, but on the provisioning of the implementation. This may be okay when we choose to depend on, for example, the windows or MacOS operating system, but is dubious for a database. (Actually its not ok for Windows either, but being able to swap out windows is considered too hard). So it&#8217;s become good practice to allow swapping out of the database. And since SQL is not quite as abstract as it should be between vendors, it means we don&#8217;t want to be dependent on SQL either.</p>
</div>
<div class="paragraph">
<p>Clean architecture suggests to do this by using interfaces specific to the user stories, and then writing adapters for every interface to SQL.</p>
</div>
<div class="paragraph">
<p>In ALA, you probably already have a 'tabular dataflow' type of programming paradigm. All abstractions that deal with tabular data already use ports of that type.</p>
</div>
<div class="paragraph">
<p>It is a matter of writing one adapter that is configured with the schema. The adapter then generates the appropriate SQL queries.</p>
</div>
<div class="paragraph">
<p>TBD provide code example of a lazy tabular programming paradigm, something like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">    interface ITabularDataflow : IQueryable&lt;dynamic&gt;
    {
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can write a Query domain abstraction that takes a linq query as a parameter. This one abstraction allows us to use LINQ&#8217;s From, Select, SelectMany, Sort, Where, Join etc. The query abstraction is then has ports to make it wirable into a user story using ALA. Since Linq is already compliant with ALA from the point of view of composing data manipulation abstractions, there is no reason not to use it directly in this way.</p>
</div>
<div class="paragraph">
<p>TBD Write a query abstraction that takes a LINQ query as a parameter and has ITabularDataflow&lt;T&gt; ports. Shouldn&#8217;t be too hard so full code can go here.</p>
</div>
<div class="paragraph">
<p>TBD Write an abstract adapter for SQL Lite database with a special port that is used directly by the Query abstraction.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="truecomposability-and-compositionality"><a class="anchor" href="#truecomposability-and-compositionality"></a>Composability and Compositionality</h3>
<div class="paragraph">
<p>We have used the word <em>compose</em> a lot so far in describing ALA. The term <em>Composability</em> means the ability to create an infinite variety of things by composing instances of a finite number of things.</p>
</div>
<div class="paragraph">
<p>Composability is a very important property for dealing with complexity. The Principle of Compositionality states: In mathematics, semantics, and philosophy of language, the principle of compositionality is the principle that the meaning of a complex expression is determined by the meanings of its constituent expressions and the rules used to combine them.</p>
</div>
<div class="paragraph">
<p>Brian Beckman, who does the best explanation of monads I have found in "Don&#8217;t fear the monad" says that composability is <em>the</em> way to deal with complexity.</p>
</div>
<div class="paragraph">
<p>Jules Hedges says of this property "I claim that compositionality is extremely delicate, and that it is so powerful that it is worth going to extreme lengths to achieve it."</p>
</div>
<div class="paragraph">
<p>In software engineering, it is described by a pattern called "Abstract Interactions" or "Configurable Modularity" by Raoul de Campo and Nate Edwards - the ability to reuse independent components by changing their interconnections but not their internals. It is said that this characterises all successful reuse systems.</p>
</div>
<div class="paragraph">
<p>ALA has these properties by using domain abstractions with ports. The ports are instances of programming paradigms. The domain abstractions are the constituent expressions, and the programming paradigms are the rules used to combine them.</p>
</div>
<div class="paragraph">
<p>There are other software systems that have composability, usually using the dataflow programming paradigm, such as RX (Reactive Extensions), or more generally monads. Most composability systems are restricted to a single paradigm. In ALA, to achieve the correct level of expressiveness of requirements, multiple different programming paradigms are needed.</p>
</div>
</div>
<div class="sect2">
<h3 id="trueala-compared-with-object-oriented-programmingp"><a class="anchor" href="#trueala-compared-with-object-oriented-programmingp"></a>ALA compared with Object oriented programmingp</h3>
<div class="paragraph">
<p>Lets start with Brian Will&#8217;s explanation of why object oriented programming is crap from his Youtube channel:</p>
</div>
<div class="paragraph">
<p><a href="https://www.youtube.com/watch?v=QM1iUe6IofM">https://www.youtube.com/watch?v=QM1iUe6IofM</a></p>
</div>
<div class="paragraph">
<p>I am in agreement with Brian in that trying to associate <em>all</em> code with data causes inappropriate fragmentation of the code, encourages a model of collaborating agents, and creates a dependency hell.</p>
</div>
<div class="paragraph">
<p>The idea of encapsulation is only partially realized because objects reach into each other&#8217;s data indirectly.</p>
</div>
<div class="paragraph">
<p>Also the UML class diagram encourages relationships directly between classes, which should be uncoupled abstractions. It encourages mutable data. And it encourages a horrendous model of agents interacting with each others data in a multithreaded environment. To solve this, Brian advocates a return to procedural programming and provides several examples which demonstrate that procedural programming is better.</p>
</div>
<div class="paragraph">
<p>Although ALA uses objects, it is not object oriented. You don&#8217;t try to model everything with objects and you can&#8217;t create associations between classes. It uses objects as a language feature, not a design philosophy. Objects are used in ALA for the following four reasons.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Objects store references to other objects to which they are wired. A form of dependency injection is used to receive the references to the other objects.</p>
</li>
<li>
<p>Domain abstractions, being reusable entities, often need configuring. The object stores its own configuration data passed in the constructor or via setters.</p>
</li>
<li>
<p>Some abstractions need state to work internally. For example an abstraction that implements a low pass filter for a dataflow needs to keep some kind of historical value or values. It is inherent in the nature of the abstraction that it has state.</p>
</li>
<li>
<p>There is usually some state data that doesn&#8217;t belong with any code. In ALA we will often create a special domain abstraction called 'state' that acts as a source or destination for dataflows.</p>
</li>
</ol>
</div>
<div class="sect3">
<h4 id="truedependency-injection"><a class="anchor" href="#truedependency-injection"></a>Dependency injection</h4>
<div class="paragraph">
<p>The dependency injection pattern was introduced as an attempt to clean up the dependency mess created by OOP. It came too late to make the famous GOF patterns book. The authors wish they had included it instead of singleton. But dependency injection alone does not solve OOPs problems.</p>
</div>
<div class="paragraph">
<p>Previously we mentioned the use of dependency injection in ALA by using the wiring pattern to wire up instances of abstractions by their ports. The way this dependency injection is done is quite different to container based dependency injection.</p>
</div>
<div class="paragraph">
<p>Container based dependency injection works by matching interface types. The interfaces are implemented by one class, and required by another. The matching of this interface type is the implicit wiring of the two classes. There is no place where you can see the wiring explicitly. This is really bad. It is very difficult to trace the flow of a user story through the classes.</p>
</div>
<div class="paragraph">
<p>Now a class may be substitutable with another class that implements or provides the same interfaces. That&#8217;s why there is a container. You instantiate an object of the class you want to wire in, and put it into the container. But this is a far cry from general composability.</p>
</div>
<div class="paragraph">
<p>In ALA interfaces do not belong to one or other of the classes being wired. They are more abstract and represent a compositional concept which we call a programming paradigm. When a domain abstraction uses one of these abstract interfaces, either implementing it or using it, we call it a port. The abstraction has no implicit fixed arrangement with other abstractions. A separate abstraction in a higher layer is needed to specify how instances of these abstractions with ports should be composed.</p>
</div>
<div class="paragraph">
<p>Note that ALA is extremely polymorphic. That&#8217;s because from the point of view inside an abstraction with ports, you do not know where that port will be wired to. Despite the use of polymorphism for wiring up everything, there is none of the usual disadvantage of indirection. In fact it is way easier to trace through a proram or system. From inside an abstraction, the abstraction doesn&#8217;t need or want to know where it is wired. It&#8217;s completely self-readable up to the port. And if you are trying to trace a dataflow through the program or system, well that&#8217;s explicit and all in one place for any given user story.</p>
</div>
<div class="paragraph">
<p>Chapter six also has a section on comparing ALA with dependency injection, and covers XML configured dependency injection.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="truefrom-procedural-programming-to-ala"><a class="anchor" href="#truefrom-procedural-programming-to-ala"></a>From procedural programming to ALA</h3>
<div class="paragraph">
<p>Let&#8217;s get back to procedural programming that Brain Will advocates instead of object oriented programming. How would ALA relate to procedural programming?</p>
</div>
<div class="paragraph">
<p>Starting from pure procedural programming and applying ALA, we can see in the progression of the following five points that we use of objects as a programming language feature in ALA, but not object oriented programming per se:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>To begin with, you can apply ALA directly to procedural programming style. Abstractions are implemented a group of procedures. You must structure the code so that you only call procedures in an abstraction that is significantly more abstract. You will have user story abstractions in the top layer, and domain abstractions in a second layer. Procedures that directly code a given user story are put together to form a user story abstraction. Procedures that are cohesive in the domain layer, such as configure/read/write sets are also grouped together as abstractions. Such abstractions could be implemented as a code source file or a static class.</p>
</li>
<li>
<p>Once you have abstractions, you can of course reuse them. Abstractions often need configuring. Configuring requires storing some data. We can put the configuration data inside the abstraction, and provide constructor parameters or setters. Since the abstraction now contains some data, the abstraction needs to be implemented as a class so that it can be instantiated with each instance having it own configuration.</p>
</li>
<li>
<p>In procedural programming, the user story will frequently call one procedure, get some data returned by that procedure and then pass it straight to another. This handling of data is not really something the abstraction should need to do. It should just compose procedures. But if we make the abstractions classes, then we can wire the instances so that at run-time data flows directly from one instane to another. Now we have two reasons to use classes.</p>
</li>
<li>
<p>In procedural programming, you will tend to have some state variables, which are like globals. We wont call them globals because we wouldn&#8217;t access them directly from any procedures. We would instead always pass them into the procedures as required. This would create extra parameters for our procedures. Some procedures will need extra parameters even though they don&#8217;t know what the data is. They are just passing it through to other procedures they call. All this extra passing around is a real pain. Some of the data may really belong with a given abstraction, so the pain seems to make no sense. Moving the data outside the abstraction and always passing it in It is breaking the abstraction. For example, say the abstraction is a running average. It needs to keep an internal state of the last n data points.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>For these cases we will put the data back inside the abstraction. We can do this either for user story abstractions, or with domain abstractions. For domain abstractions, once again we will then need to implement the abstractions with classes so that each instance of the abstraction has its own state data. For user story abstractions, there is probably one instance per application, so the class could be static.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Lastly, there may still be state data that does not belong to a specific abstraction. This will be sitting around in a top layer looking like a global. In object oriented programming, this is the type of data we would stuff into a class anyway, and then have almost pointless accessor methods. The other classes then have harmful dependencies on these data classes which obfuscate the data flows through the system.</p>
<div class="paragraph">
<p>In ALA, what we do is create a state domain abstraction. This abstraction has dataflow input and output ports. Instances of the abstraction are a source/destination of data. We can create instances of it for each item of state data needed by the application. The application wires these instances into the dataflows of the appropriate user stories.</p>
</div>
<div class="paragraph">
<p>If the type system is dynamic, the state abstraction can hold any complex data structure, and the user stories it is wired to can use the data in a dynamic way.
Only the application layer knows the actual structure of the data at design-time.</p>
</div>
<div class="paragraph">
<p>If the type system is static, and we want to group data together in a single instance of a state abstraction, The application layer can use an explicit or implicit struct type. If explicit, the state abstraction will be a generic, and the struct type is passed to it at compile-time. User stories that are wired to the state instance will also have the struct type passed to them. The other way to do static typing is to use an anonymous struct when the generic state class is created, and then the user stories that are wired to it use type inferencing, if your language supports this.</p>
</div>
<div class="paragraph">
<p>Through the five steps above, we have transformed procedural code back into ALA code. We have used objects, but we did not use object oriented design. The resulting ALA version has these properties:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Control of execution becomes the responsibility of programming paradigms.</p>
</li>
<li>
<p>Passing data becomes the responsibility of dataflow types of programming paradigms.</p>
</li>
<li>
<p>Storing state data becomes a domain abstraction whose purpose is to store state data. It will act as a data source/destination for dataflows.</p>
</li>
<li>
<p>Despite the fact that we use objects, the ALA constraints avoid most of the problems of conventional object oriented programming. For example, both the configuration data, and the wiring data stored in an instance is immutable. Only instances of abstractions that contain state data are mutable and it this is clear from very nature of the abstraction.</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="trueala-compared-with-functional-programming"><a class="anchor" href="#trueala-compared-with-functional-programming"></a>ALA Compared with functional programming</h3>
<div class="paragraph">
<p>ALA could be applied to functional programming. Applying the ALA fundamental constraints would mean that abstractions must be pure functions. Functions can only call or use functions that are significantly more abstract than themselves.</p>
</div>
<div class="paragraph">
<p>ALA is about composition of abstractions to make new abstractions. When running composition code, we are building a program not executing a program. So in functional terms, we run code that composes functions to get a new function. The program is the top level such function. Later we will refer to this as deferred or lazy execution rather than immediate or eager execution.</p>
</div>
<div class="sect3">
<h4 id="truefirst-lets-understand-monads"><a class="anchor" href="#truefirst-lets-understand-monads"></a>First lets understand monads</h4>
<div class="paragraph">
<p>If you already understand monads, skip this section.</p>
</div>
<div class="paragraph">
<p>Programming by composing simple functions wont handle many scenarios that often come up in programming. For example, we may need to check if we got a result from a function before passing the result to the next function. Or we may be dealing with time, for example we may have a function that can&#8217;t return the result immediately, so the composition needs to arrange some kind of callback or similar so that when the result is ready it will be fed to the next function. Or a function may return an array or list of results, and we need to foreach over it before passing the individual values to the next function, and then join all those results.</p>
</div>
<div class="paragraph">
<p>In functional programming all these types of scenarios are handled with a single pattern called a monad.</p>
</div>
<div class="paragraph">
<p>In the above examples, we had a function that couldn&#8217;t just return a value ready to go straight into the next function. Well since we can&#8217;t return a value, what we do is make the function return something that represents the value. In many explanations of monads, we call this something a wrapped type, a container type, a type in a box, an amplified type, or just the notation M T. I don&#8217;t think any of these forms are helpful in all cases. The wrapped, container and box version don&#8217;t work well for deferred monads, which don&#8217;t actually contain a value. The term amplified just introduces another abstract concept which is unnecessary. And the notation M T seems a bit circular. (Besides M T is not a monad by itself. A monad requires three things, an Interface&lt;T&gt; plus a bind function plus a constructor to make object that implements Interface&lt;T&gt;.)</p>
</div>
<div class="paragraph">
<p>I prefer to think of functions returning an interface, IMonadName&lt;T&gt;. The interface may be an actual interface like IEnumerable&lt;T&gt; or it may be a class, in which case its the public interface of the class like List&lt;T&gt;.</p>
</div>
<div class="paragraph">
<p>The interface adds some extra capability over a simple type T. Interfaces are pretty versatile, so the added capability can be almost anything we like. For example, if we want the function to return null or a value, it can return an interface called IMaybe&lt;T&gt;. Indeed many implementations of the Maybe monad do use such an interface with two implementations, one for when there a value and one for when there is no value.</p>
</div>
<div class="paragraph">
<p>Here is a short description of why we would return an Interface&lt;T&gt; instead of a T for each of the example scenarios we mentioned above:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Maybe&lt;T&gt; monad - The function may not always be guaranteed to return a result of type T, for example it might have a divide by zero, so it returns a Maybe&lt;T&gt; instead.</p>
</li>
<li>
<p>List&lt;T&gt; monad - The function returns an array or list of T. For example, the function may be given a student and returns a list of their course names. If you are familiar with <em>map</em> and <em>reduce</em>, then this scenario completes the picture by adding <em>expand</em>.</p>
</li>
<li>
<p>IEnumerable&lt;T&gt; monad - like the List monad, but this time its deferred or lazy.</p>
</li>
<li>
<p>Task&lt;T&gt;, Future, Promise monad - The function can&#8217;t return the result right away. It needs to wait for IO or it may be that the purpose of the function is to delay. So the function returns a Task&lt;T&gt; object. The interface of Task&lt;T&gt; has a way of attaching a callback function or continuation to receive the result when it eventually comes.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In each case you can see that the function effectively returns an Interface&lt;T&gt; (which can be a class which is effectively an interface with one implementation).</p>
</div>
<div class="paragraph">
<p>We want to compose such functions together. Let&#8217;s call them <em>first</em> function and <em>second</em> function. If the first function returns an Interface&lt;T&gt; and the the second function takes a T, we can compose the functions, but we will need something to take care of getting the value from the interface and passing it to the second function. We will call this composing function <em>bind</em>. (It goes by other names such as =&#8658;, flatmap, and SelectMany.)</p>
</div>
<div class="paragraph">
<p>The bind function always starts with an Interface&lt;T&gt; and returns another interface, which can have a different type, Interface&lt;U&gt;. Bind function calls can be chained  in a fluent manner like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">var I4 = source.bind(first function),bind(second function).bind(third function);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that the functions would normally be expressed as lambda expressions such as x&#8658;x+1</p>
</div>
<div class="paragraph">
<p>To make it clearer what the types are, let&#8217;s expand the code, and put the function types in place of the functions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">Interface&lt;T&gt; I1 = source;
Interface&lt;U&gt; I2 = I1.bind(func&lt;T, Interface&lt;U&gt;&gt;);
Interface&lt;V&gt; I3 = I2.bind(func&lt;U, Interface&lt;V&gt;&gt;);
Interface&lt;W&gt; I4 = I3.bind(func&lt;V, Interface&lt;W&gt;&gt;);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The bind function does two things. 1) It takes a function as a parameter to be composed. 2) It knows how to take an interface and produce another similar interface, potentially with a different type.</p>
</div>
<div class="paragraph">
<p>The interface can be anything we want and the bind function will take care of whatever that thing is and make sure that whatever it is gets appropriately plumbed through to the next interface. We could, for the sake of a silly example, pipe through an audio stream if we really wanted to. The bind function would take care it, and the lambda expressions could be oblivious to it, or they could generate little sound segments to be inserted into the stream.</p>
</div>
<div class="paragraph">
<p>In addition to taking care of the piping from one interface to the next, the bind function also takes the value from the interface and gives it to the function. For example, in the second line it takes a value (or values) of type U from the interface (somehow) and gives it (them) to the first function.</p>
</div>
<div class="paragraph">
<p>The Interface returned by the function, in this case Interface&lt;U&gt; is not necessarily the one returned by the bind function. It has the same type but generally bind will create a new Interface&lt;U&gt; and use the one returned by the function in an appropriate way to get value(s) for the new one.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s describe what the bind function does for each of our example monad scenarios. In each case the bind function takes an Interface&lt;T&gt; and returns an Interface&lt;U&gt;. It is also passed a function which takes a T and returns an Interface&lt;U&gt;.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Maybe monad - The bind function uses the Interface&lt;T&gt; to see if there is a value present or not. If there is nothing it doesn&#8217;t even call the function. It just returns an new Interface&lt;U&gt; implemented by a nothing object. If there is a value, it gets the value and passes it to the function. The output of the function is returned by bind.</p>
</li>
<li>
<p>List monad - The bind function starts with a List&lt;T&gt;. Let&#8217;s say this is a list of students. It uses a for loop to get all the students one at a time. It passes each student to the function. Each call of the function returns a List&lt;U&gt;. Let&#8217;s say this is a list of courses for the student. The bind function then joins all the separate course lists together to make a single list of type&lt;U&gt; that it returns.</p>
</li>
<li>
<p>IEnumerable monad - The previous two monads, the bind function returned the results immediately. IEnumerable is our first example of a deferred monad. The bind function, which we call SelectMany for this type of monad, starts with an IEnumerable&lt;T&gt;. Let&#8217;s say T is a student. This is a deferred or lazy interface, so the bind function doesn&#8217;t use a for loop immediately as that would defeat the laziness, which we wan&#8217;t to preserve in the composed structure. Instead the bind function creates a new IEnumerable&lt;U&gt;. That new IEnumerable&lt;U&gt; will be used later to get values one at a time. It keeps internal state to know where it is up to. Let&#8217;s call this IEnumerable object the deferred IEnumerable. The deferred IEnumerable knows how to use the IEnumerable&lt;T&gt; to get the first value, which it gives to the function. The function returns an IEnumerable&lt;U&gt;. Lets call this IEnumerable the function iEnumerable&lt;U&gt;. Lets say U is student courses. The deferred IEnumerable knows how to get values from the function IEnumerable&lt;U&gt;, one at a time. When it has all of them, the deferred IEnumerable then gets the second T from the IEnumerable&lt;T&gt;, and gives that to the function. The function again returns an IEnumerable&lt;U&gt;. This process continues until all students are processed.</p>
<div class="paragraph">
<p>In C# the compiler can build such IEnumerables for you using the <em>yield return</em> syntax:</p>
</div>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">IEnumerable&lt;U&gt; SelectMany&lt;T,U&gt;(this IEnumerable&lt;T&gt; source, func&lt;T, IEnumerable&lt;U&gt;&gt; function)
{
    foreach (T t in source)
    {
        IEnumerable&lt;U&gt; ie = function(t);
        foreach (U u in ie)
            yield return u;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that the code in the function does not run immediately. The compiler sees the <em>yield return</em> and builds an IEnumerable&lt;U&gt;, which is what is returned by the function.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Task, future, promise monad - This is another deferred type of monad. The bind function starts with a Task&lt;T&gt; and immediately creates a new Task&lt;U&gt; which it returns. It also saves the new Task&lt;U&gt; so that a result can be put in it later. Let&#8217;s call this bindReturnTask. The bind function sets up a callback function (a continuation) to be called when Task&lt;T&gt; produces a result. At a future time the callback will run. The callback receives the value from Task&lt;T&gt; and calls the function, which returns a Task&lt;U&gt;. The function may itself produce a result at an even later time. So the callback then sets up a second callback function to be called when the Task&lt;U&gt; produces a result. The second callback function will run at a later later time. It receives the value from the Task&lt;U&gt; and puts it into the bindReturnTask.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">Task&lt;U&gt; Bind&lt;T,U&gt;(this Task&lt;T&gt; source, func&lt;T, Task&lt;U&gt;&gt; function)
{
    var bindReturnTask = new Task&lt;U&gt;(
        (x)=&gt;function(x)(
            (y)=&gt;bindReturnTask.Done(y))
        );
    return bindReturnTask;
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>State monad - The bind function takes the value and the state from the Interface&lt;T&gt;. It gives the value to the function which returns an Interface&lt;U&gt;. It takes the value and the state from Interface&lt;U&gt;, so now it has a new value and two states. TBD</p>
</li>
<li>
<p>IO monad - TBD</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The crux of what monads do is that they allow you to compose on two abstraction layers at the same time. In the higher layer you are composing relatively simple functions that do the specific requirement you want to do.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/MonadPattern.png" alt="MonadPattern">
</div>
</div>
<div class="paragraph">
<p>The functions go from T to Interface&lt;U&gt;. Often the function doesn&#8217;t need to produce an Interface&lt;U&gt; and you provide an alteranive composing function which takes functions that go from T to U instead, e.g. Select or map.</p>
</div>
<div class="paragraph">
<p>Meanwhile, in the lower layer, all sorts of common implementation details can be taken care of. These common implementation details are solved once at the lower level. The lower level goes from Interface&lt;T&gt; to Interface&lt;U&gt;. The use of an interface gives a lot of flexibility in what common implementation details you can take care of. You can put any capability you like in the interface, and write a suitable bind function to pipe it through from Interface&lt;T&gt; to Interface&lt;U&gt; in an appropriate way.</p>
</div>
<div class="paragraph">
<p>Because all these common implementation details are taken care of in the lower layer, it frees you up so that composing is just about combining abstraction to express requirements. This sounds very similar to the aims of ALA.</p>
</div>
</div>
<div class="sect3">
<h4 id="trueprogramming-paradigms-compared-to-monad-interfaces"><a class="anchor" href="#trueprogramming-paradigms-compared-to-monad-interfaces"></a>Programming paradigms compared to monad interfaces</h4>
<div class="paragraph">
<p>With this understanding of monads, we can compare composition with monads with composition with programming paradigms. Programming paradigms are often interfaces, and these interfaces are analogous to the monad interfaces. They take care of implementation details so that when you are composing you can ignore them and just .</p>
</div>
<div class="paragraph">
<p>Monads and ALA&#8217;s programming paradigms plus the WireTo function are very similar.</p>
</div>
<div class="paragraph">
<p>Programming paradigms are implemented with interfaces, so you can add in methods to do anything you like. In other words programming paradigms do for object composition exactly what monads do for function composition.</p>
</div>
<div class="paragraph">
<p>Like programming paradigms, monads are a more abstract compositional concept. The WireTo function is somewhat analogous to bind. Except that WireTo is more general. The same wireTo can be used for all wiring. The domain abstractions are what handle the functionality of the interface behind the scenes. As with monad programming, the code that does the actual composing using WireTo is pure functional code.</p>
</div>
<div class="paragraph">
<p>The big difference, then, is that in ALA you are composing plain objects (domain abstractions), whereas with monads you are composing pure functions.</p>
</div>
</div>
<div class="sect3">
<h4 id="trueversatility-of-composing-with-objects"><a class="anchor" href="#trueversatility-of-composing-with-objects"></a>Versatility of composing with objects</h4>
<div class="paragraph">
<p>Composing with objects is more versatile than composing with functions. Composing pure functions is essentially only a dataflow programming paradigm (although there are different variants of dataflow as there are in ALA as well). ALA supports composition using multiple ports on the same abstraction. A function usually has only two ports, an input and an output, both of which must be the same type of dataflows (although different underlying types). Functions that have more than one parameter are converted to successive functions of one parameter using closure objects to carry the other parameter (currying).</p>
</div>
<div class="paragraph">
<p>In ALA, a given abstraction can have many input or output ports. They can be of completely different programming paradigms, or there can be multiple ports of the same programming paradigms. Such abstractions are more versatile than functions. For example,  For example it is common to have a single domain abstraction with a UI port (to be displayed in the UI) and a event driven ports (for mouse clicks) and a dataflow port (for binding to a data source).</p>
</div>
<div class="paragraph">
<p>To be fair, some monad abstractions support two input ports. For example <em>Join</em> can merge two input IEnumerables. If the monads are based on IObservale, then presumably some monad abstractions support either fanout, or splitting into two streams. So the difference is really that domain abstractions can have multiple ports of different programming paradigms.</p>
</div>
<div class="paragraph">
<p>Composing with objects is a little more like electronics with ICs (integrated circuit chips with many pins), whereas composing with functions is more like electronics with transistors and resistors (devices that have one input and one output).</p>
</div>
</div>
<div class="sect3">
<h4 id="trueimmediate-and-deferred-execution-monads"><a class="anchor" href="#trueimmediate-and-deferred-execution-monads"></a>Immediate and deferred execution monads</h4>
<div class="paragraph">
<p>Monads are either immediate (eager) or deferred (lazy). Of the example monads given above, IEnumerable, Lazy and Future are all of the deferred type, whereas Maybe and List are immediate types.</p>
</div>
<div class="paragraph">
<p>Composing immediate monads means the bind function actually gets the value from the first monad and then passes the unwrapped value to the function. Composing deferred monads means returning a new monad that represents the binding together of the two. It is actually an object structure of connected monads and closure objects. The bind function never actually gets values or executes lambda functions itself.</p>
</div>
<div class="paragraph">
<p>ALA programming paradigms are always deferred execution. Both deferred monads and ALA programming paradigms are used to compose a structure which you then run after the wiring up is completed. They both have two phases, the wiring up phase and the run-time execution phase. However, in ALA, we tend to wire up the entire application first and then set it running. Deferred monads are often wired up and then executed all in the same statement, for example by ending a sequence of IEnumerable monads with a ToList().</p>
</div>
</div>
<div class="sect3">
<h4 id="truecomposing-with-plain-objects"><a class="anchor" href="#truecomposing-with-plain-objects"></a>Composing with plain objects</h4>
<div class="paragraph">
<p>As we said, the major difference between ALA and monads is that ALA composes using plain objects rather than functions. The only slightly unusual thing about these objects is the use of the term <em>ports</em> for their input/outputs. But the term <em>port</em> is readily understood. They are just a field, or an implemented interface, provided (most importantly) the interface is an abstract interface, which means it doesn&#8217;t belong to the object, but is abstract enough to be used by many objects.</p>
</div>
<div class="paragraph">
<p>By using plain objects the barrier to understanding seems lower than for monads, at least for developers already familiar with objects. Functional programming, and monads in particular, seem to have quite a high barrier to entry unless you are a mathematician. The world needs programmers who are able to get objects but don&#8217;t get math. I&#8217;m not sure what would happen if all universities only taught functional programming so that everyone is introduced to pure functions first. Perhaps then it would be objects which have a barrier to entry.</p>
</div>
<div class="paragraph">
<p>The concept of monads seems difficult to grasp because it is usually described in abstract terms, either in terse mathematical looking language or with some type of diagrams using boxed values to represent monads. I don&#8217;t believe the idea of a box or a container is a good metaphor for a monad. It may work for list and maybe, but it doesn&#8217;t work well for IEnumerable, Lazy or Future. A much better way is to think of the monad as an interface which gives you a way get the value(s) not a container for the values. (Of course to be a monad, in addition to the interface, we also need the composing operator for composing functions that take a value and produce the interface, and a unit function that turns a simple value into an object implementing the interface.)</p>
</div>
<div class="paragraph">
<p>Imperative/object language programmers often learn new concepts by learning how the underlying code works. Often concepts are explained in terms of syntactic sugar for some equivalent code that the programmer already understands. For example, a lambda expression can be explained as equivalent to a delegate pointing at a normal named function.</p>
</div>
<div class="paragraph">
<p>The reason why monads are umost often explained in abstract terms is that the equivalent code is even more complicated than the concept of monads itself. This is especially true of monads that have deferred execution. For example, in C#, composing a series of monad functions results in a network structure of monad objects, Delegate objects and closure objects. I did an exercise where I used reflection to write out the structure from a simple monadic expression like Wrap(1),Add(2).Divide(3) which is using the lazy monad. In addition to three monad objects, it has four Delegate objects and four Closure objects. Each monad object connects to a Delegate object, which connects to a closure object, which connects to both another monad object and another Delegate object, which connects to another closure object.</p>
</div>
<div class="paragraph">
<p>TBD show diagram of a monad expression structure</p>
</div>
<div class="paragraph">
<p>The network can be different for different monads. For example an expression using IEnumerable ends up with a different network of a monad (that does the iterating), and Delegate objects and closures objects. You couldn&#8217;t use this approach to explain monads, although it helped me a lot going through the exercise.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>By the way, a Delegate object contains a pointer to another object and a MethodInfo referencing a method in that object. Thus a Delegate object is just a reference to a method of an object. A closure object contains a single method, which is the lambda expression it was created from, together with some fields for the captured variables, which are variables used by the lambda expression from its containing scope. The compiler generates classes for these objects automatically.</pre>
</div>
</div>
<div class="paragraph">
<p>The equivalent network for an ALA structure is just the three instances of the domain abstractions, each with a field referencing the next.</p>
</div>
<div class="paragraph">
<p>In ALA you write new programming paradigms as a normal activity. In the functional world, you can certainly write new monad types, but it doesn&#8217;t seem that easy.</p>
</div>
</div>
<div class="sect3">
<h4 id="truestate"><a class="anchor" href="#truestate"></a>State</h4>
<div class="paragraph">
<p>Monads abstractions don&#8217;t keep state, whereas domain abstractions can.</p>
</div>
<div class="paragraph">
<p>Is this true? How do reducing type operations such as Max() do it without keeping state?</p>
</div>
<div class="paragraph">
<p>TBD find out if such monads do keep state?</p>
</div>
<div class="paragraph">
<p>Sometimes abstractions naturally contain state in their implementation details. I consider it better to keep the abstraction in tact and have it keep the state internally hidden than to polute the users with having to explicitly pass the state back and forth every time. For example, an instance of a low pass filter (running average) abstraction is best thought of as an abstraction with state. It&#8217;s analogous to using instances of a filter circuit in electronics. If we remove the state and try to pass it in with each new input data, we actually destroy the abstraction, and encumber the outside world with data if it doesn&#8217;t want to know about.</p>
</div>
<div class="paragraph">
<p>On the other hand, domain abstraction instances' internal code is generally not pure. Apart from internal state, they also store immutable configuration data, including their wiring to other instances. So they are not thread safe. As I&#8217;ve mentioned before, you should never use multithreading unless its for performance reasons e.g. latency deadline of the higher urgency threads. But it&#8217;s still valid to have multiprocessor hardware. So when using domain abstractions, you would need to be careful not to allow any given instance of a domain abstraction to be used by more than one thread. This implies that an entired wired stucture can only be used by one thread. Each thread would need a different copy of the wired structure.</p>
</div>
<div class="paragraph">
<p>Monads also keep state in the closure objects.  I guess with monads they are frequently wired and then executed and then they are gone. But sometimes, e,g, when wired to I/O they must be permanently wired up. Do they also have a one wired up structure per thread?</p>
</div>
</div>
<div class="sect3">
<h4 id="truewireto-vs-bind"><a class="anchor" href="#truewireto-vs-bind"></a>WireTo vs bind</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>ALA uses the WireTo function whereas monads use the <em>bind</em>, <em>flatmap</em>, SelectMany, =&#8658; function to do composition.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Monad version:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">Source.Bind(x==0 ? : new nothing() else new something(1/x));</code></pre>
</div>
</div>
<div class="paragraph">
<p>ALA version:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">Source.WireTo(new Expression(x==0 ? : new nothing() else new something(1/x)));</code></pre>
</div>
</div>
<div class="paragraph">
<p>More often in monad programming, we use a more specialized composing function whose name represents the type of abstraction being wired, such as Filter or Select. These composing functions either create the necessary monad function and call bind, or they do the equivalent.</p>
</div>
<div class="paragraph">
<p>Similarly in ALA, we usually have domain abstractions that are a little more specialized:</p>
</div>
<div class="paragraph">
<p>Monad version:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">Source.Reciprocal();</code></pre>
</div>
</div>
<div class="paragraph">
<p>ALA version:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="C#" class="language-C# hljs">Source.WireTo(new Reciprocal();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The Monad version is more succinct syntactically. For the ALA version, we could write a function called Reciprocal(), which instantiates a Reciprocal object and then passes it to WireTo. That would make the syntax identical to the monad version. However we don&#8217;t usually choose to do that. The reasons we don&#8217;t are:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>It would create a lot of very small functions that do very little. I prefer to just use the longer WireTo(new Abstraction()) syntax, which keeps it clearer what is going on.</p>
</li>
<li>
<p>In ALA, the first object being wired to may have multiple output ports of the same programming paradigm. WireTo has the ability to have overloads which name the port to be wired. Overloads such as this that specialize the behaviours of WireTo would need to be repeated for all the domain abstraction specific composing functions.</p>
</li>
<li>
<p>When graphical tools are used for the wiring, the WireTo code will be generated automatically, and it doesn&#8217;t matter what it looks like.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="trueusing-monads-within-ala"><a class="anchor" href="#trueusing-monads-within-ala"></a>using monads within ALA</h4>
<div class="paragraph">
<p>Although composing with objects can do everything that monads can do, that doesn&#8217;t means we want to reinvent an object version of every monad abstraction. If monad operations such as Filter, Sort, GroupBy, Join etc are already available, we want to be able to use them. Besides, monad composition is normally done with text because the composition is normally a linear sequence of operations. ALA composition is done with a diagram because when you express a whole user story, not just the dataflow operations, you tend to get a graph structure, not just a linear structure.</p>
</div>
<div class="paragraph">
<p>So it makes sense to create a domain abstraction in which you can put a monad sequence of operations as a parameter in text form.</p>
</div>
<div class="paragraph">
<p>TBD write such an abstraction for IObservable monads. Call it RX. Let it take a Linq RX expression as its configuration. Let it have one input and two output ports all of type DataflowPushSynchronous. Actually do an async version as well. Demonstrate by connecting it to an input source such as an array of data, and connect the two outputs to the console output. Have eit do various things such as Sort, Filter, Select, Split.
For the Async version, introduce a delay operator to slow them down.</p>
</div>
</div>
<div class="sect3">
<h4 id="truewith-monads"><a class="anchor" href="#truewith-monads"></a>with monads</h4>
<div class="paragraph">
<p>However there are other differenes:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Non-mathematicians find it hard to learn and use functional concepts, and even the syntax of functional languages. It is difficult for them to understand monads, never mind write them. On the other hand, these same programmers can readily understand the simpler concepts of imperative programming, and happily string together 100000 lines of it to create a system (even though that system is then unmaintainable).</p>
<div class="paragraph">
<p>By using plain objects, ALA is an easier concept to grasp, and writing domain abstractions is easier even than conventional code. The hard part is conceiving the abstractions and programming paradigms, which a senior ALA team member needs to do, then the abstractions can be readily delegated to junior programmers.</p>
</div>
</li>
<li>
<p>I have only seen monads using dataflow programming paradigms. ALA domain abstractions can use multiple programming paradigms, so that composition can mean anything you want. A given abstraction can have ports of different programming paradigms,</p>
<div class="paragraph">
<p>I&#8217;m not sure how far monads could go in this direction. Monads rely on the bind function returning the dataflow interface e.g. IEnumerable, ready for the next bind function in the chain to use. That implies there can be only one output port. The WireTo method returns the first object, so the next WireTo can wire any of the remaining ports of the same object. The WireIn operator returns the second object, so now WireTo or WireIn can wire any of its other ports.</p>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>I find that keeping the <em>WireTo</em> and <em>new</em> when instantiating abstractions demystifies how the whole thing works. Monads use methods defined on e.g. IEnumerable, that do both the <em>new</em> and the <em>bind</em>. This is better once you are used to it, because you can write e.g.</p>
</div>
<div class="paragraph">
<p>Queries tend to be a linear chain structure, or sometimes a structure with two sources combining into one stream. If monads are available to do what you want, make a domain abstraction called query, and when you instantiate a query you pass to it a query written using your available monads.</p>
</div>
<div class="paragraph">
<p>instead of monads. Although ALA uses objects, it is not object oriented as its primary design focus. It uses objects for the following four reasons.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Objects store references to other objects to which they are wired via their ports. These references can be considered immutable. This is similar to the way lazily evaluated monads work. Behind the scenes effective objects (probably closures) are created which are wired together.</p>
</li>
<li>
<p>Domain abstractions, being reusable entities, often need configuring. For example, a filter abstraction needs configuring with a cutoff frequency and a stop band rejection. The configuration data is immutable. If an abstraction consisted only of functions, then that configuration data would need to be passed in every time a function is used. That would be awkward. It would also mix the dataflow parameters of the functions with the configuration parameters, breaking the Interface Segregation principle. By using objects, ALA can configure an abstraction once, and then the contained function can be used may times. This separation of configuration and function use is important for abstractions - the configuration is done at instantiation time of the abstraction, whereas the function can be used many times once it is running. Monads can do the same thing.</p>
</li>
<li>
<p>Some abstractions need state to work. Most of the time, objects do not hold state data in ALA. Instead a sequence of dataflow objects is set up once, and when needed the data moves directly from the source to the destination. However, sometimes an abstraction by its very nature needs to hold some state. For example, a running average abstracton needs to hold past values. In pure functional programming, the array of past values becomes a global in a 'top layer' and is passed into the function every time. In ALA, we don&#8217;t want to break the abstraction by splitting the averaging code from its data. For cases like these, we become 'object oriented' and store the data in the object. Monads can also do this.</p>
<div class="paragraph">
<p>In a multithreaded environments, such a running average abstraction would need a separate instance for each thread.</p>
</div>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="truedependency-graphs-ala-vs-conventional-code"><a class="anchor" href="#truedependency-graphs-ala-vs-conventional-code"></a>Dependency graphs ALA vs conventional code</h3>
<div class="paragraph">
<p>Our example for this chapter compares dependency graphs for a legacy application and one with the same functionality written in ALA.</p>
</div>
<div class="paragraph">
<p>The legacy application had been maintained for approximately 20 years, so as might be expected, maintenance had become difficult. In fact there were certain new requirements we could not do because of the prohibitive effort. Normally I wouldn&#8217;t ever re-write an application. But I wanted to run a research experiment to see how ALA would work on it. I had intern students available, and it would give us an opportunity to compare metrics of the two code bases.</p>
</div>
<div class="paragraph">
<p>The original application has around 70 KLOC. Rather than look at any of the details of the application itself, we present here dependency graphs generated by Ndepend for the legacy application and the new ALA application.</p>
</div>
<div class="sect3">
<h4 id="truelegacy-application-dependency-graphs"><a class="anchor" href="#truelegacy-application-dependency-graphs"></a>Legacy application dependency graphs</h4>
<div class="paragraph">
<p>One of the core tenets of ALA (as discussed in an earlier section) is "Composition using layers" instead of "Hierarchical decomposition using encapsulation". Unfortunately Ndepend is designed with the assumption that the application should be built using the latter approach. It likes to present a decomposition structure, starting with assemblies (packages) at the outermost level, then namespaces, and then classes. I&#8217;m not sure why it considers namespaces a viable encapsulation mechanism because they don&#8217;t provide encapsulation. Anyway, here is the namespace dependency graph for the main assembly of the legacy version of the application, as it comes out of Ndepend.</p>
</div>
<div class="imageblock">
<div class="content">
<a class="image" href="images/old-datalink/namespaces.png"><img src="images/old-datalink/namespaces.png" alt="namespaces.png"></a>
</div>
<div class="title">Figure 1. Legacy application - namespaces</div>
</div>
<div class="paragraph">
<p>This graph is quite large, so if you like you can right click on it, and open it in a new tab in your browser. The red arrows are dependencies in both directions.</p>
</div>
<div class="paragraph">
<p>Each box represents a namespace. The thickness of the arrows is proportional to the number fo dependencies between pairs of namespaces. The size of the boxes is proportional to the number of lines of code in the namespace.</p>
</div>
<div class="paragraph">
<p>If we drill down into the largest namespace, UIForms, we see the class relationships between classes inside that namespace:</p>
</div>
<div class="imageblock">
<div class="content">
<a class="image" href="images/old-datalink/classes-in-uiforms-namespace.png"><img src="images/old-datalink/classes-in-uiforms-namespace.png" alt="classes-in-uiforms-namespace.png"></a>
</div>
<div class="title">Figure 2. Legacy application - classes in uiforms namespace</div>
</div>
<div class="paragraph">
<p>Here you can see that Ndepend is trying to make out the layers. The layers are vertical columns, going from left to right. I have left them vertical even through ALA abstraction layers are usually drawn horizontal because they come out more readable on the page. Again there are many dependencies in both directions drawn in red.</p>
</div>
<div class="paragraph">
<p>Here are the classes inside the DataStructure namespace:</p>
</div>
<div class="imageblock">
<div class="content">
<a class="image" href="images/old-datalink/classes-in-datastructure-namespace.png"><img src="images/old-datalink/classes-in-datastructure-namespace.png" alt="classes-in-datastructure-namespace.png"></a>
</div>
<div class="title">Figure 3. Legacy application - classes in datastructure namespace</div>
</div>
<div class="paragraph">
<p>There is one class called Device which actually looks like it might be a good abstraction.</p>
</div>
<div class="paragraph">
<p>As mentioned, namespaces provide no useful decomposition structure. They do not make abstractions in themselves, nor do they implement a facade pattern or an aggregate root type of pattern with even logical encapsulation. Any classes inside each namespace can have unconstrained direct relationships with any classes in any other namespace.</p>
</div>
<div class="paragraph">
<p>So Ndepend is giving us a false picture here, because it is omitting all dependencies that go in or out of the namespaces. To really get an idea of what the class dependency graph looks like, I configured Ndepend to use a query that gives me all the classes in all the namespaces. Here finally is what this application truly looks like:</p>
</div>
<div class="imageblock">
<div class="content">
<a class="image" href="images/old-datalink/classes-in-all-namespaces.png"><img src="images/old-datalink/classes-in-all-namespaces.png" alt="classes-in-all-namespaces.png"></a>
</div>
<div class="title">Figure 4. Legacy application - all classes in all namespaces</div>
</div>
<div class="paragraph">
<p>This graph is very large. Right click on it, and open it in a new tab in your browser, so you can zoom in to see the dependencies in the background. It is truly frightening. Ndepend had no chance to find the dependency layers. There may be vaque onion type layers going outwards from the middle. It makes readily visible why continued maintenance on this application is so difficult. You have to read a lot of code to find even a tiny part of this hidden structure.</p>
</div>
<div class="paragraph">
<p>The developer who maintains the application tells me this is a fair projection of the complexity that he has to deal with.</p>
</div>
<div class="paragraph">
<p>To be fair, some of the dependencies in this diagram are 'good' dependencies (as described in an earlier section on good and bad dependencies). For example, the box near south-east called ScpProtocolManager has a lot of dependencies coming into it, which means it is possibly used a lot and therefore is a potential good abstraction. Ndepend does not know about the concept of good and bad dependencies, but if it did I would have it just display the bad ones.</p>
</div>
</div>
<div class="sect3">
<h4 id="truenew-ala-application-dependency-graphs"><a class="anchor" href="#truenew-ala-application-dependency-graphs"></a>New ALA application dependency graphs</h4>
<div class="paragraph">
<p>Here is the equivalent Ndepend generated class dependency graph for the new ALA version of the application.</p>
</div>
<div class="imageblock">
<div class="content">
<a class="image" href="images/new-datalink/classes-in-all-namespaces.png"><img src="images/new-datalink/classes-in-all-namespaces.png" alt="classes-in-all-namespaces.png"></a>
</div>
<div class="title">Figure 5. New ALA application - classes in all namespaces</div>
</div>
<div class="paragraph">
<p>You can see the three ALA layers which are vertical and go from left to right. Only the Application sits in the top layer. The DomainAbstractions layer contains the next two columns of classes and a few from the next column. And the ProgrammingParadigms layer contains the rest on the right. Actually there were a couple of bad dependencies present when this graph was generated which have since been fixed. (There should be no dependency between Panel and OptionBox, nor between Wizard and WizardItem.) With these removed, the graph would form into the three abstraction layers.</p>
</div>
<div class="paragraph">
<p>The newly rewritten application is a work in progress at this point. However, as features are added, this is all the dependencies you will ever see. The Application already uses most of the domain abstractions we will ever need, and the domain abstractions already use the programming paradigm interfaces they need. There are a few DomainAbstractions to be added, but this is essentially what the  class dependency graph will look like.</p>
</div>
<div class="paragraph">
<p>This graph has the classes from all namespaces. But just for interest, here is Ndepend&#8217;s namespace dependency graph.</p>
</div>
<div class="imageblock">
<div class="content">
<a class="image" href="images/new-datalink/namespaces.png"><img src="images/new-datalink/namespaces.png" alt="namespaces.png"></a>
</div>
<div class="title">Figure 6. New ALA application - namespaces</div>
</div>
<div class="paragraph">
<p>Remember in ALA namespaces are layers. The dependencies are correct for the layers.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s drill inside the domain abstraction namespace to see the interdependencies within that layer. We expect to see no dependencies:</p>
</div>
<div class="imageblock">
<div class="content">
<a class="image" href="images/new-datalink/classes-in-domainabstractions-namespace.png"><img src="images/new-datalink/classes-in-domainabstractions-namespace.png" alt="classes-in-domainabstractions-namespace.png"></a>
</div>
<div class="title">Figure 7. New ALA application - classes in DomainAbstractions namespace</div>
</div>
<div class="paragraph">
<p>Ok here we see the two previously mentioned bad dependencies, and two other dependencies. They are on delegates or enums in the same source file, and so don&#8217;t count as bad dependencies.</p>
</div>
<div class="paragraph">
<p>And finally, let&#8217;s drill into the ProgrammingParadigms namespace</p>
</div>
<div class="imageblock">
<div class="content">
<a class="image" href="images/new-datalink/classes-in-programmingparadigms-namespace.png"><img src="images/new-datalink/classes-in-programmingparadigms-namespace.png" alt="classes-in-programmingparadigms-namespace.png"></a>
</div>
<div class="title">Figure 8. New ALA application - Classes in Programming Paradigms namespace</div>
</div>
<div class="paragraph">
<p>Again we see a few dependencies on delegates in the same source file which are ok. There is a couple of connector classes that depend on interfaces in this same layer. I consider them part of the interface from the programming paradigm point of view. They are in the same source file as a cohesive unit.</p>
</div>
<div class="paragraph">
<p>As of this writing, the new ALA version of the application is still a research project, but so far everything has gone smoothly with two weeks spent doing the description of the requirements as a diagram, and three months so far spent writing the domain abstractions. So far there are no issues getting it to actually execute. It is expected that we will actually commercialize the project soon and replace the old application.</p>
</div>
</div>
<div class="sect3">
<h4 id="truethe-applications-diagram"><a class="anchor" href="#truethe-applications-diagram"></a>The application&#8217;s diagram</h4>
<div class="paragraph">
<p>As we said in this chapter, diagrams can be an important aspect of ALA when the user story naturally contains a network of relationships among its instances of abstractions. In this application this is the case. There are UI relationships between elements of the UI. There are dataflow relationships between UI elements, data processing elements, and data sources. There are event-flows from UI to wizards and between wizards and the SaveFileBrowser. and there are minor dataflows such as a the filepath from the file browser to the csvFileReaderWriter.</p>
</div>
<div class="paragraph">
<p>Here is a sample section from the application diagram that shows all the relationships that implement the user story:</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="images/DatalinkApplication.xmind.png" alt="DatalinkApplication.xmind.png">
</div>
<div class="title">Figure 9. Xmind being used to design an application</div>
</div>
<div class="paragraph">
<p>This diagram was drawn using Xmind. It shows a single user story.  There is a UI with a menu item or a tool bar to start the user story. It then displays a browse dialogue to specify the location of the file. When the filepath has been selected, it gets data off a device on a COM port, using a protocol, and writes it to a CSV file. The data is also routed to be shown on a grid on the UI.</p>
</div>
<div class="paragraph">
<p>The user story diagram makes use of four different programming paradigms (which become four different interface types). Firstly there is the UI structure consisting of the window with its menubar, grid etc arranged inside it. Secondly, there is an event connection for when the menu is clicked which opens the browse dialog. Thirdly a dataflow connection carries the output of the browse dialog, a string containing the selected filepath, to the CSVFileReaderWriter. Another dataflow connection carries characters between the COM port and the SCPProtocol and another carries SCPcommands from the SessionDataSCP. The forth programming paradigm is a table dataflow that carries dynamic columns and rows of data from the SessionDataSCP object to the grid object in the UI and to the CSVFileReaderWriter.</p>
</div>
<div class="paragraph">
<p>Having drawn the diagram to represent the user story, we need to make the diagram execute. When we started this particular project we had no tool for automatically generating the code from the diagram, but during the project, one of the interns wrote a tool to do this. It parsed the Json output from Xmind and generated C# wiring code equivalent to what we will show below.</p>
</div>
<div class="paragraph">
<p>However, at first we were hand generating code, and it is instructive to know what this hand generated code looks like, just so we know how the diagram actually executes.</p>
</div>
<div class="paragraph">
<p>When we were hand generating the code, it was important that the code was readable from the point of view of seeing how it corresponds exactly with the diagram. (It wasn&#8217;t important that the code was readable from the point of view of seeing how the user story works - that was the job of the diagram.)  We had various conventions to support the one to one matching of diagram and code. One of these conventions was to indent the code to exactly mirror the tree structures in the diagram. Another was that whenever a new instance of an abstraction instantiated, all its ports would be wired immediately, and they would be wired in the order they were declared in the abstraction. This implies a depth first wiring strategy, analogous to walking the diagram tree depth first. Any ports with cross connections (the red lines in the diagram) would also be wired to their destinations at the time the abstraction were instantiated. If the destination instance did not already exist it would be pre-instantiated.</p>
</div>
<div class="paragraph">
<p>Using these conventions, it is a simple matter to hand generate the code below from the diagram.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>using System;
using System.Windows.Media;
using DomainAbstractions;
using Wiring;


namespace Application
{
    class Application
    {
        private MainWindow mainWindow = new MainWindow("App Name") { Icon = "XYZCompanyIcon"};

        [STAThread]
        public static void Main()
        {
            new Application().Initialize().mainWindow.Run();
        }

        private Application Initialize()
        {
            return this;
        }

        private Application()
        {
            var getInfoWizard = new Wizard("Get information off device") { SecondTitle = "What information do you want to get off the device?" };
            Grid DataGrid;
            var sessionDataSCP = new SessionDataSCP();
            var csvFileReaderWriter = new CSVFileReaderWriter();

            mainWindow
            // UI
                .WireTo(new Vertical()
                    .WireTo(new Menubar()
                        // XR3000
                        .WireTo(new Menu("File")
                            .WireTo(new MenuItem("Get information off device") { Icon = "GetDeviceIcon.png", ToolTip = "Get session data or LifeData or favourites from the device\nto save to a file or send to the cloud" }
                                .WireTo(getInfoWizard)
                            )
                            .WireTo(new MenuItem("Put information onto device") { Icon = "PutDeviceIcon.png" })
                            .WireTo(new MenuItem("Exit") { Icon = "ExitIcon.png" })
                        )
                        .WireTo(new Menu("Tools"))
                        .WireTo(new Menu("Help"))
                    )
                    .WireTo(new Toolbar()
                        // XR3000
                        .WireTo(new Tool("GetDeviceIcon.png") { ToolTip = "Get information off device" }
                            .WireTo(getInfoWizard)
                        )
                        .WireTo(new Tool("PutDeviceIcon.png") { ToolTip = "Put information onto device" })
                        .WireTo(new Tool("DeleteDeviceIcon.png") { ToolTip = "Delete information off device" })
                    )
                    .WireTo(new Horizontal()
                        .WireTo(new Grid() { InstanceName = "Sessions" })
                        .WireTo((DataGrid = new Grid() { InstanceName = "DataGrid" })
                            .WireFrom(sessionDataSCP)
                        )
                    )
                    .WireTo(new Statusbar()
                        .WireTo(new Text() { Color = Brushes.Green }
                            .WireFrom(new LiteralString("Connected to device"))
                        )
                    )
                );


            getInfoWizard
                .WireTo(new WizardItem("Get selected session files") { Icon = "IconSession.png", Checked = true }
                    .WireTo(new Wizard("Select destination") { SecondTitle = "What do you want to do with the session files?", ShowBackButton = true }
                        .WireTo(new WizardItem("Save selected sessions as files on the PC") { Icon = "SessionDocumentIcon.png", Checked = true }
                            .WireTo(new SaveFileBrowser("Select location to save data") { Icon = "SaveIcon.png", InitialPath = "%ProgramData%\XYZCompany"}
                                .WireTo(csvFileReaderWriter)
                            )
                        )
                        .WireTo(new WizardItem("Send records to NAIT") { Icon = "NAIT.png" })
                        .WireTo(new WizardItem("Send sessions to NLIS") { Icon = "NLIS.png" })
                    )
                    .WireTo(getInfoWizard)
                )
                .WireTo(new WizardItem("Get Lifedata"));

            var comPorts =
                new ComPortAdapter()
                    .WireTo(new SCPProtocol()
                        .WireTo(new SessionDataSCP()
                            .WireTo(DataGrid)
                            .WireTo(csvFileReaderWriter)
                        )

                    );

        }
    }
}</pre>
</div>
</div>
<div class="paragraph">
<p>We used a 'diagram first' rule to keep the diagram and code in sync. Change the diagram first, then change the wiring code.</p>
</div>
<div class="paragraph">
<p>As of this writing, a graphical IDE is being developed for these types of ALA applications.</p>
</div>
<div class="paragraph">
<p>da</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2022-06-04 12:06:11 01200
</div>
</div>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/styles/github.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/highlight.min.js"></script>
<script>hljs.initHighlighting()</script>
</body>
</html>